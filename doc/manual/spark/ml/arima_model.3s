.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "ARIMAModel" "" "" "" ""
.hy
.SH NAME
.PP
ARIMAModel - A data structure used for modeling the output of ARIMA
algorithm from frovedis server to spark client wrapper.
.SH SYNOPSIS
.PP
import com.nec.frovedis.mllib.tsa.arima.ARIMAModel
.SS Public Member Functions
.PP
\f[V]org.apache.spark.sql.DataFrame\f[R] predict (Long start, Long end)
.PD 0
.P
.PD
\f[V]org.apache.spark.sql.DataFrame\f[R] forecast (Long steps)
.PD 0
.P
.PD
\f[V]org.apache.spark.sql.DataFrame\f[R] fittedvalues ()
.PD 0
.P
.PD
Unit release()
.SH DESCRIPTION
.PP
ARIMAModel models the output of the frovedis ARIMA timeseries prediction
algorithm, the fit interface of ARIMA aims to optimize an initial model
and outputs the same after optimization.
.PP
Note that the actual model with given parameters like order etc.
is created at frovedis server only.
Spark ARIMAModel contains a unique ID associated with the frovedis
server side model.
It simply works like a pointer to the in-memory model at frovedis
server.
.PP
Any operations, like prediction etc.
on a ARIMAModel makes a request to the frovedis server along with the
unique model ID and the actual job is served by the frovedis server.
For functions which returns some output, the result is sent back from
frovedis server to the spark client.
.SS Public Member Function Documentation
.SS 1. \f[V]org.apache.spark.sql.DataFrame\f[R] predict (Long start, Long end)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]start\f[B]\f[R]: This parameter can be an integer.
It specifies the starting index
.PD 0
.P
.PD
from which the values are to be predicted.
(Default: 0)
.PD 0
.P
.PD
\f[B]\f[BI]stop\f[B]\f[R]: This parameter can be an integer.
It specifies the index till which
.PD 0
.P
.PD
the values are to be predicted.
(Default: Index of last element in dataset)
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to perform in-sample prediction and out-of-sample prediction
at frovedis server.
.PP
\f[B]During prediction, end index must not be less than start
index.\f[R]
.PP
Below mentioned examples show frovedis ARIMAModel being used to perform
in-sample and out-sample predictions.
.PP
\f[B]Perform in-sample and out-sample predictions endog being an RDD of
Float or Double input.\f[R]
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# perform in-sample prediction with start and end
val predicted_values = model.predict(start = 4, end = 5)
println(\[dq]In-sample predictions:\[dq])
predicted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
In-sample predictions:
+-----+------------------+
|index|    predicted_mean|
+-----+------------------+
|    4|2.9856736597237106|
|    5|39.075471086355975|
+-----+------------------+
\f[R]
.fi
.PP
\f[B]When start and end are negative indices to perform in-sample
prediction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# perfrom in-sample prediction with start and end as negative indices
val predicted_values = model.predict(start = -2, end = -1)
println(\[dq]In-sample prediction with negative indices:\[dq])
predicted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
In-sample prediction with negative indices:
+-----+------------------+
|index|    predicted_mean|
+-----+------------------+
|   10|20.085332914693463|
|   11|15.014777413995532|
+-----+------------------+
\f[R]
.fi
.PP
\f[B]Note:\f[R] Here, negative indices can only be used to perform
in-sample predictions.
.PP
\f[B]When start and end are integers to perfrom out-sample
prediction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# perform out-sample prediction with start and end as integers
val predicted_values = model.predict(start = 12, end = 13)
println(\[dq]Out-sample predictions:\[dq])
predicted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Out-sample predictions:
+-----+-----------------+
|index|   predicted_mean|
+-----+-----------------+
|   12| 9.59804015203159|
|   13|4.378840440410923|
+-----+-----------------+
\f[R]
.fi
.PP
\f[B]Perform in-sample and out-sample predictions endog being a spark
dataframe\f[R]
.PP
For example,
.IP
.nf
\f[C]
# loading an spark dataframe
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog = (Seq(2,4,6,8,10,12,14,16,18,20,22,24) zip 
            Seq(10.5,15.0,20.0,25.5,35.5,45.0,40.5,35.5,30.5,25.5,20.5,15.0))
           .toDF(\[dq]Id\[dq], \[dq]MonthlyTemperature\[dq])
# fitting input dataframe on ARIMA object
var model = new ARIMA(order = List(2,1,2), targetCol = \[dq]MonthlyTemperature\[dq], indexCol = \[dq]Id\[dq])
                              .fit(endog)
# displaying the fittedvalues
val fitted_values = model.fittedvalues()

# perform in-sample prediction with start and end
val predicted_values = model.predict(start = 4, end = 5)
println(\[dq]In-sample predictions:\[dq])
predicted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
In-sample predictions:
+-----+------------------+
|index|    predicted_mean|
+-----+------------------+
|   10|2.9856736597237106|
|   12|39.075471086355975|
+-----+------------------+
\f[R]
.fi
.PP
\f[B]When start and end are negative indices to perform in-sample
prediction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# perfrom in-sample prediction with start and end as negative indices
val predicted_values = model.predict(start = -2, end = -1)
println(\[dq]In-sample prediction with negative indices:\[dq])
predicted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
In-sample prediction with negative indices:
+-----+------------------+
|index|    predicted_mean|
+-----+------------------+
|   22|20.085332914693463|
|   24|15.014777413995532|
+-----+------------------+
\f[R]
.fi
.PP
\f[B]Note:\f[R] Here, negative indices can only be used to perform
in-sample predictions.
.PP
\f[B]When start and end are integers to perfrom out-sample
prediction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# perform out-sample prediction with start and end as integers
val predicted_values = model.predict(start = 12, end = 13)
println(\[dq]Out-sample predictions:\[dq])
predicted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Out-sample predictions:
+-----+-----------------+
|index|   predicted_mean|
+-----+-----------------+
|   26| 9.59804015203159|
|   28|4.378840440410923|
+-----+-----------------+
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
- It returns a spark dataframe.
.SS 2. \f[V]org.apache.spark.sql.DataFrame\f[R] forecast(Long steps)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]steps\f[B]\f[R]: This parameter is a positive integer.
It specifies the number of out of sample values to be predicted.
(Default: 1)
.PD 0
.P
.PD
\f[B]NOTE:\f[R] steps must be atleast 1.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to perform out of sample forecasting.
.PP
Below mentioned examples show frovedis ARIMAModel to be used to perform
forecasting.
.PP
\f[B]Performing forecasting when endog is RDD input.\f[R]
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# perform forecasting
val forecasted_values = model.forecast(steps = 2)
println(\[dq]Forecast:\[dq])
forecasted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Forecast:
+-----+-----------------+
|index|   predicted_mean|
+-----+-----------------+
|   12| 9.59804015203159|
|   13|4.378840440410923|
+-----+-----------------+
\f[R]
.fi
.PP
\f[B]Performing forecasting when endog is spark dataframe.\f[R]
.PP
For example,
.IP
.nf
\f[C]
# loading an spark dataframe
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog = (Seq(2,4,6,8,10,12,14,16,18,20,22,24) zip 
            Seq(10.5,15.0,20.0,25.5,35.5,45.0,40.5,35.5,30.5,25.5,20.5,15.0))
           .toDF(\[dq]Id\[dq], \[dq]MonthlyTemperature\[dq])
# fitting input dataframe on ARIMA object
var model = new ARIMA(order = List(2,1,2), targetCol = \[dq]MonthlyTemperature\[dq], indexCol = \[dq]Id\[dq])
                              .fit(endog)

# perform forecasting
val forecasted_values = model.forecast(steps = 2)
println(\[dq]Forecast:\[dq])
forecasted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Forecast:
+-----+-----------------+
|index|   predicted_mean|
+-----+-----------------+
|   26| 9.59804015203159|
|   28|4.378840440410923|
+-----+-----------------+
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
- It returns a spark dataframe.
.SS 3. \f[V]org.apache.spark.sql.DataFrame\f[R] fittedvalues()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to get the generated fitted values after fitting.
.PP
Below mentioned example shows use of fittedvalues method.
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# get fitted values
val fitted_values = model.fittedvalues()
println(\[dq]Fitted values:\[dq])
fitted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Fitted values:
+-----+------------------+
|index|                  |
+-----+------------------+
|    0|               0.0|
|    1|               0.0|
|    2|               0.0|
|    3| 2.656587032568032|
|    4|2.9856736597237106|
|    5|39.075471086355975|
|    6| 46.74116210912707|
|    7| 33.34402185820186|
|    8| 32.46163584927344|
|    9|24.824135902546068|
|   10|20.512681101065784|
|   11|  15.5408920934298|
+-----+------------------+

# loading a spark dataframe
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog = (Seq(2,4,6,8,10,12,14,16,18,20,22,24) zip 
            Seq(10.5,15.0,20.0,25.5,35.5,45.0,40.5,35.5,30.5,25.5,20.5,15.0))
           .toDF(\[dq]Id\[dq], \[dq]MonthlyTemperature\[dq])
# fitting input dataframe on ARIMA object
var model = new ARIMA(order = List(2,1,2), targetCol = \[dq]MonthlyTemperature\[dq], indexCol = \[dq]Id\[dq])
                              .fit(endog)
# displaying the fittedvalues
val fitted_values = model.fittedvalues()
println(\[dq]Fitted values\[dq])
fitted_values.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Fitted values:
+-----+------------------+
|index|                  |
+-----+------------------+
|    2|               0.0|
|    4|               0.0|
|    6|               0.0|
|    8| 2.656587032568032|
|   10|2.9856736597237106|
|   12|39.075471086355975|
|   14| 46.74116210912707|
|   16| 33.34402185820186|
|   18| 32.46163584927344|
|   20|24.824135902546068|
|   22|20.512681101065784|
|   24|  15.5408920934298|
+-----+------------------+
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
- It returns a spark dataframe.
.SS 4. Unit release()
.PP
This function can be used to release the existing in-memory model in
frovedis server.
.PP
Below mentioned example shows use of release method.
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# get fitted values
val fitted_values = model.fittedvalues()

# release model
model.release()
\f[R]
.fi
.SH SEE ALSO
.PP
\f[B]ARIMA\f[R]
