.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "ARIMAModel" "" "" "" ""
.hy
.SH NAME
.PP
ARIMAModel - A data structure used for modeling the output of ARIMA
algorithm from frovedis server to spark client wrapper.
.SH SYNOPSIS
.PP
import com.nec.frovedis.mllib.tsa.arima.ARIMAModel
.SS Public Member Functions
.PP
\f[V]Array[Double]\f[R] predict (Long start, Long end, Boolean dynamic)
.PD 0
.P
.PD
\f[V]Array[Double]\f[R] forecast (Long steps)
.PD 0
.P
.PD
\f[V]Array[Double]\f[R] fittedvalues ()
.PD 0
.P
.PD
Unit release()
.SH DESCRIPTION
.PP
ARIMAModel models the output of the frovedis ARIMA timeseries prediction
algorithm, the fit interface of ARIMA aims to optimize an initial model
and outputs the same after optimization.
.PP
Note that the actual model with given parameters like order etc.
is created at frovedis server only.
Spark ARIMAModel contains a unique ID associated with the frovedis
server side model.
It simply works like a pointer to the in-memory model at frovedis
server.
.PP
Any operations, like prediction etc.
on a ARIMAModel makes a request to the frovedis server along with the
unique model ID and the actual job is served by the frovedis server.
For functions which returns some output, the result is sent back from
frovedis server to the spark client.
.SS Public Member Function Documentation
.SS 1. \f[V]Array[Double]\f[R] predict (Long start, Long end, Boolean dynamic)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]start\f[B]\f[R]: This parameter can be an integer.
It specifies the starting index from which the values are to be
predicted.
(Default: 0)
.PD 0
.P
.PD
\f[B]\f[BI]stop\f[B]\f[R]: This parameter can be an integer.
It specifies the index till which the values are to be predicted.
(Default: Index of last element in dataset)
.PD 0
.P
.PD
\f[B]\f[BI]dynamic\f[B]\f[R]: An unused parameter.
(Default: false)
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to perform in-sample prediction and out-of-sample prediction
at frovedis server.
.PP
\f[B]During prediction, end index must not be less than start
index.\f[R]
.PP
Below mentioned examples show frovedis ARIMAModel being used to perform
in-sample and out-sample predictions.
.PP
\f[B]Perform in-sample and out-sample predictions endog being an RDD of
Float or Double input.\f[R]
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# perform in-sample prediction with start and end
val predicted_values = model.predict(start = 4, end = 5)
println(\[dq]In-sample predictions:\[dq])
predicted_values.foreach(println)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
In-sample predictions:
2.9856736597237106
39.075471086355975
\f[R]
.fi
.PP
\f[B]When start and end are negative indices to perform in-sample
prediction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# perfrom in-sample prediction with start and end as negative indices
val predicted_values = model.predict(start = -2, end = -1)
println(\[dq]In-sample prediction with negative indices:\[dq])
predicted_values.foreach(println)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
In-sample prediction with negative indices:
20.085332914693463
15.014777413995532
\f[R]
.fi
.PP
\f[B]Note:\f[R] Here, negative indices can only be used to perform
in-sample predictions.
.PP
\f[B]When start and end are integers to perfrom out-sample
prediction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# perform out-sample prediction with start and end as integers
val predicted_values = model.predict(start = 12, end = 13)
println(\[dq]Out-sample predictions:\[dq])
predicted_values.foreach(println)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Out-sample predictions:
9.59804015203159
4.378840440410923
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
- It returns an array of doubles.
.SS 2. \f[V]Array[Double]\f[R] forecast(Long steps)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]steps\f[B]\f[R]: This parameter is a positive integer.
It specifies the number of out of sample values to be predicted.
(Default: 1)
.PD 0
.P
.PD
\f[B]NOTE:\f[R] steps must be atleast 1.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to perform out of sample forecasting.
.PP
Below mentioned examples show frovedis ARIMAModel to be used to perform
forecasting.
.PP
\f[B]Performing forecasting when endog is RDD input.\f[R]
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# perform forecasting
val forecasted_values = model.forecast(steps = 2)
println(\[dq]Forecast:\[dq])
forecasted_values.foreach(println)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Forecast:
9.59804015203159
4.378840440410923
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
- It returns an array of doubles.
.SS 3. \f[V]Array[Double]\f[R] fittedvalues()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to get the generated fitted values after fitting.
.PP
Below mentioned example shows use of fittedvalues method.
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# get fitted values
val fitted_values = model.fittedvalues()
println(\[dq]Fitted values:\[dq])
fitted_values.foreach(println)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Fitted values:
0.0
0.0
0.0
2.656587032568032
2.9856736597237106
39.075471086355975
46.74116210912707
33.34402185820186
32.46163584927344
24.824135902546068
20.512681101065784
15.5408920934298
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
- It returns an array of doubles.
.SS 4. Unit release()
.PP
This function can be used to release the existing in-memory model in
frovedis server.
.PP
Below mentioned example shows use of release method.
.PP
For example,
.IP
.nf
\f[C]
# loading an RDD[Double] data
import com.nec.frovedis.mllib.tsa.arima.ARIMA
val endog:RDD[Double] = sc.parallelize(Array(10.5,15.0,20.0,25.5,35.5,45.0,
                            40.5,35.5,30.5,25.5,20.5,15.0))

# fitting RDD data on ARIMA object
val model = new ARIMA(order = List(2,1,2)).fit(endog)

# get fitted values
val fitted_values = model.fittedvalues()

# release model
model.release()
\f[R]
.fi
.SH SEE ALSO
.PP
\f[B]ARIMA\f[R]
