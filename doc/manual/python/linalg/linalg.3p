.TH "linalg" "" "" "" ""
.SH NAME
.PP
linalg \- a frovedis module which provides user\-friendly interfaces for
commonly used linear algebra functions.
.SH SYNOPSIS
.IP
.nf
\f[C]
import\ frovedis.linalg.linalg
\f[]
.fi
.SH Public Member Functions
.IP
.nf
\f[C]
1.\ dot(a,\ b,\ out=None)
2.\ eigsh(A,\ M=None,\ k=6,\ sigma=None,\ which=\[aq]LM\[aq],\ v0=None,\ ncv=None,\ maxiter=None,\ 
\ \ \ \ \ \ \ \ \ tol=0.,\ return_eigenvectors=True,\ Minv=None,\ OPinv=None,\ mode=\[aq]normal\[aq])
3.\ inv(a)
4.\ matmul(x1,\ x2,\ out=None,\ casting=\[aq]same_kind\[aq],\ order=\[aq]K\[aq],\ dtype=None,\ 
\ \ \ \ \ \ \ \ \ \ subok=True,\ signature=None,\ extobj=None)
5.\ solve(a,\ b)
6.\ svd(a,\ full_matrices=False,\ compute_uv=True)
\f[]
.fi
.SH DESCRIPTION
.PP
The frovedis linear algebra functions rely on PBLAS and ScaLAPACK
wrappers in frovedis to provide efficient low level implementations of
standard linear algebra algorithms.
These functions are used to compute matrices and vector product, matrix
decompostion, solving linear equations, inverting matrices, etc.
.PP
This module provides a client\-server implementation, where the client
application is a normal python program.
The frovedis interface for all linear algebra functions is almost same
as numpy linear algebra function interfaces, but it doesn\[aq]t have any
dependency on numpy.
It can be used simply even if the system doesn\[aq]t have numpy
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python matrix data to frovedis
server side.
Python data is converted into frovedis compatible data (blockcyclic
matrix) internally and then python client can request frovedis server
for any of the supported linalg functions on that matrix.
Once the operation is completed, the frovedis server sends back the
resultant matrix as equivalent python data.
.SS Detailed Description
.SS 1. dot(a, b, out = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts scalar values and python array\-like
inputs (having dimensions <= 2) of int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts scalar values, and python array\-like
inputs (having dimensions <= 2) of int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]out\f[]\f[]: A numpy ndarray of int, float (float32) or double
(float64) type values which is where the result is written.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), a freshly\-allocated array
having double (float64) type values is returned.
Otherwise if provided, it must have a shape that matches the signature
(n,k),(k,m)\->(n,m) and same datatype as input matrices.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes dot product of two arrays.
.PP
\f[B]1. If both inputs \[aq]a\[aq] and \[aq]b\[aq] are scalar
values,\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ dot()\ demo\ with\ scalar\ values\ as\ input
from\ frovedis.linalg\ import\ dot
prod\ =\ dot(3,4)
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
12
\f[]
.fi
.PP
Here, result is also a scalar value.
.PP
\f[B]2. If both \[aq]a\[aq] and \[aq]b\[aq] are 1D arrays,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ dot
vec1\ =\ np.array([1.,\ 9.,\ 8.])
vec2\ =\ np.array([4.,\ 1.,\ 7.])\ \ \ \ 

#\ dot()\ demo\ with\ both\ inputs\ as\ 1D\ array
prod\ =\ dot(vec1,vec2)
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
69.0
\f[]
.fi
.PP
Here, dot product is the inner product of vectors.
.PP
\f[B]3. If either \[aq]a\[aq] or \[aq]b\[aq] is a scalar value,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ dot
vec1\ =\ np.array([[1,\ 9,\ 8],\ [7,\ 1,\ 5],\ [1,\ 2,\ 4]])

#\ dot()\ demo\ with\ 1D\ array\ and\ scalar\ value\ as\ input
prod\ =\ dot(vec1,4)
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 4.\ 36.\ 32.]
\ [28.\ \ 4.\ 20.]
\ [\ 4.\ \ 8.\ 16.]]
\f[]
.fi
.PP
Here, result is multiplication of scalar over the vector.
.PP
\f[B]4. If both a and b are 2D arrays,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ dot
mat1\ =\ np.array([[1,\ 9,\ 8],\ [7,\ 1,\ 5],\ [1,\ 2,\ 4]])
mat2\ =\ np.array([[4,\ 1,\ 7],\ [2,\ 2,\ 9],\ [1,\ 2,\ 3]])

#\ dot()\ demo\ with\ 2D\ arrays\ as\ input
prod\ =\ dot(mat1,\ mat2)
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 30.\ \ 35.\ 112.]
\ [\ 35.\ \ 19.\ \ 73.]
\ [\ 12.\ \ 13.\ \ 37.]]
\f[]
.fi
.PP
Here, result is simply matrix multiplication.
.PP
\f[B]When both \[aq]a\[aq] and \[aq]b\[aq] inputs are matrices or
instances of FrovedisBlockCyclicMatrix, then the column size of
\[aq]a\[aq] must be same as row size of \[aq]b\[aq] before computing dot
product as internally it performs matrix\-matrix multiplication.\f[]
.PP
\f[B]5. If a is an ND array and b is a 1\-D array,\f[]
.PP
Currenlty, frovedis supports only N <= 2, so that dot() between ND array
and 1D array can be interpreted currently as:
.PD 0
.P
.PD
\- dot product between both 1D arrays.
.PD 0
.P
.PD
\- dot product between 2D array and 1D array.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ dot
mat1\ =\ np.array([[1,\ 9,\ 8],\ [7,\ 1,\ 5],\ [1,\ 2,\ 4]])
mat2\ =\ np.array([4,\ 2,\ 1])

#\ dot()\ demo\ with\ \[aq]a\[aq]\ as\ 2D\ array,\ \[aq]b\[aq]\ as\ 1D\ array\ as\ input
prod\ =\ dot(mat1,\ mat2)
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[30.\ 35.\ 12.]
\f[]
.fi
.PP
In above example, result will be the sum product over the last axis of
\[aq]a\[aq] and \[aq]b\[aq].
.PP
\f[B]Currently, dot product between inputs \[aq]a\[aq] (an N\-D array)
and \[aq]b\[aq] (an M\-D array (where M>=2) is not supported in
frovedis.\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ dot
mat1\ =\ np.array([[1.,\ 9.,\ 8.],\ [7.,\ 1.,\ 5.],\ [1.,\ 2.,\ 4.]])
mat2\ =\ np.array([[4.,\ 1.,\ 7.],\ [2.,\ 2.,\ 9.],\ [1.,\ 2.,\ 3.]])

#\ dot()\ demo\ with\ out\ !=\ None
prod\ =\ dot(mat1,\ mat2,\ out\ =\ np.array([[1.,\ 1.,\ 1.],[1.,\ 1.,\ 1.],[1.,\ 1.,\ 1.]]))
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 30.\ \ 35.\ 112.]
\ [\ 35.\ \ 19.\ \ 73.]
\ [\ 12.\ \ 13.\ \ 37.]]
\f[]
.fi
.PP
Here, the result will be written in the user provided ndarray and shape
and datatype same as input matrix.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ dot
mat1\ =\ np.array([[1,\ 9,\ 8],\ [7,\ 1,\ 5],\ [1,\ 2,\ 4]])
mat2\ =\ np.array([[4,\ 1,\ 7],\ [2,\ 2,\ 9],\ [1,\ 2,\ 3]])

#\ creating\ FrovedisBlockcyclicMatrix\ instance
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
A_Bmat\ =\ FrovedisBlockcyclicMatrix(mat1,\ np.float64)
B_Bmat\ =\ FrovedisBlockcyclicMatrix(mat2,\ np.float64)

#\ dot()\ demo\ with\ FrovedisBlockcyclicMatrix\ instance\ 
prod\ =\ dot(A_Bmat,\ B_Bmat)
prod.debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 30\ 35\ 12\ 35\ 19\ 13\ 112\ 73\ 37
\f[]
.fi
.PP
\f[B]This output will be only visible on server side terminal.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns the dot product of \[aq]a\[aq] and \[aq]b\[aq].
.PD 0
.P
.PD
If \[aq]a\[aq] and \[aq]b\[aq] are both scalars or both 1\-D arrays then
a scalar is returned.
Otherwise, an array is returned.
.PD 0
.P
.PD
If out is given, then it is returned.
.PD 0
.P
.PD
If either \[aq]a\[aq] or \[aq]b\[aq] is a FrovedisBlockCyclicMatrix
instance, then it returns a FrovedisBlockCyclicMatrix instance.
.SS 2. eigsh(A, M = None, k = 6, sigma = None, which = \[aq]LM\[aq], v0
= None, ncv = None, maxiter = None, tol = 0., return_eigenvectors =
True, Minv = None, OPinv = None, mode = \[aq]normal\[aq])
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]A\f[]\f[]: A numpy dense or scipy sparse matrix or any python
array\-like object or an instance of FrovedisCRSMatrix for sparse data
and FrovedisRowmajorMatrix for dense data.
The input matrix provided must be squared symmetric in nature.
.PD 0
.P
.PD
\f[I]\f[B]M\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]k\f[]\f[]: A positive integer parameter that specifies the
number of eigenvalues and eigenvectors desired.
It must be in range 0 to N, where N is the number of rows in squared
symmetric matrix.
(Default: 6)
.PD 0
.P
.PD
\f[I]\f[B]sigma\f[]\f[]: It accepts a float (float32) type parameter
that is used to find eigenvalues near sigma using shift\-invert mode.
Currently, it is only supported for dense matrices.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as largest
possible value of float (float32) type.
.PD 0
.P
.PD
\f[I]\f[B]which\f[]\f[]: A string object parameter that specifies which
\f[B]k\f[] eigenvectors and eigenvalues to find:
.PD 0
.P
.PD
\- \f[B]\[aq]LM\[aq]\f[] : Largest (in magnitude) eigenvalues.
It is the default value.
.PD 0
.P
.PD
\- \f[B]\[aq]SM\[aq]\f[] : Smallest (in magnitude) eigenvalues.
.PD 0
.P
.PD
\- \f[B]\[aq]LA\[aq]\f[] : Largest (algebraic) eigenvalues.
.PD 0
.P
.PD
\- \f[B]\[aq]SA\[aq]\f[] : Smallest (algebraic) eigenvalues.
.PD 0
.P
.PD
\- \f[B]\[aq]BE\[aq]\f[] : Half (k/2) from each end of the spectrum.
.PP
When sigma != None, \[aq]which\[aq] refers to the shifted eigenvalues.
.PD 0
.P
.PD
\f[I]\f[B]v0\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]ncv\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]maxiter\f[]\f[]: A positive integer that specifies the maximum
number of iterations allowed.
The convergance may occur on or before the maximum iteration limit is
reached.
In case, the convergance does not occur before the iteration limit, then
this method will not generate the resultant \f[B]\[aq]k\[aq]\f[]
eigenvalues and eigenvectors.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as 10 * N,
where N is the number of rows in squared symmetric matrix.
.PD 0
.P
.PD
\f[I]\f[B]tol\f[]\f[]: A float (float32) type parameter that specifies
the tolerance values used to find relative accuracy for eigenvalues
(stopping criterion).
(Default: 0.)
.PD 0
.P
.PD
\f[I]\f[B]return_eigenvectors\f[]\f[]: A boolean parameter that
specifies whether to return eigenvectors in addition to eigenvalues.
(Default: True)
.PD 0
.P
.PD
When it is set to False, it will only return \f[B]k\f[] eigenvalues.
.PD 0
.P
.PD
\f[I]\f[B]Minv\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]OPinv\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]mode\f[]\f[]: A string object parameter that specifies the
strategy to use for shift\-invert mode.
This parameter applies only when sigma != None.
This parameter can be \f[B]\[aq]normal\[aq]\f[],
\f[B]\[aq]cayley\[aq]\f[] or \f[B]\[aq]buckling\[aq] modes\f[].
\f[B]Currently, frovedis supports only normal mode\f[].
(Default: \[aq]normal\[aq])
.PD 0
.P
.PD
The choice of mode will affect which eigenvalues are selected by the
\[aq]which\[aq] parameter.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It finds \f[B]k\f[] eigenvalues and eigenvectors of the symmetric square
matrix A.
.PP
The parameters: "M", "vc0", "ncv", "Minv" and "OPinv" are simply kept in
to to make the interface uniform to the scipy.sparse.linalg.eigsh()
module.
They are not used anywhere within the frovedis implementation.
.PP
For example,
.IP
.nf
\f[C]
#\ dense\ square\ symmetric\ matrix
import\ numpy\ as\ np
mat\ =\ np.asarray([[2.,\-1.,0.,0.,\-1.,0.],\ [\-1.,3.,\-1.,0.,\-1.,0.],\ [0.,\-1.,2.,\-1.,0.,0.],
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [0.,0.,\-1.,3.,\-1.,\-1],\ [\-1.,\-1.,0.,\-1.,3.,0],\ [0.,0.,0.,\-1.,0.,1.]])

#\ eigsh()\ demo
from\ frovedis.linalg\ import\ eigsh
eigen_vals,\ eigen_vecs\ =\ eigsh(mat,\ k\ =\ 3)
print("frovedis\ computed\ eigen\ values:\\n")
print(eigen_vals)
print("\\nfrovedis\ computed\ eigen\ vectors:\\n")
print(eigen_vecs)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
frovedis\ computed\ eigen\ values:

[3.\ \ \ \ \ \ \ \ \ 3.70462437\ 4.89121985]

frovedis\ computed\ eigen\ vectors:

[[\-0.28867513\ \ 0.56702343\ \ 0.03232265]
\ [\-0.28867513\ \-0.65812747\ \ 0.46850031]
\ [\-0.28867513\ \ 0.20514371\ \-0.35640753]
\ [\ 0.57735027\ \ 0.30843449\ \ 0.56195221]
\ [\ 0.57735027\ \-0.30843449\ \-0.56195221]
\ [\-0.28867513\ \-0.11403968\ \-0.14441544]]
\f[]
.fi
.PP
Since, input dense matrix has shape (3,3), so 0< k <=3.
.PP
For example,
.IP
.nf
\f[C]
#\ eigsh()\ demo\ when\ sigma\ !=\ None
eigen_vals,\ eigen_vecs\ =\ eigsh(mat,\ k\ =\ 3,\ sigma\ =\ \-1)
print("frovedis\ computed\ eigen\ values:\\n")
print(eigen_vals)
print("\\nfrovedis\ computed\ eigen\ vectors:\\n")
print(eigen_vecs)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
frovedis\ computed\ eigen\ values:

[0.\ \ \ \ \ \ \ \ \ 0.72158639\ 1.68256939]

frovedis\ computed\ eigen\ vectors:

[[\ 0.40824829\ \ 0.41486979\ \-0.50529469]
\ [\ 0.40824829\ \ 0.30944167\ \ 0.04026854]
\ [\ 0.40824829\ \ 0.0692328\ \ \ 0.75901025]
\ [\ 0.40824829\ \-0.22093352\ \ 0.20066454]
\ [\ 0.40824829\ \ 0.22093352\ \-0.20066454]
\ [\ 0.40824829\ \-0.79354426\ \-0.29398409]]
\f[]
.fi
.PP
Here, the resultant eigenvalues and eigenvectors are generated using
shift invert mode.
.PP
For example,
.IP
.nf
\f[C]
#\ eigsh()\ demo\ where\ which\ =\ \[aq]SM\[aq]
eigen_vals,\ eigen_vecs\ =\ eigsh(mat,\ k\ =\ 3,\ which\ =\ \[aq]SM\[aq])
print("frovedis\ computed\ eigen\ values:\\n")
print(eigen_vals)
print("\\nfrovedis\ computed\ eigen\ vectors:\\n")
print(eigen_vecs)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
frovedis\ computed\ eigen\ values:

[2.70826973e\-16\ 7.21586391e\-01\ 1.68256939e+00]

frovedis\ computed\ eigen\ vectors:

[[\ 0.40824829\ \ 0.41486979\ \ 0.50529469]
\ [\ 0.40824829\ \ 0.30944167\ \-0.04026854]
\ [\ 0.40824829\ \ 0.0692328\ \ \-0.75901025]
\ [\ 0.40824829\ \-0.22093352\ \-0.20066454]
\ [\ 0.40824829\ \ 0.22093352\ \ 0.20066454]
\ [\ 0.40824829\ \-0.79354426\ \ 0.29398409]]
\f[]
.fi
.PP
Here, the resultant eigenvalues and eigenvectors are smallest in
magnitute for the given dense input matrix.
.PP
For example,
.IP
.nf
\f[C]
#\ eigsh()\ demo\ where\ maxiter\ =\ 10
eigen_vals,\ eigen_vecs\ =\ eigsh(mat,\ k\ =\ 3,\ maxiter\ =\ 10)
print("frovedis\ computed\ eigen\ values:\\n")
print(eigen_vals)
print("\\nfrovedis\ computed\ eigen\ vectors:\\n")
print(eigen_vecs)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
frovedis\ computed\ eigen\ values:

[3.\ \ \ \ \ \ \ \ \ 3.70462437\ 4.89121985]

scipy\ computed\ eigen\ vectors:

[[\-0.28867513\ \ 0.56702343\ \ 0.03232265]
\ [\-0.28867513\ \-0.65812747\ \ 0.46850031]
\ [\-0.28867513\ \ 0.20514371\ \-0.35640753]
\ [\ 0.57735027\ \ 0.30843449\ \ 0.56195221]
\ [\ 0.57735027\ \-0.30843449\ \-0.56195221]
\ [\-0.28867513\ \-0.11403968\ \-0.14441544]]
\f[]
.fi
.PP
The eigenvalues and eigenvectors will be generated only when convergence
occurs.
.PD 0
.P
.PD
In above example, this will happen on or before maxiter = 10 is reached.
.PP
For example,
.IP
.nf
\f[C]
#\ eigsh()\ demo\ where\ return_eigenvectors\ =\ False
eigen_vals\ =\ eigsh(mat,\ k\ =\ 3,\ return_eigenvectors\ =\ False)
print("frovedis\ computed\ eigen\ values:\\n")
print(eigen_vals)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
frovedis\ computed\ eigen\ values:

[3.\ \ \ \ \ \ \ \ \ 3.70462437\ 4.89121985]
\f[]
.fi
.PP
Here, only eigenvalues are returned by this method.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If return_eigenvectors = True:\f[]
.PD 0
.P
.PD
\- It returns eigenvectors in addition to eigenvalues as numpy ndarrays
having double (float64) type values.
Also, eigenvectors has shape \f[B](k,1)\f[] and eigenvalues has shape
\f[B](M,k)\f[], where \f[B]M\f[] is the number of rows of input matrix
\[aq]A\[aq].
.PD 0
.P
.PD
2.
\f[B]If return_eigenvectors = False:\f[]
.PD 0
.P
.PD
\- It returns only eigenvalues as numpy ndarray having shape
\f[B](k,1)\f[] and double (float64) type values.
.SS 3. inv(a)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or numpy
matrix (having dimensions <= 2) of int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It specifies the matrix to be inverted.
It must be a square matrix of shape \f[B](M, M)\f[] , where \f[B]M\f[]
is the number of rows and columns of input squared matrix.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method computes the inverse matrix of a given matrix.
.PP
Internally it uses \f[B]getrf()\f[] and \f[B]getri()\f[] methods present
in \f[B]frovedis.linalg.scalapack\f[] module.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ inv

#\ input\ array\ contains\ integer\ values
mat\ =\ np.array([[1,\ 2],\ [3,\ 4]])

#\ inv(0\ demo\ with\ numpy\ array\ as\ input
matinv\ =\ inv(mat)
print(matinv)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\-2.\ \ \ 1.\ ]
\ [\ 1.5\ \-0.5]]
\f[]
.fi
.PP
It returns an ndarray as the inverse of given matrix having double
(float64) type values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ inv

#\ input\ array\ contains\ float\ (float320\ type\ values
mat\ =\ np.array([[1.,\ 2.],\ [3.,\ 4.]],\ dtype\ =\ np.float32)

#\ inv()\ demo\ with\ numpy\ array\ as\ input
matinv\ =\ inv(mat)
print(matinv)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\-2.0000002\ \ \ 1.0000001\ ]
\ [\ 1.5000001\ \ \-0.50000006]]
\f[]
.fi
.PP
It returns an ndarray as the inverse of given matrix having float
(float32) type values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ inv

#\ input\ array\ contains\ double\ (float64)\ type\ values
mat\ =\ np.array([[1.,\ 2.],\ [3.,\ 4.]])

#\ inv(0\ demo\ with\ numpy\ array\ as\ input
matinv\ =\ inv(mat)
print(matinv)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\-2.\ \ \ 1.\ ]
\ [\ 1.5\ \-0.5]]
\f[]
.fi
.PP
It returns an ndarray as the inverse of given matrix having double
(float64) type values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ inv

#\ creating\ FrovedisBlockcyclicMatrix\ instance\ 
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat\ =\ np.array([[1.,\ 2.],\ [3.,\ 4.]])
A_Bmat\ =\ FrovedisBlockcyclicMatrix(mat)

#\ inv()\ demo\ FrovedisBlockcyclicMatrix\ instance
matinv\ =\ inv(A_Bmat)
matinv.debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
matrix:
num_row\ =\ 2,\ num_col\ =\ 2
node\ 0
node\ =\ 0,\ local_num_row\ =\ 2,\ local_num_col\ =\ 2,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 2\ 2\ 2\ 2\ 0\ 0\ 2\ 2\ 2
val\ =\ \-2\ 1.5\ 1\ \-0.5
\f[]
.fi
.PP
\f[B]This output will be only visible on server side terminal.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]When numpy array\-like input is used\f[]:
.PD 0
.P
.PD
\- It returns a numpy ndarray having float (float32) or double (float64)
type values and has shape \f[B](M, M)\f[], where \f[B]M\f[] is number of
rows and columns of input ndarray.
.PD 0
.P
.PD
2.
\f[B]When input is a numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a numpy matrix having float (float32) or double (float64)
type values and has shape \f[B](M, M)\f[], where \f[B]M\f[] is number of
rows and columns of input matrix.
.PD 0
.P
.PD
3.
\f[B]When input is a FrovedisBlockCyclicMatrix instance\f[]:
.PD 0
.P
.PD
\- It returns an instance of FrovedisBlockCyclicMatrix.
.SS 4. matmul(x1, x2, out = None, casting = \[aq]same_kind\[aq], order =
\[aq]K\[aq], dtype = None, subok = True, signature = None, extobj =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]x1\f[]\f[]: It accepts a python array\-like input or numpy
maxtrix (having dimensions <= 2) of int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It must not be scalar values.
.PD 0
.P
.PD
\f[I]\f[B]x2\f[]\f[]: It accepts scalar values, python array\-like
inputs or numpy maxtrix (having dimensions <= 2) of int, float (float32)
or double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It must not be scalar values.
.PD 0
.P
.PD
\f[I]\f[B]out\f[]\f[]: A numpy ndarray of int, float or double (float64)
type values which is where the result is written.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), a freshly\-allocated array
having double (float64) type values is returned.
Otherwise if provided, it must have a shape that matches the signature
(n,k),(k,m)\->(n,m) and same datatype as input matrices.
.PD 0
.P
.PD
\f[I]\f[B]casting\f[]\f[]: This is an unused parameter.
(Default: \[aq]same_kind\[aq])
.PD 0
.P
.PD
\f[I]\f[B]order\f[]\f[]: This is an unused parameter.
(Default: \[aq]K\[aq])
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]subok\f[]\f[]: This is an unused parameter.
(Default: True)
.PD 0
.P
.PD
\f[I]\f[B]signature\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]extobj\f[]\f[]: This is an unused parameter.
(Default: None)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes matrix product of two arrays.
.PP
The parameters: "casting", "order", "dtype", "subok" and "signature" and
"extobj" are simply kept in to to make the interface uniform to the
numpy.matmul() module.
They are not used anywhere within the frovedis implementation.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ matmul

#\ inputs\ are\ having\ integer\ type\ values
mat1\ =\ np.array([[1,\ 9,\ 8],\ [7,\ 1,\ 5],\ [1,\ 2,\ 4]])
mat2\ =\ np.array([[4,\ 1,\ 7],\ [2,\ 2,\ 9],\ [1,\ 2,\ 3]])

#\ matmul()\ demo\ with\ numpy\ array\ as\ input
prod\ =\ matmul(mat1,\ mat2)
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 30.\ \ 35.\ 112.]
\ [\ 35.\ \ 19.\ \ 73.]
\ [\ 12.\ \ 13.\ \ 37.]]
\f[]
.fi
.PP
Here, the result will be written in a newly generated array having
double (float64) type values.
.PP
\f[B]For inputs \[aq]mat1\[aq] and \[aq]mat2\[aq], the column size of
\[aq]mat1\[aq] must be same as row size of \[aq]mat2\[aq] before
computing matrix multiplication.\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ matmul

#\ inputs\ are\ having\ double\ (float64)\ type\ values
mat1\ =\ np.array([[1.5,\ 9,\ 8],\ [7,\ 1,\ 5.5],\ [1,\ 2.5,\ 4]])
mat2\ =\ np.array([[4,\ 1,\ 7.5],\ [2.5,\ 2,\ 9],\ [1,\ 2,\ 3.5]])

#\ matmul()\ demo\ with\ numpy\ array\ as\ input
prod\ =\ matmul(mat1,\ mat2)
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 36.5\ \ \ 35.5\ \ 120.25]
\ [\ 36.\ \ \ \ 20.\ \ \ \ 80.75]
\ [\ 14.25\ \ 14.\ \ \ \ 44.\ \ ]]
\f[]
.fi
.PP
Here, the result will be written in a newly generated array having
double (float64) type values.
.PP
\f[B]For inputs having float (float32) type values, the newly generated
array will also have float (float32) type values.\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ matmul

mat1\ =\ np.array([[1.,\ 9.,\ 8.],\ [7.,\ 1.,\ 5.],\ [1.,\ 2.,\ 4.]])
mat2\ =\ np.array([[4.,\ 1.,\ 7.],\ [2.,\ 2.,\ 9.],\ [1.,\ 2.,\ 3.]])

#\ matmul()\ demo\ with\ out\ !=\ None
prod\ =\ matmul(mat1,\ mat2,\ out\ =\ np.array([[1.,1.,1.],[1.,1.,1.],[1.,1.,1.]]))
print(prod)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 30.\ \ 35.\ 112.]
\ [\ 35.\ \ 19.\ \ 73.]
\ [\ 12.\ \ 13.\ \ 37.]]
\f[]
.fi
.PP
Here, the result will be written in the user provided ndarray.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ matmul
mat1\ =\ np.array([[1,\ 9,\ 8],\ [7,\ 1,\ 5],\ [1,\ 2,\ 4]])
mat2\ =\ np.array([[4,\ 1,\ 7],\ [2,\ 2,\ 9],\ [1,\ 2,\ 3]])

#\ creating\ FrovedisBlockcyclicMatrix\ instance
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
A_Bmat\ =\ FrovedisBlockcyclicMatrix(mat1,\ np.float64)
B_Bmat\ =\ FrovedisBlockcyclicMatrix(mat2,\ np.float64)

#\ matmul()\ demo\ with\ FrovedisBlockcyclicMatrix\ instance\ 
prod\ =\ matmul(A_Bmat,\ B_Bmat)
prod.debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 30\ 35\ 12\ 35\ 19\ 13\ 112\ 73\ 37
\f[]
.fi
.PP
\f[B]This output will be only visible on server side terminal.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If any python array like input (having dimensions <= 2) and out =
None:\f[]
.PD 0
.P
.PD
\- It returns a numpy ndarray as output and having float (float32) or
double (float64) type values.
.PD 0
.P
.PD
2.
\f[B]If any python array like input (having dimensions <= 2) and out !=
None:\f[]
.PD 0
.P
.PD
\- It returns a numpy ndarray as output.
Datatype for output values will be same as datatype of input
\[aq]x1\[aq] such as int, float (float32) or double (float64) type.
.PD 0
.P
.PD
3.
\f[B]If numpy matrix (having dimensions <= 2) and out = None:\f[]
.PD 0
.P
.PD
\- It returns a numpy matrix as output and having float (float32) or
double (float64) type values.
.PD 0
.P
.PD
4.
\f[B]If numpy matrix (having dimensions <= 2) and out != None:\f[]
.PD 0
.P
.PD
\- It returns a numpy matrix as output.
Datatype for output values will be same as datatype of input
\[aq]x1\[aq] such as int, float (float32) or double (float64) type.
.PD 0
.P
.PD
5.
\f[B]If inputs are FrovedisBlockCyclicMatrix instances:\f[]
.PD 0
.P
.PD
\- It returns a FrovedisBlockCyclicMatrix instance.
.SS 5. solve(a, b)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or numpy
maxtrix (having dimensions <= 2) of int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It specifies a coefficient matrix.
It must be a square matrix of shape \f[B](nRows, nCols)\f[] , where
\f[B]nRows = nCols\f[].
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like inputs or numpy
matrix (having dimensions <= 2) of int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It specifies the variables to be determined while solving the equation
\[aq]Ax = B\[aq].
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This function solves a linear matrix equation Ax = B, or system of
linear scalar equations.
.PP
Internally it uses \f[B]gesv()\f[] method present in
\f[B]frovedis.linalg.scalapack\f[] module.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ solve

#\ inputs\ have\ integer\ type\ values
A\ =\ np.array([[3,4,3],[1,2,3],[4,2,1]])
B\ =\ np.array([[1,1,1],\ [3,0,2],\ [8,2,5]])

#solve()\ demo\ with\ numpy\ array\ input
X\ =\ solve(A,B)
print(X)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 3.57142857\ \ 0.57142857\ \ 2.14285714]
\ [\-4.57142857\ \-0.07142857\ \-2.64285714]
\ [\ 2.85714286\ \-0.14285714\ \ 1.71428571]]
\f[]
.fi
.PP
Here, it returns an array with solution matrix having double (float64)
type values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ solve

#\ inputs\ have\ float\ (float32)\ type\ values
A\ =\ np.array([[3,4,3],[1,2,3],[4,2,1]],\ np.float32)
B\ =\ np.array([[1,1,1],\ [3,0,2],\ [8,2,5]],\ np.float32)

#solve()\ demo\ with\ numpy\ array\ input
X\ =\ solve(A,B)
print(X)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 3.5714288\ \ \ 0.57142854\ \ 2.142857\ \ ]
\ [\-4.571429\ \ \ \-0.07142858\ \-2.6428573\ ]
\ [\ 2.857143\ \ \ \-0.14285713\ \ 1.7142859\ ]]
\f[]
.fi
.PP
Here, it returns an array with solution matrix having float (float32)
type values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ solve

#\ inputs\ have\ integer\ type\ values
A\ =\ np.array([[3.,4.,3.],[1.,2.,3.],[4.,2.,1.]])
B\ =\ np.array([[1.,1.,1.],\ [3.,0.,2.],\ [8.,2.,5.]])

#solve()\ demo\ with\ numpy\ array\ input
X\ =\ solve(A,B)
print(X)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 3.57142857\ \ 0.57142857\ \ 2.14285714]
\ [\-4.57142857\ \-0.07142857\ \-2.64285714]
\ [\ 2.85714286\ \-0.14285714\ \ 1.71428571]]
\f[]
.fi
.PP
Here, it returns an array with solution matrix having double (float64)
type values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ solve
A\ =\ np.array([[3,4,3],[1,2,3],[4,2,1]])
B\ =\ np.array([[1,1,1],\ [3,0,2],\ [8,2,5]])

#creating\ FrovedisBlockCyclicMatrix\ instance
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
A_Bmat\ =\ FrovedisBlockcyclicMatrix(A,\ np.float64)
B_Bmat\ =\ FrovedisBlockcyclicMatrix(B,\ np.float64)

#solve()\ demo\ with\ FrovedisBlockCyclicMatrix\ input
X\ =\ solve(A_Bmat,B_Bmat)
X.debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 3.57143\ \-4.57143\ 2.85714\ 0.571429\ \-0.0714286\ \-0.142857\ 2.14286\ \-2.64286\ 1.71429
\f[]
.fi
.PP
It stores result as a FrovedisBlockCyclicMatrix instance.
.PP
\f[B]Also, this output will be only visible on server side terminal.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]When python array\-like input is used\f[]:
.PD 0
.P
.PD
\- It returns a numpy ndarray having float (float32) or double (float64)
type values and shape \f[B](nRows, nCols)\f[], where \f[B]nRows\f[] is
number of rows and \f[B]nCols\f[] is number of columns of resultant
array.
.PD 0
.P
.PD
2.
\f[B]When input is numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a numpy matrix having float (float32) or double (float64)
type values and shape \f[B](nRows, nCols)\f[], where \f[B]nRows\f[] is
number of rows and \f[B]nCols\f[] is number of columns of resultant
matrix.
.PD 0
.P
.PD
3.
\f[B]When input is a FrovedisBlockCyclicMatrix instance\f[]:
.PD 0
.P
.PD
\- It returns an instance of FrovedisBlockCyclicMatrix.
.SS 6. svd(a, full_matrices = False, compute_uv = True)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts python array\-like inputs or numpy
matrix (having dimensions <= 2) containing int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]full_matrices\f[]\f[]: It is a boolean parameter.
Currently, it can only be set as False.
Also, the unitary 2D arrays \[aq]u\[aq] and \[aq]vh\[aq] shapes are (M,
K) and (K, N), respectively, where \f[B]K = min(M, N)\f[], \f[B]M\f[] is
the number of rows and \f[B]N\f[] is the number of columns of input
matrix.
(Default: False)
.PD 0
.P
.PD
\f[I]\f[B]compute_uv\f[]\f[]: It is a boolean parameter that specifies
whether or not to compute unitary arrays \[aq]u\[aq] and \[aq]vh\[aq] in
addition to 1D array of singular values \[aq]s\[aq].
(Default: True)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the factor of an array by Singular Value Decomposition.
.PP
In a nutshell, this method performs factorization of matrix into three
matrices \[aq]u\[aq], \[aq]vh\[aq] and \[aq]s\[aq].
.PD 0
.P
.PD
Here,
.PD 0
.P
.PD
\- \f[B]u\f[] and \f[B]vh\f[] are orthogonal matrices.
.PD 0
.P
.PD
\- \f[B]s\f[] is a diagonal matrix of singular values.
.PP
This method internally \f[B]gesvd()\f[] method present in
\f[B]frovedis.linalg.scalapack\f[] module.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ svd

#\ input\ is\ having\ integer\ values
mat1\ =\ np.array([[3,4,3],[1,2,3],[4,2,1]])

#\ svd()\ demo\ with\ numpy\ 2D\ array
u,\ s,\ vh\ =\ svd(mat1)
print(u)
print(s)
print(vh)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\-0.73553325\ \-0.18392937\ \-0.65204358]
\ [\-0.42657919\ \-0.62196982\ \ 0.65664582]
\ [\-0.52632788\ \ 0.76113306\ \ 0.37901904]]

[7.87764972\ 2.54031671\ 0.69958986]

[[\-0.60151068\ \ 0.73643349\ \ 0.30959751]
\ [\-0.61540527\ \-0.18005275\ \-0.76737042]
\ [\-0.5093734\ \ \-0.65210944\ \ 0.5615087\ ]]
\f[]
.fi
.PP
Here it returns \[aq]u\[aq], \[aq]s\[aq] and \[aq]vh\[aq] as arrays
having double (float64) dtype values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ svd

#\ input\ is\ having\ float\ (float32)\ type\ values
mat1\ =\ np.array([[3.,4.,3.],[1.,2.,3.],[4.,2.,1.]],\ dtype\ =\ np.float32)

#\ svd()\ demo\ with\ numpy\ 2D\ array
u,\ s,\ vh\ =\ svd(mat1)
print(u)
print(s)
print(vh)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\-0.7355336\ \ \-0.18392955\ \-0.65204364]
\ [\-0.4265793\ \ \-0.62197\ \ \ \ \ 0.656646\ \ ]
\ [\-0.5263281\ \ \ 0.7611333\ \ \ 0.3790189\ ]]
[7.8776484\ 2.540317\ \ 0.69959\ \ ]
[[\-0.60151064\ \ 0.73643357\ \ 0.30959752]
\ [\-0.6154053\ \ \-0.1800527\ \ \-0.76737046]
\ [\-0.5093734\ \ \-0.6521094\ \ \ 0.5615088\ ]]
\f[]
.fi
.PP
Here it returns \[aq]u\[aq], \[aq]s\[aq] and \[aq]vh\[aq] as arrays
having float (float32) dtype values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ svd

#\ input\ is\ having\ double\ (float64)\ type\ values
mat1\ =\ np.array([[3.,4.,3.],[1.,2.,3.],[4.,2.,1.]])

#\ svd()\ demo\ with\ numpy\ 2D\ array
u,\ s,\ vh\ =\ svd(mat1)
print(u)
print(s)
print(vh)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\-0.73553325\ \-0.18392937\ \-0.65204358]
\ [\-0.42657919\ \-0.62196982\ \ 0.65664582]
\ [\-0.52632788\ \ 0.76113306\ \ 0.37901904]]

[7.87764972\ 2.54031671\ 0.69958986]

[[\-0.60151068\ \ 0.73643349\ \ 0.30959751]
\ [\-0.61540527\ \-0.18005275\ \-0.76737042]
\ [\-0.5093734\ \ \-0.65210944\ \ 0.5615087\ ]]
\f[]
.fi
.PP
Here it returns \[aq]u\[aq], \[aq]s\[aq] and \[aq]vh\[aq] as arrays
having double (float64) dtype values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ svd
mat1\ =\ np.array([[3,4,3],[1,2,3],[4,2,1]])

#\ svd()\ demo\ with\ compute_uv\ =\ False
s\ =\ svd(mat1,\ compute_uv\ =\ False)
print(s)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[7.87764972\ 2.54031671\ 0.69958986]
\f[]
.fi
.PP
Here, it returns only \[aq]s\[aq] as an array having double (float64)
type values.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ svd
mat1\ =\ np.array([[3,4,3],[1,2,3],[4,2,1]])

#\ create\ FrovedisBlockcyclicMatrix\ instance
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat2\ =\ FrovedisBlockcyclicMatrix(mat1,\ np.float64)

#\ svd()\ demo\ with\ FrovedisBlockcyclicMatrix\ object\ as\ input
u,\ s,\ vh\ =\ svd(mat2)
u.debug_print()
s.debug_print()
vh.debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-0.735533\ \-0.426579\ \-0.526328\ \-0.183929\ \-0.62197\ 0.761133\ \-0.652044\ 0.656646\ 0.379019

vector:
[7.87764972\ 2.54031671\ 0.69958986]

matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-0.601511\ \-0.615405\ \-0.509373\ 0.736433\ \-0.180053\ \-0.652109\ 0.309598\ \-0.76737\ 0.561509
\f[]
.fi
.PP
\f[B]This output will be only visible on server side terminal.\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
from\ frovedis.linalg\ import\ svd
mat1\ =\ np.array([[3,4,3],[1,2,3],[4,2,1]])

#\ create\ FrovedisBlockcyclicMatrix\ instance
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat2\ =\ FrovedisBlockcyclicMatrix(mat1,\ np.float64)

#\ svd()\ demo\ with\ FrovedisBlockcyclicMatrix\ object\ as\ input\ and\ compute_cv\ =\ False
s\ =\ svd(mat2,\ compute_uv\ =\ False)
s.debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
vector:
[7.87764972\ 2.54031671\ 0.69958986]
\f[]
.fi
.PP
\f[B]This output will be only visible on server side terminal.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]When input is numpy array\f[]:
.PD 0
.P
.PD
\- If compute_cv = True, then it returns a tuple \f[B](u, s, vh)\f[],
where \f[B]u\f[], \f[B]s\f[] and \f[B]vh\f[] are numpy ndarrays having
float (float32) or double (float64) type values.
.PD 0
.P
.PD
\- If compute_cv = False, then it returns only array of singular values
\f[B]s\f[] of float (float32) or double (float64) type.
.PD 0
.P
.PD
2.
\f[B]When input is numpy matrix\f[]:
.PD 0
.P
.PD
\- If compute_cv = True, then it returns a tuple \f[B](u, s, vh)\f[],
where \f[B]u\f[], \f[B]vh\f[] are matrices and \f[B]s\f[] is a numpy
ndarray having float (float32) or double (float64) type values.
.PD 0
.P
.PD
\- If compute_cv = False, then it returns only array of singular values
\f[B]s\f[] of float (float32) or double (float64) type.
.PD 0
.P
.PD
3.
\f[B]When input is a FrovedisBlockcyclicMatrix instance\f[]:
.PD 0
.P
.PD
\- If compute_cv = True, then it returns a tuple \f[B](u, s, vh)\f[],
where \f[B]u\f[], \f[B]vh\f[] are FrovedisBlockcyclicMatrix instances
and \f[B]s\f[] is FrovedisVector instance.
.PD 0
.P
.PD
\- If compute_cv = False, then it returns \f[B]s\f[] is an instance of
FrovedisVector.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Scalapack Functions (./scalapack.md)\f[]
