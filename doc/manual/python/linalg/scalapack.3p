.TH "scalapack" "" "" "" ""
.SH NAME
.PP
scalapack \- it contains wrapper functions created for low level
functions from ScaLAPACK library (present in frovedis).
.SH SYNOPSIS
.IP
.nf
\f[C]
import\ frovedis.linalg.scalapack\ \ 
\f[]
.fi
.SH Public Member Functions
.IP
.nf
\f[C]
1.\ dgels(a,\ b,\ trans=\[aq]N\[aq],\ lwork=0,\ overwrite_a=0,\ overwrite_b=0)
2.\ gels(a,\ b,\ trans=\[aq]N\[aq],\ lwork=0,\ overwrite_a=0,\ overwrite_b=0,\ dtype=np.float64)
3.\ sgels(a,\ b,\ trans=\[aq]N\[aq],\ lwork=0,\ overwrite_a=0,\ overwrite_b=0)
4.\ dgesv(a,\ b,\ overwrite_a=0,\ overwrite_b=0)
5.\ gesv(a,\ b,\ overwrite_a=0,\ overwrite_b=0,\ dtype=np.float64)
6.\ sgesv(a,\ b,\ overwrite_a=0,\ overwrite_b=0)\ 
7.\ dgesvd(a,\ compute_uv=1,\ full_matrices=0,\ lwork=0,\ overwrite_a=0)\ 
8.\ gesvd(a,\ compute_uv=1,\ full_matrices=0,\ lwork=0,\ overwrite_a=0,\ dtype=np.float64)
9.\ sgesvd(a,\ compute_uv=1,\ full_matrices=0,\ lwork=0,\ overwrite_a=0)\ \ \ \ 
10.\ dgetrf(a,\ overwrite_a=0)
11.\ getrf(a,\ overwrite_a=0,\ dtype=np.float64)
12.\ sgetrf(a,\ overwrite_a=0)
13.\ dgetri(lu,\ piv,\ lwork=0,\ overwrite_lu=0)
14.\ getri(lu,\ piv,\ lwork=0,\ overwrite_lu=0,\ dtype=np.float64)
15.\ sgetri(lu,\ piv,\ lwork=0,\ overwrite_lu=0)\ \ \ \ 
16.\ dgetrs(lu,\ piv,\ b,\ trans=0,\ overwrite_b=0)
17.\ getrs(lu,\ piv,\ b,\ trans=0,\ overwrite_b=0,\ dtype=np.float64)
18.\ sgetrs(lu,\ piv,\ b,\ trans=0,\ overwrite_b=0)
\f[]
.fi
.SH DESCRIPTION
.PP
In Frovedis, the linalg module contains wrapper for ScaLAPACK (Scalable
LAPACK: the LAPACK routines distributed in nature) routines, whereas
scipy.linalg contains wrapper for LAPACK routines.
Here, the method names, arguments, purpose etc.
in frovedis.linalg wrapper routines are similar to scipy.linalg wrapper
routines.
.PD 0
.P
.PD
In order to use dgetrf() wrapper present in linalg module of both
frovedis and scipy:
.PP
\f[B]In frovedis:\f[]
.IP
.nf
\f[C]
from\ frovedis.linalg.scalapack\ import\ dgetrf\ \ 
\f[]
.fi
.PP
\f[B]In scipy:\f[]
.IP
.nf
\f[C]
from\ scipy.linalg.lapack\ import\ dgetrf
\f[]
.fi
.PP
This python module implements a client\-server application, where the
python client can send the python matrix data to frovedis server side in
order to create blockcyclic matrix at frovedis server and then perform
the supported ScaLAPACK operation requested by the python client on that
matrix.
After request is completed, frovedis server sends back the resultant
matrix and it can then create equivalent python data.
.PP
\f[B]We have supported \[aq]overwrite\[aq] option in frovedis routine
wrappers.\f[]
.PP
\f[B]However, unlike scipy.linalg, if \[aq]overwrite\[aq] option is
enabled and input is a valid ndarray or an instance of
FrovedisBlockcyclicMatrix, we would always overwrite (copy\-back) to the
same (irrespective of its dtype).\f[]
.PP
\f[B]This will slow down the overall computation. This should be enabled
only when it\[aq]s wanted to check the intermediate results (like LU
factor etc.)\f[]
.SS Detailed Description
.SS 1. dgels(a, b, trans = \[aq]N\[aq], lwork = 0, overwrite_a = 0,
overwrite_b = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values.
It should have number of rows >= max(M,N) and at least 1 column.
.PD 0
.P
.PD
\f[I]\f[B]trans\f[]\f[]: It accepts a string object parameter like
\[aq]N\[aq] or \[aq]T\[aq] which specifies if transpose of \[aq]a\[aq]
is needed to be computed before solving linear equation.
If set to \[aq]T\[aq], then transpose is computed.
(Default: \[aq]N\[aq])
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an ununsed parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise, \[aq]a\[aq] would be overwritten with QR or LQ factor.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise, \[aq]b\[aq] would be overwritten with the solution matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method solves overdetermined or underdetermined real linear systems
involving a left hand side matrix \[aq]a\[aq] or its transpose, using a
QR or LQ factorization of \[aq]a\[aq].
It is assumed that the matrix \[aq]a\[aq] has full rank.
It returns the LQ or QR factor, solution matrix with double (float64)
precision.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.dgels() module.
They are not used anywhere within the frovedis implementation.
.PP
This method internally uses Scalapack.gels() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ dgels()\ demo
from\ frovedis.linalg.scalapack\ import\ dgels
rf\ =\ dgels(mat1,mat2)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-1.41421356,\ \ 3.53553391,\ \-1.41421356],
\ \ \ [\-0.41421356,\ \-4.63680925,\ \ 4.74464202],
\ \ \ [\ 0.\ \ \ \ \ \ \ \ ,\ \ 0.36709178,\ \-7.77742709]]),\ array([[\-7.54901961,\ \ 2.68627451,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.50980392,\ \ 1.1372549\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686275,\ \ 0.\ \ \ \ \ \ \ \ ]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ dgels()\ demo\ and\ using\ transpose\ of\ a
from\ frovedis.linalg.scalapack\ import\ dgels
rf\ =\ dgels(mat1,mat2,trans=\[aq]T\[aq])
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-1.41421356,\ \ 3.53553391,\ \-1.41421356],
\ \ \ [\-0.41421356,\ \-4.63680925,\ \ 4.74464202],
\ \ \ [\ 0.\ \ \ \ \ \ \ \ ,\ \ 0.36709178,\ \-7.77742709]]),\ array([[\-7.82352941,\ \ 3.29411765,\ \-0.70588235],
\ \ \ [\ 1.17647059,\ \ 0.29411765,\ \ 0.29411765],
\ \ \ [\-1.96078431,\ \ 0.50980392,\ \-0.15686275]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ dgels()\ demo\ and\ overwriting\ of\ a\ with\ QR\ or\ LQ\ factor
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ dgels
rf\ =\ dgels(mat1,mat2,overwrite_a=1)
print(\[aq]overwritten\ matrix\ with\ LQ\ or\ QF\ factor:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix\ with\ LQ\ or\ QF\ factor:\ 
\ [[\-1.41421356\ \ 3.53553391\ \-1.41421356]
\ [\-0.41421356\ \-4.63680925\ \ 4.74464202]
\ [\ 0.\ \ \ \ \ \ \ \ \ \ 0.36709178\ \-7.77742709]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, then LQ or QR factor would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ dgels()\ demo\ and\ overwriting\ of\ b\ with\ solution\ matrix
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
from\ frovedis.linalg.scalapack\ import\ dgels
rf\ =\ dgels(mat1,mat2,overwrite_b=1)
print(\[aq]overwritten\ matrix\ with\ solution\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:\ 
[[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]

overwritten\ matrix\ with\ solution\ matrix:\ 
[[\-7.54901961\ \ 2.68627451\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980392\ \ 1.1372549\ \ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.7254902\ \ \ 0.15686275\ \ 0.\ \ \ \ \ \ \ \ ]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat2\[aq] is double (float64) type and
overwite is enabled, then solution matrix would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2)

#\ dgels()\ demo\ and\ a\ and\ b\ as\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ dgels
rf\ =\ dgels(bcm1,bcm2)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
rf[1].debug_print()
print(rf[2])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-1.41421\ \-0.414214\ 0\ 3.53553\ \-4.63681\ 0.367092\ \-1.41421\ 4.74464\ \-7.77743
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lqr, x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lqr\f[]: It is a numpy matrix having double (float64) type
values (by default) and containing the QR or LQ factor of input matrix
\[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having double (float64) type
values (by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are instances of
FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lqr, x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lqr\f[]: It returns instance of FrovedisBlockcyclicMatrix
containing the QR or LQ factor of input matrix \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
Here, the original inputs \[aq]a\[aq] and \[aq]b\[aq] are not
overwritten even when overwrite_a/overwrite_b is enabled.
.SS 2. gels(a, b, trans = \[aq]N\[aq], lwork = 0, overwrite_a = 0,
overwrite_b = 0, dtype = np.float64)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It should have number of rows >= max(M,N) and at least 1 column.
.PD 0
.P
.PD
\f[I]\f[B]trans\f[]\f[]: It accepts a string object parameter like
\[aq]N\[aq] or \[aq]T\[aq] which specifies if transpose of \[aq]a\[aq]
is needed to be computed before solving linear equation.
If set to \[aq]T\[aq], then transpose is computed.
(Default: \[aq]N\[aq])
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an ununsed parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise, \[aq]a\[aq] would be overwritten with QR or LQ factor.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise, \[aq]b\[aq] would be overwritten with the solution matrix.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: It specifies the datatype to be used for
setting the precision level (single for float32 / double for float64)
for the values returned by this method.
(Default: np.float64)
.PD 0
.P
.PD
\f[B]Currently, it supports float (float32) or double (float64)
datatypes.\f[]
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method solves overdetermined or underdetermined real linear systems
involving a left hand side matrix \[aq]a\[aq] or its transpose, using a
QR or LQ factorization of \[aq]a\[aq].
It is assumed that the matrix \[aq]a\[aq] has full rank.
It returns the LQ or QR factor, solution matrix for the system of linear
equations with single (float32) or double (float64) precision depending
on the \[aq]dtype\[aq] parameter provided by user.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform with other modules in frovedis.
They are not used anywhere within the frovedis implementation.
.PP
\f[B]This method is present only in frovedis\f[].
.PP
This method internally uses Scalapack.gels() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ gels()\ demo
from\ frovedis.linalg.scalapack\ import\ gels
rf\ =\ gels(mat1,mat2)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-1.41421356,\ \ 3.53553391,\ \-1.41421356],
\ \ \ [\-0.41421356,\ \-4.63680925,\ \ 4.74464202],
\ \ \ [\ 0.\ \ \ \ \ \ \ \ ,\ \ 0.36709178,\ \-7.77742709]]),\ array([[\-7.54901961,\ \ 2.68627451,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.50980392,\ \ 1.1372549\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686275,\ \ 0.\ \ \ \ \ \ \ \ ]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ gels()\ demo\ and\ using\ transpose\ of\ a
from\ frovedis.linalg.scalapack\ import\ gels
rf\ =\ gels(mat1,mat2,trans=\[aq]T\[aq])
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-1.41421356,\ \ 3.53553391,\ \-1.41421356],
\ \ \ [\-0.41421356,\ \-4.63680925,\ \ 4.74464202],
\ \ \ [\ 0.\ \ \ \ \ \ \ \ ,\ \ 0.36709178,\ \-7.77742709]]),\ array([[\-7.82352941,\ \ 3.29411765,\ \-0.70588235],
\ \ \ [\ 1.17647059,\ \ 0.29411765,\ \ 0.29411765],
\ \ \ [\-1.96078431,\ \ 0.50980392,\ \-0.15686275]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ gels()\ demo\ and\ overwriting\ of\ a\ with\ QR\ or\ LQ\ factor
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ gels
rf\ =\ gels(mat1,mat2,overwrite_a=1)
print(\[aq]overwritten\ matrix\ with\ LQ\ or\ QF\ factor:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix\ with\ LQ\ or\ QF\ factor:\ 
\ [[\-1.41421356\ \ 3.53553391\ \-1.41421356]
\ [\-0.41421356\ \-4.63680925\ \ 4.74464202]
\ [\ 0.\ \ \ \ \ \ \ \ \ \ 0.36709178\ \-7.77742709]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, then LQ or QR factor would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ gels()\ demo\ and\ overwriting\ of\ b\ with\ solution\ matrix
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
from\ frovedis.linalg.scalapack\ import\ gels
rf\ =\ gels(mat1,mat2,overwrite_b=1)
print(\[aq]overwritten\ matrix\ with\ solution\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:\ 
[[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]

overwritten\ matrix\ with\ solution\ matrix:\ 
[[\-7.54901961\ \ 2.68627451\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980392\ \ 1.1372549\ \ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.7254902\ \ \ 0.15686275\ \ 0.\ \ \ \ \ \ \ \ ]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat2\[aq] is double (float64) type and
overwite is enabled, then solution matrix would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ gels()\ demo\ and\ specifying\ the\ dtypes\ of\ output\ matrices\ LQ\ or\ QR\ factor\ and\ solution\ matrix
from\ frovedis.linalg.scalapack\ import\ gels
rf\ =\ gels(mat1,mat2,dtype=np.float32)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-1.4142135\ ,\ \ 3.535534\ \ ,\ \-1.4142137\ ],
\ \ \ \ \ \ \ [\-0.41421354,\ \-4.6368093\ ,\ \ 4.744642\ \ ],
\ \ \ \ \ \ \ [\ 0.\ \ \ \ \ \ \ \ ,\ \ 0.36709177,\ \-7.777427\ \ ]],\ dtype=float32),\ 
\ \ \ \ \ \ \ array([[\-7.5490184\ ,\ \ 2.686274\ \ ,\ \-1.0000001\ ],
\ \ \ \ \ \ \ [\-1.5098035\ ,\ \ 1.1372546\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ \ \ \ \ [\-0.7254901\ ,\ \ 0.15686269,\ \ 0.\ \ \ \ \ \ \ \ ]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2)

#\ gels()\ demo\ and\ a\ and\ b\ as\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ gels
rf\ =\ gels(bcm1,bcm2)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
rf[1].debug_print()
print(rf[2])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-1.41421\ \-0.414214\ 0\ 3.53553\ \-4.63681\ 0.367092\ \-1.41421\ 4.74464\ \-7.77743
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0
\f[]
.fi
.PP
\f[B]Note:\- \[aq]dtype\[aq] for the wrapper function and
FrovedisBlockcyclicMatrix instance must be same during computation.
Otherwise, it will raise an excpetion.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices and dtype = np.float64\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lqr, x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lqr\f[]: It is a numpy matrix having double (float64) type
values (by default) and containing the QR or LQ factor of input matrix
\[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having double (float64) type
values (by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices and dtype = np.float32\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lqr, x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lqr\f[]: It is a numpy matrix having float (float32) type values
(by default) and containing the QR or LQ factor of input matrix
\[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having float (float32) type
values (by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
3.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are instances of
FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lqr, x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lqr\f[]: It returns instance of FrovedisBlockcyclicMatrix
containing the QR or LQ factor of input matrix \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 3. sgels(a, b, trans = \[aq]N\[aq], lwork = 0, overwrite_a = 0,
overwrite_b = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
It should have number of rows >= max(M,N) and at least 1 column.
.PD 0
.P
.PD
\f[I]\f[B]trans\f[]\f[]: It accepts a string object parameter like
\[aq]N\[aq] or \[aq]T\[aq] which specifies if transpose of \[aq]a\[aq]
is needed to be computed before solving linear equation.
If set to \[aq]T\[aq], then transpose is computed.
(Default: \[aq]N\[aq])
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an ununsed parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise, \[aq]a\[aq] would be overwritten with QR or LQ factor.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise, \[aq]b\[aq] would be overwritten with the solution matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method solves overdetermined or underdetermined linear systems
involving a left hand side matrix \[aq]a\[aq] or its transpose, using a
QR or LQ factorization of \[aq]a\[aq].
It is assumed that the matrix \[aq]a\[aq] has full rank.
It returns the LQ or QR factor, solution matrix for the system of linear
equations with single (float32) precision.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.sgels() module.
They are not used anywhere within the frovedis implementation.
.PP
This method internally uses Scalapack.gels() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ sgels()\ demo
from\ frovedis.linalg.scalapack\ import\ sgels
rf\ =\ sgels(mat1,mat2)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-1.4142135\ ,\ \ 3.535534\ \ ,\ \-1.4142137\ ],
\ \ \ [\-0.41421354,\ \-4.6368093\ ,\ \ 4.744642\ \ ],
\ \ \ [\ 0.\ \ \ \ \ \ \ \ ,\ \ 0.36709177,\ \-7.777427\ \ ]],\ dtype=float32),\ 
\ \ \ array([[\-7.5490184\ ,\ \ 2.686274\ \ ,\ \-1.0000001\ ],
\ \ \ [\-1.5098035\ ,\ \ 1.1372546\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254901\ ,\ \ 0.15686269,\ \ 0.\ \ \ \ \ \ \ \ ]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sgels()\ demo\ and\ using\ transpose\ of\ a
from\ frovedis.linalg.scalapack\ import\ sgels
rf\ =\ sgels(mat1,mat2,trans=\[aq]T\[aq])
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-1.4142135\ ,\ \ 3.535534\ \ ,\ \-1.4142137\ ],
\ \ \ [\-0.41421354,\ \-4.6368093\ ,\ \ 4.744642\ \ ],
\ \ \ [\ 0.\ \ \ \ \ \ \ \ ,\ \ 0.36709177,\ \-7.777427\ \ ]],\ dtype=float32),\ 
\ \ \ array([[\-7.8235283\ ,\ \ 3.2941177\ ,\ \-0.7058824\ ],
\ \ \ [\ 1.1764708\ ,\ \ 0.29411745,\ \ 0.29411763],
\ \ \ [\-1.9607842\ ,\ \ 0.509804\ \ ,\ \-0.15686275]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sgels()\ demo\ and\ overwriting\ of\ a\ with\ QR\ or\ LQ\ factor
print(\[aq]original\ matrix\ mat1:\ \[aq],\ mat1)
from\ frovedis.linalg.scalapack\ import\ sgels
rf\ =\ sgels(mat1,mat2,overwrite_a=1)
print(\[aq]overwritten\ matrix\ with\ LQ\ or\ QF\ factor:\ \[aq],\ mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]
overwritten\ matrix\ with\ LQ\ or\ QF\ factor:
[[\-1.41421354\ \ 3.53553391\ \-1.41421366]
\ [\-0.41421354\ \-4.63680935\ \ 4.74464178]
\ [\ 0.\ \ \ \ \ \ \ \ \ \ 0.36709177\ \-7.7774272\ ]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, then LQ or QR factor would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ sgels()\ demo\ and\ overwriting\ of\ b\ with\ solution\ matrix
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
from\ frovedis.linalg.scalapack\ import\ sgels
rf\ =\ sgels(mat1,mat2,overwrite_b=1)
print(\[aq]overwritten\ matrix\ with\ solution\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:\ 
[[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]
\ 
overwritten\ matrix\ with\ solution\ matrix:\ 
[[\-7.54901838\ \ 2.68627405\ \-1.00000012]
\ [\-1.50980353\ \ 1.1372546\ \ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.72549009\ \ 0.15686269\ \ 0.\ \ \ \ \ \ \ \ ]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat2\[aq] is double (float64) type and
overwite is enabled, then solution matrix would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2)

#\ sgels()\ demo\ and\ a\ and\ b\ as\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ sgels
rf\ =\ sgels(bcm1,bcm2)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
rf[1].debug_print()
print(rf[2])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-1.41421\ \-0.414214\ 0\ 3.53553\ \-4.63681\ 0.367092\ \-1.41421\ 4.74464\ \-7.77743
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lqr, x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lqr\f[]: It is a numpy matrix having float (float32) type values
(by default) and containing the QR or LQ factor of input matrix
\[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having float (float32) (by
default) type values and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are instances of
FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lqr, x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lqr\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the QR or LQ factor of input matrix \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 4. dgesv(a, b, overwrite_a = 0, overwrite_b = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values.
It should have number of rows >= the number of rows in \[aq]a\[aq] and
at least 1 column in it.
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise, \[aq]a\[aq] would be overwritten with LU factor.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise, \[aq]b\[aq] would be overwritten with the solution matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It solves a system of linear equations, AX = B with a left hand side
square matrix, \[aq]a\[aq] by computing it\[aq]s LU factors internally.
It returns the LU factor, solution matrix for the system of linear
equations with double (float64) precision.
.PP
This method internally uses Scalapack.gesv() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ dgesv()\ demo
from\ frovedis.linalg.scalapack\ import\ dgesv
rf\ =\ dgesv(mat1,mat2)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]]),\ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f30f7e25208>,\ 
\ \ \ array([[\-7.54901961,\ \ 2.68627451,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.50980392,\ \ 1.1372549\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686275,\ \ 0.\ \ \ \ \ \ \ \ ]]),\ 0)
\f[]
.fi
.PP
\f[B]This resultant tuple of dgesv() wrapper function contains
GetrfResult instance in frovedis. Whereas in scipy, it contains an
array.\f[]
.PD 0
.P
.PD
\f[B]Both here are responsible to hold pivot array information.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ dgesv()\ demo\ and\ overwriting\ of\ a\ with\ LU\ factor
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ dgesv
rf\ =\ dgesv(mat1,mat2,overwrite_a=1)
print(\[aq]overwritten\ matrix\ with\ LU\ factor:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
\ [[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix\ with\ LU\ factor:\ 
[[\ \ 1.\ \ \ \ 0.\ \ \ \ 2.\ ]
\ [\ \-1.\ \ \ \ 5.\ \ \ \ 2.\ ]
\ [\ \ 0.\ \ \ \ 0.6\ \-10.2]]\ \ \ \ 
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, then LU factor would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ dgesv()\ demo\ and\ overwriting\ of\ b\ with\ solution\ matrix
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
from\ frovedis.linalg.scalapack\ import\ dgesv
rf\ =\ dgesv(mat1,mat2,overwrite_b=1)
print(\[aq]overwritten\ matrix\ with\ solution\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:\ 
\ [[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]

overwritten\ matrix\ with\ solution\ matrix:\ 
[[\-7.54901961\ \ 2.68627451\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980392\ \ 1.1372549\ \ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.7254902\ \ \ 0.15686275\ \ 0.\ \ \ \ \ \ \ \ ]]\ \ \ \ 
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat2\[aq] is double (float64) type and
overwite is enabled, then solution matrix would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2)

#\ dgesv()\ demo\ and\ a\ and\ b\ as\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ dgesv
rf\ =\ dgesv(bcm1,bcm2)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
print(rf[1])
rf[2].debug_print()
print(rf[3])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
<frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f7ce5798cf8>
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 1\ \-1\ 0\ 0\ 5\ 0.6\ 2\ 2\ \-10.2
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, piv, x, rs_stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having double (float64) type values
(by default) and containing the LU factor of input \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]piv\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having double (float64) type
values (by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]rs_stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are instances of
FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, piv, x, rs_stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the LU factor of input \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]piv\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]rs_stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 5. gesv(a, b, overwrite_a = 0, overwrite_b = 0, dtype = np.float64)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It should have number of rows >= the number of rows in \[aq]a\[aq] and
at least 1 column in it.
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise, \[aq]a\[aq] would be overwritten with LU factor.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise, \[aq]b\[aq] would be overwritten with the solution matrix.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: It specifies the datatype to be used for
setting the precision level (single for float32 / double for float64)
for the values returned by this method.
(Default: np.float64)
.PD 0
.P
.PD
\f[B]Currently, it supports float (float32) or double (float64)
datatypes.\f[]
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It solves a system of linear equations, AX = B with a left hand side
square matrix, \[aq]a\[aq] by computing it\[aq]s LU factors internally.
It returns the LU factor computed using getrf() and solution matrix
computed using getrf() for the system of linear equations with float
(float32) or double (float64) precision depending on the \[aq]dtype\[aq]
parameter provided by user.
.PP
\f[B]This method is present only in frovedis\f[].
.PP
This method internally uses Scalapack.gesv() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ gesv()\ demo
from\ frovedis.linalg.scalapack\ import\ gesv
rf\ =\ gesv(mat1,mat2)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]]),\ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f30f7e25208>,\ 
\ \ \ array([[\-7.54901961,\ \ 2.68627451,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.50980392,\ \ 1.1372549\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686275,\ \ 0.\ \ \ \ \ \ \ \ ]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ dgesv()\ demo\ and\ overwriting\ of\ a\ with\ LU\ factor
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ dgesv
rf\ =\ dgesv(mat1,mat2,overwrite_a=1)
print(\[aq]overwritten\ matrix\ with\ LU\ factor:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
\ [[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix\ with\ LU\ factor:\ 
[[\ \ 1.\ \ \ \ 0.\ \ \ \ 2.\ ]
\ [\ \-1.\ \ \ \ 5.\ \ \ \ 2.\ ]
\ [\ \ 0.\ \ \ \ 0.6\ \-10.2]]\ \ \ \ 
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, then LU factor would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ dgesv()\ demo\ and\ overwriting\ of\ b\ with\ solution\ matrix
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
from\ frovedis.linalg.scalapack\ import\ dgesv
rf\ =\ dgesv(mat1,mat2,overwrite_b=1)
print(\[aq]overwritten\ matrix\ with\ solution\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:\ 
\ [[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]

overwritten\ matrix\ with\ solution\ matrix:\ 
[[\-7.54901961\ \ 2.68627451\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980392\ \ 1.1372549\ \ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.7254902\ \ \ 0.15686275\ \ 0.\ \ \ \ \ \ \ \ ]]\ \ \ \ 
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat2\[aq] is double (float64) type and
overwite is enabled, then solution matrix would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ gesv()\ demo\ and\ specifying\ the\ dtypes\ of\ output\ matrices\ LU\ factor\ and\ solution\ matrix
from\ frovedis.linalg.scalapack\ import\ gesv
rf\ =\ gesv(mat1,mat2,dtype=np.float32)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]],\ dtype=float32),\ 
\ \ \ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f03d450ad30>,\ 
\ \ \ array([[\-7.54902\ \ \ ,\ \ 2.6862745\ ,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.509804\ \ ,\ \ 1.137255\ \ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686277,\ \ 0.\ \ \ \ \ \ \ \ ]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2)

#\ dgesv()\ demo\ and\ a\ and\ b\ as\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ dgesv
rf\ =\ dgesv(bcm1,bcm2)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
print(rf[1])
rf[2].debug_print()
print(rf[3])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
<frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f7ce5798cf8>
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 1\ \-1\ 0\ 0\ 5\ 0.6\ 2\ 2\ \-10.2
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0
\f[]
.fi
.PP
\f[B]Note:\- \[aq]dtype\[aq] for the wrapper function and
FrovedisBlockcyclicMatrix instance must be same during computation.
Otherwise, it will raise an excpetion.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices and dtype = np.float32\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, piv, x, rs_stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having float (float32) type values
(by default) and containing the LU factor of input \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]piv\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having float (float32) type
values (by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]rs_stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices and dtype = np.float64\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, piv, x, rs_stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having double (float64) type values
(by default) and containing the LU factor of input \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]piv\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having double (float64) type
values (by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]rs_stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
3.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are instances of
FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, piv, x, rs_stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the LU factor of input \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]piv\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]rs_stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 6. sgesv(a, b, overwrite_a = 0, overwrite_b = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
It should have number of rows >= the number of rows in \[aq]a\[aq] and
at least 1 column in it.
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise, \[aq]a\[aq] would be overwritten with LU factor.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise, \[aq]b\[aq] would be overwritten with the solution matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It solves a system of linear equations, AX = B with a left hand side
square matrix, \[aq]a\[aq] by computing it\[aq]s LU factors internally.
It returns the LU factor, solution matrix for the system of linear
equations with single (float32) precision.
.PP
This method internally uses Scalapack.gesv() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]],dtype\ =\ np.float32)
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]],dtype\ =\ np.float32)

#\ sgesv()\ demo
from\ frovedis.linalg.scalapack\ import\ sgesv
rf\ =\ sgesv(mat1,mat2)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]],\ dtype=float32),\ 
\ \ \ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f49657f3cf8>,\ 
\ \ \ array([[\-7.54902\ \ \ ,\ \ 2.6862745\ ,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.509804\ \ ,\ \ 1.137255\ \ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686277,\ \ 0.\ \ \ \ \ \ \ \ ]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
\f[B]This resultant tuple of sgesv() wrapper function contains
GetrfResult instance in frovedis. Whereas in scipy, it contains an
array.\f[]
.PD 0
.P
.PD
\f[B]Both here are responsible to hold pivot array information.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ sgesv()\ demo\ and\ overwriting\ of\ a\ with\ LU\ factor
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ sgesv
rf\ =\ sgesv(mat1,mat2,overwrite_a=1)
print(\[aq]overwritten\ matrix\ with\ LU\ factor:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix\ with\ LU\ factor:\ 
[[\ \ 1.\ \ \ \ 0.\ \ \ \ 2.\ ]
\ [\ \-1.\ \ \ \ 5.\ \ \ \ 2.\ ]
\ [\ \ 0.\ \ \ \ 0.6\ \-10.2]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, then LU factor would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ sgesv()\ demo\ and\ overwriting\ of\ b\ with\ solution\ matrix
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
from\ frovedis.linalg.scalapack\ import\ sgesv
rf\ =\ sgesv(mat1,mat2,overwrite_b=1)
print(\[aq]overwritten\ matrix\ with\ solution\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:\ 
[[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]

overwritten\ matrix\ with\ solution\ matrix:\ 
[[\-7.54901981\ \ 2.68627453\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980401\ \ 1.13725495\ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.72549021\ \ 0.15686277\ \ 0.\ \ \ \ \ \ \ \ ]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat2\[aq] is double (float64) type and
overwite is enabled, then solution matrix would also be double (float64)
type.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype=np.float32)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2,dtype=np.float32)

#\ sgesv()\ demo\ and\ a\ and\ b\ as\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ sgesv
rf\ =\ sgesv(bcm1,bcm2)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
print(rf[1])
rf[2].debug_print()
print(rf[3])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
<frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f67ddeccd30>
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 1\ \-1\ 0\ 0\ 5\ 0.6\ 2\ 2\ \-10.2
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0\ \ \ \ 
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are python inputs such as numpy
matrices\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, piv, x, rs_stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having float (float32) type values
(by default) and containing the LU factor of input \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]piv\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]x\f[]: It is also a numpy matrix having float (float32) type
values (by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]rs_stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] and \[aq]b\[aq] are instances of
FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, piv, x, rs_stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the LU factor of input \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]piv\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]rs_stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 7. dgesvd(a, compute_uv = 1, full_matrices = 0, lwork = 0,
overwrite_a = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]compute_uv\f[]\f[]: It accepts an integer parameter that
specifies whether left singular matrix and right singular matrix will be
computed.
If it is set as \[aq]0\[aq], a numpy matrix of shape \f[B](1,1)\f[] and
datatype same as \[aq]a\[aq] will be assigned to the left and right
singular matrix.
(Default: 1)
.PD 0
.P
.PD
\f[I]\f[B]full_matrices\f[]\f[]: It accepts an integer parameter.
Currently, it can only be set as 0.
Also, the left singular matrix and right singular matrix shapes are
\f[B](M, K)\f[] and \f[B](K, N)\f[], respectively, where \f[B]K = min(M,
N)\f[], \f[B]M\f[] is the number of rows and \f[B]N\f[] is the number of
columns of input matrix.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an ununsed parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise \[aq]a\[aq] would be consumed internally and its contents will
be destroyed.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the singular value decomposition (SVD) of matrix \[aq]a\[aq]
with double (float64) precision.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.dgesvd() module.
They are not used anywhere within the frovedis implementation.
.PP
This method internally uses Scalapack.gesvd() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ dgesvd()\ demo
from\ frovedis.linalg.scalapack\ import\ dgesvd
rf\ =\ dgesvd(mat1)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.19046167,\ \-0.12914878,\ \-0.97316234],
\ \ \ [\-0.20606538,\ \-0.97448299,\ \ 0.08899413],
\ \ \ [\-0.95982364,\ \ 0.18358509,\ \-0.21221475]]),\ array([9.83830146,\ 4.80016509,\ 1.0799257\ ]),\ 
\ \ \ array([[\ 0.04030442,\ \-0.39740577,\ \ 0.91675744],
\ \ \ [\ 0.17610524,\ \-0.9003148\ ,\ \-0.39802035],
\ \ \ [\-0.98354588,\ \-0.17748777,\ \-0.03369857]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ dgesvd()\ demo\ and\ compute_uv\ =\ 0
from\ frovedis.linalg.scalapack\ import\ dgesvd
rf\ =\ dgesvd(mat1,compute_uv=0)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[0.]]),\ array([9.83830146,\ 4.80016509,\ 1.0799257\ ]),\ array([[0.]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ dgesvd()\ demo\ and\ overwriting\ of\ a
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ dgesvd
rf\ =\ dgesvd(mat1,overwrite_a=1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix:\ 
[[\-1.41421356\ \-3.80788655\ \-0.1925824\ ]
\ [\-0.41421356\ \ 6.71975985\ \ 5.52667534]
\ [\ 0.\ \ \ \ \ \ \ \ \ \ 0.64659915\ \-5.36662718]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with double (float64) type
values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)

#\ dgesvd()\ demo\ and\ a\ is\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ dgesvd
rf\ =\ dgesvd(bcm1)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
rf[1].debug_print()
rf[2].debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
vector:
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.190462\ \-0.206065\ \-0.959824\ \-0.129149\ \-0.974483\ 0.183585\ \-0.973162\ 0.0889941\ \-0.212215
[9.83830146\ 4.80016509\ 1.0799257\ ]
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.0403044\ \-0.397406\ 0.916757\ 0.176105\ \-0.900315\ \-0.39802\ \-0.983546\ \-0.177488\ \-0.0336986
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] is a python input such as numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](u, s, vt, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]u\f[]: It is a numpy matrix having double (float64) type values
and containing the left singular matrix.
.PD 0
.P
.PD
\- \f[B]s\f[]: It is a numpy matrix having double (float64) type values
and containing the singular matrix.
.PD 0
.P
.PD
\- \f[B]vt\f[]: It is a numpy matrix having double (float64) type values
and containing the right singular matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](u, s, vt, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]u\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the left singular matrix.
.PD 0
.P
.PD
\- \f[B]s\f[]: It is a numpy matrix having double (float64) type values
and containing the singular matrix.
.PD 0
.P
.PD
\- \f[B]vt\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the right singular matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 8. gesvd(a, compute_uv = 1, full_matrices = 0, lwork = 0,
overwrite_a = 0, dtype = np.float64)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]compute_uv\f[]\f[]: It accepts an integer parameter that
specifies whether left singular matrix and right singular matrix will be
computed.
If it is set as \[aq]0\[aq], a numpy matrix of shape \f[B](1,1)\f[] and
datatype same as \[aq]a\[aq] will be assigned to the left and right
singular matrix.
(Default: 1)
.PD 0
.P
.PD
\f[I]\f[B]full_matrices\f[]\f[]: It accepts an integer parameter.
Currently, it can only be set as 0.
Also, the left singular matrix and right singular matrix shapes are
\f[B](M, K)\f[] and \f[B](K, N)\f[], respectively, where \f[B]K = min(M,
N)\f[], \f[B]M\f[] is the number of rows and \f[B]N\f[] is the number of
columns of input matrix.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an ununsed parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise \[aq]a\[aq] would be consumed internally and its contents will
be destroyed.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: It specifies the datatype to be used for
setting the precision level (single for float32 / double for float64)
for the values returned by this method.
(Default: np.float64)
.PD 0
.P
.PD
\f[B]Currently, it supports float (float32) or double (float64)
datatypes.\f[]
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the singular value decomposition (SVD) of matrix \[aq]a\[aq]
with single (float32) or double (float64) precision depending on the
\[aq]dtype\[aq] parameter provided by user.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.dgesvd() module.
They are not used anywhere within the frovedis implementation.
.PP
\f[B]This method is present only in frovedis\f[].
.PP
This method internally uses Scalapack.gesvd() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ gesvd()\ demo
from\ frovedis.linalg.scalapack\ import\ gesvd
rf\ =\ gesvd(mat1)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.19046167,\ \-0.12914878,\ \-0.97316234],
\ \ \ [\-0.20606538,\ \-0.97448299,\ \ 0.08899413],
\ \ \ [\-0.95982364,\ \ 0.18358509,\ \-0.21221475]]),\ 
\ \ \ array([9.83830146,\ 4.80016509,\ 1.0799257\ ]),\ 
\ \ \ array([[\ 0.04030442,\ \-0.39740577,\ \ 0.91675744],
\ \ \ [\ 0.17610524,\ \-0.9003148\ ,\ \-0.39802035],
\ \ \ [\-0.98354588,\ \-0.17748777,\ \-0.03369857]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ gesvd()\ demo\ and\ compute_uv\ =\ 0
from\ frovedis.linalg.scalapack\ import\ gesvd
rf\ =\ gesvd(mat1,compute_uv=0)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[0.]]),\ array([9.83830146,\ 4.80016509,\ 1.0799257\ ]),\ array([[0.]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ gesvd()\ demo\ and\ overwriting\ of\ a
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ gesvd
rf\ =\ gesvd(mat1,overwrite_a=1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix:\ 
[[\-1.41421356\ \-3.80788655\ \-0.1925824\ ]
\ [\-0.41421356\ \ 6.71975985\ \ 5.52667534]
\ [\ 0.\ \ \ \ \ \ \ \ \ \ 0.64659915\ \-5.36662718]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with double (float64) type
values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ gesvd()\ demo\ and\ specifying\ the\ dtypes\ of\ output\ matrices\ 
from\ frovedis.linalg.scalapack\ import\ gesvd
rf\ =\ gesvd(mat1,dtype=np.float32)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.19046175,\ \-0.12914878,\ \-0.9731621\ ],
\ \ \ \ \ \ \ [\-0.20606534,\ \-0.97448295,\ \ 0.08899409],
\ \ \ \ \ \ \ [\-0.9598237\ ,\ \ 0.1835851\ ,\ \-0.2122148\ ]],\ dtype=float32),\ 
\ \ \ \ \ \ \ array([9.838303\ ,\ 4.800165\ ,\ 1.0799255],\ dtype=float32),\ 
\ \ \ \ \ \ \ array([[\ 0.04030442,\ \-0.3974058\ ,\ \ 0.91675735],
\ \ \ \ \ \ \ [\ 0.17610519,\ \-0.90031475,\ \-0.39802024],
\ \ \ \ \ \ \ [\-0.98354584,\ \-0.17748773,\ \-0.03369856]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)

#\ gesvd()\ demo\ and\ a\ is\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ gesvd
rf\ =\ gesvd(bcm1)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
rf[1].debug_print()
rf[2].debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
vector:
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.190462\ \-0.206065\ \-0.959824\ \-0.129149\ \-0.974483\ 0.183585\ \-0.973162\ 0.0889941\ \-0.212215
[9.83830146\ 4.80016509\ 1.0799257\ ]
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.0403044\ \-0.397406\ 0.916757\ 0.176105\ \-0.900315\ \-0.39802\ \-0.983546\ \-0.177488\ \-0.0336986
\f[]
.fi
.PP
\f[B]Note:\- \[aq]dtype\[aq] for the wrapper function and
FrovedisBlockcyclicMatrix instance must be same during computation.
Otherwise, it will raise an excpetion.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] is a python input such as numpy matrix and dtype =
np.float32\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](u, s, vt, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]u\f[]: It is a numpy matrix having float (float32) type values
and containing the left singular matrix.
.PD 0
.P
.PD
\- \f[B]s\f[]: It is a numpy matrix having float (float32) type values
and containing the singular matrix.
.PD 0
.P
.PD
\- \f[B]vt\f[]: It is a numpy matrix having float (float32) type values
and containing the right singular matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] is a python input such as numpy matrix and dtype =
np.float64\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](u, s, vt, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]u\f[]: It is a numpy matrix having double (float64) type values
and containing the left singular matrix.
.PD 0
.P
.PD
\- \f[B]s\f[]: It is a numpy matrix having double (float64) type values
and containing the singular matrix.
.PD 0
.P
.PD
\- \f[B]vt\f[]: It is a numpy matrix having double (float64) type values
and containing the right singular matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
3.
\f[B]If \[aq]a\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](u, s, vt, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]u\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the left singular matrix.
.PD 0
.P
.PD
\- \f[B]s\f[]: It is a numpy matrix having double (float64) type values
and containing the singular matrix.
.PD 0
.P
.PD
\- \f[B]vt\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the right singular matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 9. sgesvd(a, compute_uv = 1, full_matrices = 0, lwork = 0,
overwrite_a = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
.PD 0
.P
.PD
\f[I]\f[B]compute_uv\f[]\f[]: It accepts an integer parameter that
specifies whether left singular matrix and right singular matrix will be
computed.
If it is set as \[aq]0\[aq], a numpy matrix of shape \f[B](1,1)\f[] and
datatype same as \[aq]a\[aq] will be assigned to the left and right
singular matrix.
(Default: 1)
.PD 0
.P
.PD
\f[I]\f[B]full_matrices\f[]\f[]: It accepts an integer parameter.
Currently, it can only be set as 0.
Also, the left singular matrix and right singular matrix shapes are
\f[B](M, K)\f[] and \f[B](K, N)\f[], respectively, where \f[B]K = min(M,
N)\f[], \f[B]M\f[] is the number of rows and \f[B]N\f[] is the number of
columns of input matrix.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an ununsed parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise \[aq]a\[aq] would be consumed internally and its contents will
be destroyed.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the singular value decomposition (SVD) of matrix \[aq]a\[aq]
with single (float32) precision.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.sgesvd() module.
They are not used anywhere within the frovedis implementation.
.PP
This method internally uses Scalapack.gesvd() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ sgesvd()\ demo
from\ frovedis.linalg.scalapack\ import\ sgesvd
rf\ =\ sgesvd(mat1)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.19046175,\ \-0.12914878,\ \-0.9731621\ ],
\ \ \ [\-0.20606534,\ \-0.97448295,\ \ 0.08899409],
\ \ \ [\-0.9598237\ ,\ \ 0.1835851\ ,\ \-0.2122148\ ]],\ dtype=float32),\ 
\ \ \ array([9.838303\ ,\ 4.800165\ ,\ 1.0799255],\ dtype=float32),\ 
\ \ \ array([[\ 0.04030442,\ \-0.3974058\ ,\ \ 0.91675735],
\ \ \ [\ 0.17610519,\ \-0.90031475,\ \-0.39802024],
\ \ \ [\-0.98354584,\ \-0.17748773,\ \-0.03369856]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sgesvd()\ demo\ and\ compute_uv\ =\ 0
from\ frovedis.linalg.scalapack\ import\ sgesvd
rf\ =\ sgesvd(mat1,compute_uv=0)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[0.]],\ dtype=float32),\ array([9.838302\ ,\ 4.800165\ ,\ 1.0799258],\ dtype=float32),\ 
array([[0.]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sgesvd()\ demo\ and\ overwriting\ of\ a
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ sgesvd
rf\ =\ sgesvd(mat1,overwrite_a=1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ \ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix:\ 
[[\-1.41421354\ \-3.80788684\ \-0.19258241]
\ [\-0.41421354\ \ 6.71975994\ \ 5.52667427]
\ [\ 0.\ \ \ \ \ \ \ \ \ \ 0.64659911\ \-5.36662769]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with double (float64) type
values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float32)

#\ sgesvd()\ demo\ and\ a\ is\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ sgesvd
rf\ =\ sgesvd(bcm1)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
rf[1].debug_print()
rf[2].debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
vector:
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.190462\ \-0.206065\ \-0.959824\ \-0.129149\ \-0.974483\ 0.183585\ \-0.973162\ 0.0889941\ \-0.212215
[9.838303\ \ 4.800165\ \ 1.0799255]
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.0403044\ \-0.397406\ 0.916757\ 0.176105\ \-0.900315\ \-0.39802\ \-0.983546\ \-0.177488\ \-0.0336986
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] is a python input such as numpy matrices\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](u, s, vt, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]u\f[]: It is a numpy matrix having float (float32) type values
and containing the left singular matrix.
.PD 0
.P
.PD
\- \f[B]s\f[]: It is a numpy matrix having float (float32) type values
and containing the singular matrix.
.PD 0
.P
.PD
\- \f[B]vt\f[]: It is a numpy matrix having float (float32) type values
and containing the right singular matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](u, s, vt, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]u\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the left singular matrix.
.PD 0
.P
.PD
\- \f[B]s\f[]: It is a numpy matrix having float (float32) type values
and containing the singular matrix.
.PD 0
.P
.PD
\- \f[B]vt\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the right singular matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.SS 10. dgetrf(a, overwrite_a = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise \[aq]a\[aq] will be overwritten with \[aq]L\[aq] and
\[aq]U\[aq] factors.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes LU factorization of matrix \[aq]a\[aq] with double (float64)
precision.
.PP
It computes an LU factorization of matrix \[aq]a\[aq], using partial
pivoting with row interchanges.
.PP
This method internally uses Scalapack.getrf() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ dgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ dgetrf
rf\ =\ dgetrf(mat1)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]]),\ 
\ \ \ \ \ \ \ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f80614aacf8>,\ 0)
\f[]
.fi
.PP
\f[B]This resultant tuple of dgetrf() wrapper function contains
GetrfResult instance in frovedis. Whereas in scipy, it contains an
array.\f[]
.PD 0
.P
.PD
\f[B]Both here are responsible to hold pivot array information.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ dgetrf()\ demo\ and\ overwriting\ of\ a
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ dgetrf
rf\ =\ dgetrf(mat1,overwrite_a=1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix:\ 
[[\ \ 1.\ \ \ \ 0.\ \ \ \ 2.\ ]
\ [\ \-1.\ \ \ \ 5.\ \ \ \ 2.\ ]
\ [\ \ 0.\ \ \ \ 0.6\ \-10.2]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with double (float64) type
values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float64)

#\ dgetrf()\ demo\ and\ bcm1\ is\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ dgetrf
rf\ =\ dgetrf(bcm1)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
print(rf[1])
print(rf[2])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
<frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f785d244978>
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 1\ \-1\ 0\ 0\ 5\ 0.6\ 2\ 2\ \-10.2
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] is a python inputs such as numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, res, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having double (float64) type values
(by default) and containing the LU factor of input matrix \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]res\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrf.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, res, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the LU factor of input matrix \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]res\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrf.
.SS 11. getrf(a, overwrite_a = 0, dtype = np.float64)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise \[aq]a\[aq] will be overwritten with \[aq]LU\[aq].
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: It specifies the datatype to be used for
setting the precision level (single for float32 / double for float64)
for the values returned by this method.
(Default: np.float64)
.PD 0
.P
.PD
\f[B]Currently, it supports float (float32) or double (float64)
datatypes.\f[]
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the LU factorization of matrix \[aq]a\[aq] with single
(float32) or double (float64) precision depending on \[aq]dtype\[aq]
parameter provided by user.
.PP
It computes an LU factorization of matrix \[aq]a\[aq], using partial
pivoting with row interchanges.
.PP
\f[B]This method is present only in frovedis\f[].
.PP
This method internally uses Scalapack.getrf() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ getrf()\ demo
from\ frovedis.linalg.scalapack\ import\ getrf
rf\ =\ getrf(mat1)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]]),\ 
\ \ \ \ \ \ \ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f80614aacf8>,\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ getrf()\ demo\ and\ overwriting\ of\ a
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ getrf
rf\ =\ getrf(mat1,overwrite_a=1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]

overwritten\ matrix:\ 
[[\ \ 1.\ \ \ \ 0.\ \ \ \ 2.\ ]
\ [\ \-1.\ \ \ \ 5.\ \ \ \ 2.\ ]
\ [\ \ 0.\ \ \ \ 0.6\ \-10.2]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with double (float64) type
values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ getrf()\ demo\ and\ specifying\ the\ dtype\ of\ output\ matrix\ LU\ factor\ 
from\ frovedis.linalg.scalapack\ import\ getrf
rf\ =\ getrf(mat1,dtype=np.float32)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]],\ dtype=float32),\ 
\ \ \ \ \ \ \ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f7c0bdbbd30>,\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float32)

#\ getrf()\ demo\ and\ bcm1\ is\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ getrf
rf\ =\ getrf(bcm1,dtype\ =\ np.float32)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
print(rf[1])
print(rf[2])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
<frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f56091379b0>
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 1\ \-1\ 0\ 0\ 5\ 0.6\ 2\ 2\ \-10.2
\f[]
.fi
.PP
\f[B]Note:\- \[aq]dtype\[aq] for the wrapper function and
FrovedisBlockcyclicMatrix instance must be same during computation.
Otherwise, it will raise an excpetion.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] is a python input such as numpy matrix and dtype =
np.float32\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, res, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having float (float32) type values
(by default) and containing the LU factor of input matrix \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]res\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrf.
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] is a python input such as numpy matrix and dtype =
np.float64\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, res, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having double (float64) type values
(by default) and containing the LU factor of input matrix \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]res\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrf.
.PD 0
.P
.PD
3.
\f[B]If \[aq]a\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, res, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the LU factor of input matrix \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]res\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrf.
.SS 12. sgetrf(a, overwrite_a = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]a\f[]\f[]: It accepts a python array\-like input or left hand
side numpy matrix of the linear equation having int, float (float32) or
double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
.PD 0
.P
.PD
\f[I]\f[B]overwrite_a\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]a\[aq] will remain unchanged.
Otherwise \[aq]a\[aq] will be overwritten with \[aq]LU\[aq].
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the LU factorization of matrix \[aq]a\[aq] with single
(float32) precision.
.PP
This method internally uses Scalapack.getrf() \f[B](present in
frovedis.matrix module)\f[].
.PP
It computes an LU factorization of matrix \[aq]a\[aq], using partial
pivoting with row interchanges.
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ sgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ sgetrf
rf\ =\ sgetrf(mat1)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ \ 1.\ ,\ \ \ 0.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \-1.\ ,\ \ \ 5.\ ,\ \ \ 2.\ ],
\ \ \ \ \ \ \ [\ \ 0.\ ,\ \ \ 0.6,\ \-10.2]],\ dtype=float32),\ 
\ \ \ \ \ \ \ <frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f1498750cf8>,\ 0)
\f[]
.fi
.PP
\f[B]This resultant tuple of sgetrf() wrapper function contains
GetrfResult instance in frovedis. Whereas in scipy, it contains an
array.\f[]
.PD 0
.P
.PD
\f[B]Both here are responsible to hold pivot array information.\f[]
.PP
For example,
.IP
.nf
\f[C]
#\ sgetrf()\ demo\ and\ overwriting\ of\ a
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
from\ frovedis.linalg.scalapack\ import\ sgetrf
rf\ =\ sgetrf(mat1,overwrite_a=1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:\ 
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]
overwritten\ matrix:\ 
[[\ \ 1.\ \ \ \ \ \ \ \ \ \ \ 0.\ \ \ \ \ \ \ \ \ \ \ 2.\ \ \ \ \ \ \ \ ]
\ [\ \-1.\ \ \ \ \ \ \ \ \ \ \ 5.\ \ \ \ \ \ \ \ \ \ \ 2.\ \ \ \ \ \ \ \ ]
\ [\ \ 0.\ \ \ \ \ \ \ \ \ \ \ 0.60000002\ \-10.19999981]]
\f[]
.fi
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with double (float64) type
values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float32)

#\ sgetrf()\ demo\ and\ bcm1\ is\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ getrf
rf\ =\ getrf(bcm1,dtype\ =\ np.float32)

#\ Unpacking\ the\ tuple
rf[0].debug_print()
print(rf[1])
print(rf[2])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
<frovedis.matrix.results.GetrfResult\ object\ at\ 0x7f6199f28908>
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 1\ \-1\ 0\ 0\ 5\ 0.6\ 2\ 2\ \-10.2
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]a\[aq] is a python input such as numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, res, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It is a numpy matrix having float (float32) type values
(by default) and containing the LU factor of input matrix \[aq]a\[aq].
In case \[aq]overwrite_a\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]a\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]res\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrf.
.PD 0
.P
.PD
2.
\f[B]If \[aq]a\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](lu, res, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]lu\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the LU factor of input matrix \[aq]a\[aq].
.PD 0
.P
.PD
\- \f[B]res\f[]: It returns an instance of GetrfResult containing server
side pointer of pivot array.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrf.
.SS 13. dgetri(lu, piv, lwork = 0, overwrite_lu = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]lu\f[]\f[]: It accepts a python array\-like input or numpy
matrix having int, float (float32) or double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values computed using dgetrf().
.PD 0
.P
.PD
\f[I]\f[B]piv\f[]\f[]: It accepts an instance of GetrfResult containing
server side pointer of pivot array computed using dgetrf().
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an unused parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_lu\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]lu\[aq] will remain unchanged.
Otherwise \[aq]lu\[aq] will be overwritten with inverse matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the inverse matrix with double (float64) precision.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.dgetri() module.
They are not used anywhere within the frovedis implementation.
.PP
This method internally uses Scalapack.getri() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ dgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ dgetrf,dgetri

#\ compute\ lu\ and\ piv\ using\ dgetrf()
rf\ =\ dgetrf(mat1)

#\ dgetri()\ demo
ri\ =\ dgetri(rf[0],rf[1])
print(ri)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.88235294,\ \-0.11764706,\ \ 0.19607843],
\ \ \ [\ 0.17647059,\ \ 0.17647059,\ \ 0.03921569],
\ \ \ [\ 0.05882353,\ \ 0.05882353,\ \-0.09803922]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ dgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ dgetrf,dgetri

#\ compute\ lu\ and\ piv\ using\ dgetrf()
rf\ =\ dgetrf(mat1,overwrite_a\ =\ 1)

#\ dgetri()\ demo\ and\ overwriting\ of\ lu
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
ri\ =\ dgetri(rf[0],rf[1],\ overwrite_lu\ =\ 1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]
overwritten\ matrix:
[[\ 0.88235294\ \-0.11764706\ \ 0.19607843]
\ [\ 0.17647059\ \ 0.17647059\ \ 0.03921569]
\ [\ 0.05882353\ \ 0.05882353\ \-0.09803922]]
\f[]
.fi
.PP
The input matrix is only processed by dgetrf() first to generate LU
factor.
The LU factor and ipiv information is then used with dgetri().
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with inverse matrix having
double (float64) type values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2)

#\ dgetri()\ demo\ and\ bcm1\ and\ bcm2\ are\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ dgetrf,dgetri
rf\ =\ dgetrf(bcm1)
ri\ =\ dgetri(rf[0],rf[1],bcm2)

#\ Unpacking\ the\ tuple
ri[0].debug_print()
print(ri[1])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.882353\ 0.176471\ 0.0588235\ \-0.117647\ 0.176471\ 0.0588235\ 0.196078\ 0.0392157\ \-0.0980392
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]lu\[aq] is python input such as numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](inv_a, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]inv_a\f[]: It is a numpy matrix having double (float64) type
values (by default) and containing the inverse matrix.
In case \[aq]overwrite_lu\[aq] is enabled, then dtype for the matrix
will depend on intermediate input \[aq]LU\[aq] factor dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.PD 0
.P
.PD
2.
\f[B]If \[aq]lu\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](inv_a, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]inv_a\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the inverse matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.SS 14. getri(lu, piv, lwork = 0, overwrite_lu = 0, dtype = np.float64)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]lu\f[]\f[]: It accepts a python array\-like input or numpy
matrix having int, float (float32) or double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
.PD 0
.P
.PD
\f[I]\f[B]piv\f[]\f[]: It accepts an instance of GetrfResult containing
server side pointer of pivot array.
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an unused parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_lu\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]lu\[aq] will remain unchanged.
Otherwise \[aq]lu\[aq] will be overwritten with inverse matrix.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: It specifies the datatype to be used for
setting the precision level (single for float32 / double for float64)
for the values returned by this method.
(Default: np.float64)
.PD 0
.P
.PD
\f[B]Currently, it supports float (float32) or double (float64)
datatypes.\f[]
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the inverse matrix with single (float32) or double (float64)
precision depending on \[aq]dtype\[aq] parameter provided by user.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.dgetri() module.
They are not used anywhere within the frovedis implementation.
.PP
\f[B]This method is present only in frovedis\f[].
.PP
This method internally uses Scalapack.getri() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ getrf()\ demo
from\ frovedis.linalg.scalapack\ import\ getrf,getri

#\ compute\ lu\ and\ piv\ using\ getrf()
rf\ =\ getrf(mat1)

#\ getri()\ demo
ri\ =\ getri(rf[0],rf[1])
print(ri)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.88235294,\ \-0.11764706,\ \ 0.19607843],
\ \ \ \ \ \ \ [\ 0.17647059,\ \ 0.17647059,\ \ 0.03921569],
\ \ \ \ \ \ \ [\ 0.05882353,\ \ 0.05882353,\ \-0.09803922]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ getrf()\ demo
from\ frovedis.linalg.scalapack\ import\ getrf,getri

#\ compute\ lu\ and\ piv\ using\ getrf()
rf\ =\ getrf(mat1,\ overwrite_a\ =\ 1)

#\ getri()\ demo\ and\ overwriting\ of\ lu
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
ri\ =\ getri(rf[0],rf[1],\ overwrite_lu\ =\ 1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]
overwritten\ matrix:
[[\ 0.88235294\ \-0.11764706\ \ 0.19607843]
\ [\ 0.17647059\ \ 0.17647059\ \ 0.03921569]
\ [\ 0.05882353\ \ 0.05882353\ \-0.09803922]]
\f[]
.fi
.PP
The input matrix is only processed by getrf() first to generate LU
factor.
The LU factor and ipiv information is then used with getri().
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with inverse matrix having
double (float64) type values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ getrf()\ demo
from\ frovedis.linalg.scalapack\ import\ getrf,getri

#\ compute\ lu\ and\ piv\ using\ getrf()
rf\ =\ getrf(mat1)

#\ getri()\ demo\ and\ specifying\ the\ dtype\ of\ output\ LU\ matrix\ \ 
from\ frovedis.linalg.scalapack\ import\ getri
rf\ =\ getri(rf[0],rf[1],dtype=np.float32)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.88235295,\ \-0.11764707,\ \ 0.19607843],
\ \ \ [\ 0.1764706\ ,\ \ 0.1764706\ ,\ \ 0.03921569],
\ \ \ [\ 0.05882353,\ \ 0.05882353,\ \-0.09803922]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float32)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2,dtype\ =\ np.float32)

#\ sgetri()\ demo\ and\ bcm1\ and\ bcm2\ are\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ getrf,getri
rf\ =\ getrf(bcm1,dtype\ =\ np.float32)
ri\ =\ getri(rf[0],rf[1],bcm2,\ dtype\ =\ np.float32)

#\ Unpacking\ the\ tuple
ri[0].debug_print()
print(ri[1])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.882353\ 0.176471\ 0.0588235\ \-0.117647\ 0.176471\ 0.0588235\ 0.196078\ 0.0392157\ \-0.0980392
\f[]
.fi
.PP
\f[B]Note:\- \[aq]dtype\[aq] for the wrapper function and
FrovedisBlockcyclicMatrix instance must be same during computation.
Otherwise, it will raise an excpetion.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]lu\[aq] is python input such as numpy matrix and dtype =
np.float32\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](inv_a, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]inv_a\f[]: It is a numpy matrix having float (float32) type
values (by default) and containing the inverse matrix.
In case \[aq]overwrite_lu\[aq] is enabled, then dtype for the matrix
will depend on intermediate input \[aq]LU\[aq] factor dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.PD 0
.P
.PD
2.
\f[B]If \[aq]lu\[aq] is python input such as numpy matrix and dtype =
np.float64\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](inv_a, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]inv_a\f[]: It is a numpy matrix having double (float64) type
values (by default) and containing the inverse matrix.
In case \[aq]overwrite_lu\[aq] is enabled, then dtype for the matrix
will depend on intermediate input \[aq]LU\[aq] factor dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.PD 0
.P
.PD
3.
\f[B]If \[aq]lu\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](inv_a, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]inv_a\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the inverse matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.SS 15. sgetri(lu, piv, lwork = 0, overwrite_lu = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]lu\f[]\f[]: It accepts a python array\-like input or numpy
matrix having int, float (float32) or double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
.PD 0
.P
.PD
\f[I]\f[B]piv\f[]\f[]: It accepts an instance of GetrfResult containing
server side pointer of pivot array.
.PD 0
.P
.PD
\f[I]\f[B]lwork\f[]\f[]: This is an unused parameter.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_lu\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]lu\[aq] will remain unchanged.
Otherwise \[aq]lu\[aq] will be overwritten with inverse matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes the inverse matrix with single (float32) precision.
.PP
The parameter: "lwork" is simply kept in to to make the interface
uniform to the scipy.linalg.lapack.dgetri() module.
They are not used anywhere within the frovedis implementation.
.PP
This method internally uses Scalapack.getri() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ sgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ sgetrf,sgetri

#\ compute\ lu\ and\ piv\ using\ sgetrf()
rf\ =\ sgetrf(mat1)

#\ sgetri()\ demo
ri\ =\ sgetri(rf[0],rf[1])
print(ri)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\ 0.88235295,\ \-0.11764707,\ \ 0.19607843],
\ \ \ [\ 0.1764706\ ,\ \ 0.1764706\ ,\ \ 0.03921569],
\ \ \ [\ 0.05882353,\ \ 0.05882353,\ \-0.09803922]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ sgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ sgetrf,sgetri

#\ compute\ lu\ and\ piv\ using\ sgetrf()
rf\ =\ sgetrf(mat1,\ overwrite_a\ =\ 1)

#\ sgetri()\ demo\ and\ overwriting\ of\ lu
print(\[aq]original\ matrix\ mat1:\ \[aq])
print(mat1)
ri\ =\ sgetri(rf[0],rf[1],\ overwrite_lu\ =\ 1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat1:
[[\ 1.\ \ 0.\ \ 2.]
\ [\-1.\ \ 5.\ \ 0.]
\ [\ 0.\ \ 3.\ \-9.]]
\ 
overwritten\ matrix:
[[\ 0.88235295\ \-0.11764707\ \ 0.19607843]
\ [\ 0.17647059\ \ 0.17647059\ \ 0.03921569]
\ [\ 0.05882353\ \ 0.05882353\ \-0.09803922]]
\f[]
.fi
.PP
The input matrix is only processed by sgetrf() first to generate LU
factor.
The LU factor and ipiv information is then used with sgetri().
.PP
\f[B]Here, if the input \[aq]mat1\[aq] is double (float64) type and
overwite is enabled, it\[aq]s overwitten with inverse matrix having
double (float64) type values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float32)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2,dtype\ =\ np.float32)

#\ sgetri()\ demo\ and\ bcm1\ and\ bcm2\ are\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ sgetrf,sgetri
rf\ =\ sgetrf(bcm1)
ri\ =\ sgetri(rf[0],rf[1],bcm2)

#\ Unpacking\ the\ tuple
ri[0].debug_print()
print(ri[1])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ 0.882353\ 0.176471\ 0.0588235\ \-0.117647\ 0.176471\ 0.0588235\ 0.196078\ 0.0392157\ \-0.0980392
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]lu\[aq] is python input such as numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](inv_a, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]inv_a\f[]: It is a numpy matrix having float (float32) type
values (by default) and containing the inverse matrix.
In case \[aq]overwrite_lu\[aq] is enabled, then dtype for the matrix
will depend on intermediate input \[aq]LU\[aq] factor dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.PD 0
.P
.PD
2.
\f[B]If \[aq]lu\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](inv_a, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]inv_a\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the inverse matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.SS 16. dgetrs(lu, piv, b, trans = 0, overwrite_b = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]lu\f[]\f[]: It accepts a python array\-like input or numpy
matrix having int, float (float32) or double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values computed using dgetrf.
.PD 0
.P
.PD
\f[I]\f[B]piv\f[]\f[]: It accepts an instance of GetrfResult containing
server side pointer of pivot array computed using dgetrf().
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side matrix of the linear equation having int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having double
(float64) type values.
It should have number of rows >= the number of rows in \[aq]a\[aq] and
at least 1 column in it.
.PD 0
.P
.PD
\f[I]\f[B]trans\f[]\f[]: It accepts an integer parameter indicating if
transpose of \[aq]lu\[aq] needs to be computed before solving linear
equation.
If it is not 0, then the transpose is computed.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise \[aq]b\[aq] will be overwritten with the solution matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It solves a system of linear equations, AX = B with matrix \[aq]a\[aq]
using the LU factorization computed by getrf().
Thus before calling this function, it is required to obtain the factored
matrix \[aq]lu\[aq] (along with piv information) by calling getrf().
.PP
It computes the solution matrix for the system of linear equations with
double (float64) precision.
.PP
This method internally uses Scalapack.getrs() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ dgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ dgetrf,dgetrs

#\ compute\ lu\ and\ piv\ using\ dgetrf()
rf\ =\ dgetrf(mat1)

#\ dgetrs()\ demo
ri\ =\ dgetrs(rf[0],rf[1],mat2)
print(ri)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-7.54901961,\ \ 2.68627451,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.50980392,\ \ 1.1372549\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686275,\ \ 0.\ \ \ \ \ \ \ \ ]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ dgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ dgetrf,dgetrs

#\ compute\ lu\ and\ piv\ using\ dgetrf()
rf\ =\ dgetrf(mat1,\ overwrite_a\ =\ 1)

#\ dgetrs()\ demo\ and\ overwriting\ of\ b
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
ri\ =\ dgetrs(rf[0],rf[1],mat2,overwrite_b\ =\ 1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat1)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:
[[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]
overwritten\ matrix:
[[\-7.54901961\ \ 2.68627451\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980392\ \ 1.1372549\ \ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.7254902\ \ \ 0.15686275\ \ 0.\ \ \ \ \ \ \ \ ]]
\f[]
.fi
.PP
\f[B]Here, if the inputs \[aq]mat2\[aq] is double (float64) type and
overwite is enabled in dgetrs(), it\[aq]s overwitten with solution
having double (float64) type values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2)

#\ dgetrs()\ demo\ and\ bcm1\ and\ bcm2\ are\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ dgetrf,dgetrs
rf\ =\ dgetrf(bcm1)
ri\ =\ dgetrs(rf[0],rf[1],bcm2)

#\ Unpacking\ the\ tuple
ri[0].debug_print()
print(ri[1])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]b\[aq] is python input such as numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]x\f[]: It is a numpy matrix having double (float64) type values
(by default) and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]b\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.SS 17. getrs(lu, piv, b, trans = 0, overwrite_b = 0, dtype =
np.float64)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]lu\f[]\f[]: It accepts a python array\-like input or numpy
matrix having int, float (float32) or double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values computed using dgetrf.
.PD 0
.P
.PD
\f[I]\f[B]piv\f[]\f[]: It accepts an instance of GetrfResult containing
server side pointer of pivot array computed using dgetrf().
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side matrix of the linear equation having int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) or double (float64) type values.
It should have number of rows >= the number of rows in \[aq]a\[aq] and
at least 1 column in it.
.PD 0
.P
.PD
\f[I]\f[B]trans\f[]\f[]: It accepts an integer parameter indicating if
transpose of \[aq]lu\[aq] needs to be computed before solving linear
equation.
If it is not 0, then the transpose is computed.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise \[aq]b\[aq] will be overwritten with the solution matrix.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: It specifies the datatype to be used for
setting the precision level (single for float32 / double for float64)
for the values returned by this method.
(Default: np.float64)
.PD 0
.P
.PD
\f[B]Currently, it supports float (float32) or double (float64)
datatypes.\f[]
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It solves a system of linear equations, AX = B with matrix \[aq]a\[aq]
using the LU factorization computed by getrf().
Thus before calling this function, it is required to obtain the factored
matrix \[aq]lu\[aq] by calling getrf().
.PP
It computes the solution matrix for the system of linear equations with
float or double (float64) precision depending on \[aq]dtype\[aq]
parameter provided by user.
.PP
\f[B]This method is present only in frovedis\f[].
.PP
This method internally uses Scalapack.getrs() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ getrf()\ demo
from\ frovedis.linalg.scalapack\ import\ getrf,getrs

#\ compute\ lu\ and\ piv\ using\ getrf()
rf\ =\ getrf(mat1)

#\ getrs()\ demo
ri\ =\ getrs(rf[0],rf[1],mat2)
print(ri)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-7.54901961,\ \ 2.68627451,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.50980392,\ \ 1.1372549\ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686275,\ \ 0.\ \ \ \ \ \ \ \ ]]),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ getrf()\ demo
from\ frovedis.linalg.scalapack\ import\ getrf,getrs

#\ compute\ lu\ and\ piv\ using\ getrf()
rf\ =\ getrf(mat1,\ overwrite_a\ =\ 1)

#\ getrs()\ demo\ and\ overwriting\ of\ b
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
ri\ =\ getrs(rf[0],rf[1],\ mat2,\ overwrite_b\ =\ 1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:
[[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]
overwritten\ matrix:
[[\-7.54901961\ \ 2.68627451\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980392\ \ 1.1372549\ \ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.7254902\ \ \ 0.15686275\ \ 0.\ \ \ \ \ \ \ \ ]]
\f[]
.fi
.PP
\f[B]Here, if the inputs \[aq]mat2\[aq] is double (float64) type and
overwite is enabled in dgetrs(), it\[aq]s overwitten with solution
having double (float64) type values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ getrf()\ demo
from\ frovedis.linalg.scalapack\ import\ getrf,getrs

#\ compute\ lu\ and\ piv\ using\ getrf()
rf\ =\ getrf(mat1,dtype=np.float32)

#\ getrs()\ demo\ and\ specifying\ the\ dtype\ of\ output\ LU\ matrix\ \ 
from\ frovedis.linalg.scalapack\ import\ getrs
rf\ =\ getrs(rf[0],rf[1],mat2,dtype=np.float32)
print(rf)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-7.54902\ \ \ ,\ \ 2.6862745\ ,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.509804\ \ ,\ \ 1.137255\ \ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686277,\ \ 0.\ \ \ \ \ \ \ \ ]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float32)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2,\ dtype\ =\ np.float32)

#\ getrs()\ demo\ and\ bcm1\ and\ bcm2\ are\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ getrf,getrs
rf\ =\ getrf(bcm1,dtype\ =\ np.float32)
ri\ =\ getrs(rf[0],rf[1],bcm2,dtype\ =\ np.float32)

#\ Unpacking\ the\ tuple
ri[0].debug_print()
print(ri[1])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0
\f[]
.fi
.PP
\f[B]Note:\- \[aq]dtype\[aq] for the wrapper function and
FrovedisBlockcyclicMatrix instance must be same during computation.
Otherwise, it will raise an excpetion.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]b\[aq] is python input such as numpy matrix and dtype =
np.float32\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]x\f[]: It is a numpy matrix having float (float32) type values
(by default) containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]b\[aq] is python input such as numpy matrix and dtype =
np.float64\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]x\f[]: It is a numpy matrix having double (float64) type values
(by default) containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
3.
\f[B]If \[aq]b\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.SS 18. sgetrs(lu, piv, b, trans = 0, overwrite_b = 0)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]lu\f[]\f[]: It accepts a python array\-like input or numpy
matrix having int, float (float32) or double (float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values computed using dgetrf.
.PD 0
.P
.PD
\f[I]\f[B]piv\f[]\f[]: It accepts an instance of GetrfResult containing
server side pointer of pivot array computed using dgetrf().
.PD 0
.P
.PD
\f[I]\f[B]b\f[]\f[]: It accepts a python array\-like input or right hand
side matrix of the linear equation having int, float (float32) or double
(float64) type values.
It also accepts FrovedisBlockcyclicMatrix instance having float
(float32) type values.
It should have number of rows >= the number of rows in \[aq]a\[aq] and
at least 1 column in it.
.PD 0
.P
.PD
\f[I]\f[B]trans\f[]\f[]: It accepts an integer parameter indicating if
transpose of \[aq]lu\[aq] needs to be computed before solving linear
equation.
If it is not 0, then the transpose is computed.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]overwrite_b\f[]\f[]: It accepts an integer parameter, if set
to 0, then \[aq]b\[aq] will remain unchanged.
Otherwise \[aq]b\[aq] will be overwritten with the solution matrix.
(Default: 0)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It solves a system of linear equations, AX = B with the matrix
\[aq]a\[aq] using the LU factorization computed by sgetrf().
.PD 0
.P
.PD
Thus before calling this function, it is required to obtain the factored
matrix \[aq]lu\[aq] by calling sgetrf().
.PP
It computes the solution matrix for the system of linear equations with
float precision.
.PP
This method internally uses Scalapack.getrs() \f[B](present in
frovedis.matrix module)\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])

#\ sgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ sgetrf,sgetrs

#\ compute\ lu\ and\ piv\ using\ sgetrf()
rf\ =\ sgetrf(mat1)

#\ sgetrs()\ demo
ri\ =\ sgetrs(rf[0]rf[1],mat2)
print(ri)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
(array([[\-7.54902\ \ \ ,\ \ 2.6862745\ ,\ \-1.\ \ \ \ \ \ \ \ ],
\ \ \ [\-1.509804\ \ ,\ \ 1.137255\ \ ,\ \ 0.\ \ \ \ \ \ \ \ ],
\ \ \ [\-0.7254902\ ,\ \ 0.15686277,\ \ 0.\ \ \ \ \ \ \ \ ]],\ dtype=float32),\ 0)
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
import\ numpy\ as\ np
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])

#\ sgetrf()\ demo
from\ frovedis.linalg.scalapack\ import\ sgetrf,sgetrs

#\ compute\ lu\ and\ piv\ using\ sgetrf()
rf\ =\ sgetrf(mat1)

#\ sgetrs()\ demo\ and\ overwriting\ of\ b
print(\[aq]original\ matrix\ mat2:\ \[aq])
print(mat2)
ri\ =\ sgetrs(rf[0],rf[1],\ mat2,\ overwrite_b\ =\ 1)
print(\[aq]overwritten\ matrix:\ \[aq])
print(mat2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
original\ matrix\ mat2:
[[\-9.\ \ 3.\ \-1.]
\ [\ 0.\ \ 3.\ \ 1.]
\ [\ 2.\ \ 2.\ \ 0.]]
overwritten\ matrix:
[[\-7.54901981\ \ 2.68627453\ \-1.\ \ \ \ \ \ \ \ ]
\ [\-1.50980401\ \ 1.13725495\ \ 0.\ \ \ \ \ \ \ \ ]
\ [\-0.72549021\ \ 0.15686277\ \ 0.\ \ \ \ \ \ \ \ ]]
\f[]
.fi
.PP
\f[B]Here, if the inputs \[aq]mat2\[aq] is double (float64) type and
overwite is enabled in dgetrs(), it\[aq]s overwitten with solution
having double (float64) type values.\f[]
.PP
\f[B]Same applies for other types (int, float (float32)) when input is a
numpy matrix/array and overwrite is enabled.\f[]
.PP
For example,
.IP
.nf
\f[C]
from\ frovedis.matrix.dense\ import\ FrovedisBlockcyclicMatrix
mat1\ =\ np.array([[1.,0.,2.],[\-1.,5.,0.],[0.,3.,\-9.]])
mat2\ =\ np.array([[\-9.,3.,\-1.],[0.,3.,1.],[2.,2.,0.]])
bcm1\ =\ FrovedisBlockcyclicMatrix(mat1,dtype\ =\ np.float32)
bcm2\ =\ FrovedisBlockcyclicMatrix(mat2,dtype\ =\ np.float32)

#\ sgetrs()\ demo\ and\ bcm1\ and\ bcm2\ are\ an\ instance\ of\ FrovedisBlockcyclicMatrix
from\ frovedis.linalg.scalapack\ import\ sgetrf,sgetrs
rf\ =\ sgetrf(bcm1)
ri\ =\ sgetrs(rf[0],rf[1],bcm2)

#\ Unpacking\ the\ tuple
ri[0].debug_print()
print(ri[1])
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
0
matrix:
num_row\ =\ 3,\ num_col\ =\ 3
node\ 0
node\ =\ 0,\ local_num_row\ =\ 3,\ local_num_col\ =\ 3,\ type\ =\ 2,\ descriptor\ =\ 1\ 1\ 3\ 3\ 3\ 3\ 0\ 0\ 3\ 3\ 3
val\ =\ \-7.54902\ \-1.5098\ \-0.72549\ 2.68627\ 1.13725\ 0.156863\ \-1\ 0\ 0\ \ \ \ 
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
1.
\f[B]If \[aq]b\[aq] is python input such as numpy matrix\f[]:
.PD 0
.P
.PD
\- It returns a tuple \f[B](x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]x\f[]: It is a numpy matrix having float (float32) type value
and containing the solution matrix.
In case \[aq]overwrite_b\[aq] is enabled, then dtype for the matrix will
depend on input \[aq]b\[aq] dtype.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetrs.
.PD 0
.P
.PD
2.
\f[B]If \[aq]b\[aq] is an instance of FrovedisBlockcyclicMatrix:\f[]
.PD 0
.P
.PD
\- It returns a tuple \f[B](x, stat)\f[] where,
.PD 0
.P
.PD
\- \f[B]x\f[]: It returns an instance of FrovedisBlockcyclicMatrix
containing the solution matrix.
.PD 0
.P
.PD
\- \f[B]stat\f[]: It returns an integer containing status (info) of
native scalapack dgetri.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Linalg Functions (./linalg.md)\f[]
