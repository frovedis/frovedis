.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Graph" "" "" "" ""
.hy
.SH NAME
.PP
Graph - This class implements a directed or undirected frovedis graph.
.SH SYNOPSIS
.IP
.nf
\f[C]
frovedis.graph.graph.Graph(nx_graph=None)  
\f[R]
.fi
.SS Public Member Functions
.PP
load(nx_graph)
.PD 0
.P
.PD
load_csr(smat)
.PD 0
.P
.PD
debug_print()
.PD 0
.P
.PD
release()
.PD 0
.P
.PD
clear()
.PD 0
.P
.PD
number_of_edges()
.PD 0
.P
.PD
number_of_nodes()
.PD 0
.P
.PD
save(fname)
.PD 0
.P
.PD
load_text(fname)
.PD 0
.P
.PD
to_networkx_graph()
.SH DESCRIPTION
.PP
Base class for undirected and directed frovedis graphs.
A Frovedis Graph stores nodes and edges with optional data.
Here, the graph data, edge to edge information is internally stored as
and adjacency matrix data.
.PP
This module provides a client-server implementation, where the client
application is a normal python program.
The frovedis public method interface is almost same as NetworkX Graph
interface, but it doesn\[cq]t have any dependency with NetworkX.
It can be used simply even if the system doesn\[cq]t have NetworkX
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.PP
Python side calls for Graph() on the frovedis server.
Once the graph is loaded for the given input networkx or scipy
csr_matrix graph data at the frovedis server, it returns a frovedis
graph instance to the client python program.
.SS Detailed Description
.SS 1. Graph()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]nx_graph\f[B]\f[R]: Data to initialize graph.
Here data provided is a scipy sparse csr_matrix or a networkx.Graph
instance.
It loads such data to create a frovedis graph.
(Default: None)
.PD 0
.P
.PD
When it is None, an empty frovedis graph is created.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It initializes a Frovedis Graph object having nodes and edges.
It can create both directed or undirected graph.
.PP
For example,
.PP
\f[B]a) When loading an undirected networkx.Graph as input,\f[R]
.IP
.nf
\f[C]
import frovedis.graph as fnx
import networkx as gnx
net_graph = gnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq])
frov_graph = fnx.Graph(net_graph)
\f[R]
.fi
.PP
\f[B]b) When loading a directed networkx.Graph as input,\f[R]
.IP
.nf
\f[C]
import frovedis.graph as fnx
import networkx as gnx
net_graph = gnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], create_using = gnx.DiGraph())
frov_graph = fnx.Graph(net_graph)
\f[R]
.fi
.PP
\f[B]c) When loading a scipy sparse csr_matrix as input to create
undirected frovedis graph,\f[R]
.IP
.nf
\f[C]
#Here it creates an undirected graph
import frovedis.graph as fnx
from scipy.sparse import csr_matrix
data = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
row = [0,0,0,0,0,1,2,3,4,5,6,6,6,6,7,8,9,10,11,12]
col = [1,2,3,4,5,0,0,0,0,0,7,8,9,10,6,6,6,6,12,11]
csr_mat = csr_matrix((data, (row, col)), shape = (13, 13))
frov_graph = fnx.Graph(csr_mat)
\f[R]
.fi
.PP
\f[B]d) Again, when loading a scipy sparse csr_matrix as input to create
directed frovedis graph,\f[R]
.IP
.nf
\f[C]
#Here it creates a directed graph
import frovedis.graph as fnx
from scipy.sparse import csr_matrix
data = [1,1,1,1,1,1,1,1,1,1]
row = [0,0,0,0,0,6,6,6,6,11]
col = [1,2,3,4,5,7,8,9,10,12]
csr_mat = csr_matrix((data, (row, col)), shape = (13, 13))
frov_graph = fnx.Graph(csr_mat)
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 2. load(nx_graph)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]nx_graph\f[B]\f[R]: Data to initialize graph.
Here graph data provided is a networkx.Graph instance.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It loads a networkx graph to create a frovedis graph.
Here, the loaded graph can be directed or undirected.
.PP
For example,
.IP
.nf
\f[C]
import frovedis.graph as fnx
import networkx as gnx
net_graph = gnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq])
frov_graph = fnx.Graph().load(nx_graph = net_graph)
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 3. load_csr(smat)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]smat\f[B]\f[R]: Data to initialize graph.
Here graph data provided is a scipy sparse csr_matrix.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It loads frovedis graph from a scipy csr_matrix.
Here, depending on the scipy csr_matrix data, the final graph maybe
directed or undirected.
.PP
For example,
.IP
.nf
\f[C]
#Loading a scipy csr_matrix to create an undirected frovedis graph
import frovedis.graph as fnx
from scipy.sparse import csr_matrix
data = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
row = [0,0,0,0,0,1,2,3,4,5,6,6,6,6,7,8,9,10,11,12]
col = [1,2,3,4,5,0,0,0,0,0,7,8,9,10,6,6,6,6,12,11]
csr_mat = csr_matrix((data, (row, col)), shape = (13, 13))
frov_graph = fnx.Graph().load_csr(smat = csr_mat)

#Loading a scipy csr_matrix to create a directed frovedis graph
import frovedis.graph as fnx
from scipy.sparse import csr_matrix
data = [1,1,1,1,1,1,1,1,1,1]
row = [0,0,0,0,0,6,6,6,6,11]
col = [1,2,3,4,5,7,8,9,10,12]
csr_mat = csr_matrix((data, (row, col)), shape = (13, 13))
frov_graph = fnx.Graph().load_csr(smat = csr_mat)
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 4. debug_print()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It shows graph information on the client side and server side user
terminal.
It is mainly used for debugging purpose.
.PP
For example,
.IP
.nf
\f[C]
frov_graph.debug_print()
\f[R]
.fi
.PP
Output on client side
.IP
.nf
\f[C]
Num of edges:  20
Num of vertices:  13
\f[R]
.fi
.PP
It displays information such as number of edges and vertices.
.PP
Output on server side
.IP
.nf
\f[C]
Num of edges:  20
Num of vertices:  13
is directed: 0
is weighted: 0
in-degree:
5 1 1 1 1 1 4 1 1 1 1 1 1
out-degree:
5 1 1 1 1 1 4 1 1 1 1 1 1
adjacency matrix:
0 1 1 1 1 1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 1 1 1 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 1 0
\f[R]
.fi
.PP
It displays information such as number of edges and vertices, directed
(`0' for No, `1' for Yes) , incoming links, outgoing links and an
adjacency matrix.
Currently, it shows information about an undirected frovedis graph.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 5. release()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to release the in-memory model at frovedis server.
.PP
For example,
.IP
.nf
\f[C]
frov_graph.release()  
\f[R]
.fi
.PP
This will remove the graph model, model-id present on server, along with
releasing server side memory.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 6. clear()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to release the in-memory model at frovedis server.
This method is an alias to release().
.PP
For example,
.IP
.nf
\f[C]
frov_graph.clear()  
\f[R]
.fi
.PP
This will remove the graph model, model-id present on server, along with
releasing server side memory.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 7. number_of_edges()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to fetch the number of edges present in the directed or
undirected frovedis graph.
.PP
For example,
.IP
.nf
\f[C]
edge_count = frov_graph.number_of_edges()
print(\[aq]Number of edges: \[aq], edge_count)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Number of edges: 20
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a long (int64) type value specifying the number of edges.
.SS 8. number_of_nodes()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to fetch the number of nodes/vertices present in the directed
or undirected frovedis graph.
.PP
For example,
.IP
.nf
\f[C]
nodes_count = frov_graph.number_of_nodes()
print(\[aq]Number of nodes: \[aq], nodes_count)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Number of nodes: 13
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a long (int64) type value specifying the number of
node/vertices.
.SS 9. save(fname)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]fname\f[B]\f[R]: A string object containing the name of the
file on which the adjacency matrix is to be saved.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
On success, it writes the adjacency matrix information in the specified
file.
Otherwise, it throws an exception.
.PP
For example,
.IP
.nf
\f[C]
# To save the frovedis graph  
frov_graph.save(\[dq]./out/FrovGraph\[dq])  
\f[R]
.fi
.PP
This will save the frovedis grpah on the path `/out/FrovGraph'.
It would raise exception if the directory already exists with same name.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 10. load_text(fname)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]fname\f[B]\f[R]: A string object containing the name of the
file having adjacency matrix information to be loaded.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It loads a frovedis graph from the specified file path (having adjacency
matrix data).
.PP
For example,
.IP
.nf
\f[C]
# To load the frovedis graph  
frov_graph.load_text(\[dq]./out/FrovGraph\[dq])  
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 11. to_networkx_graph()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to convert a frovedis graph into a networkx graph.
.PP
For example,
.IP
.nf
\f[C]
nx_graph = frov_graph.to_networkx_graph()
print(nx_graph.adj)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
{0: {1: {\[aq]weight\[aq]: 1.0}, 2: {\[aq]weight\[aq]: 1.0}, 3: {\[aq]weight\[aq]: 1.0}, 4: {\[aq]weight\[aq]: 1.0}, 
5: {\[aq]weight\[aq]: 1.0}}, 1: {0: {\[aq]weight\[aq]: 1.0}}, 2: {0: {\[aq]weight\[aq]: 1.0}}, 
3: {0: {\[aq]weight\[aq]: 1.0}}, 4: {0: {\[aq]weight\[aq]: 1.0}}, 5: {0: {\[aq]weight\[aq]: 1.0}}, 
6: {7: {\[aq]weight\[aq]: 1.0}, 8: {\[aq]weight\[aq]: 1.0}, 9: {\[aq]weight\[aq]: 1.0}, 10: {\[aq]weight\[aq]: 1.0}}, 
7: {6: {\[aq]weight\[aq]: 1.0}}, 8: {6: {\[aq]weight\[aq]: 1.0}}, 9: {6: {\[aq]weight\[aq]: 1.0}}, 
10: {6: {\[aq]weight\[aq]: 1.0}}, 11: {12: {\[aq]weight\[aq]: 1.0}}, 12: {11: {\[aq]weight\[aq]: 1.0}}}
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a networkx.Graph instance.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Graph in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Breadth First Search in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Connected Components in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]PageRank in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Single Source Shortest Path in Frovedis\f[R]
