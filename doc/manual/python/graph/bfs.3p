.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Breadth First Search" "" "" "" ""
.hy
.SH NAME
.PP
Breadth First Search - Basic algorithms for breadth-first searching the
nodes of a graph.
.SH SYNOPSIS
.IP
.nf
\f[C]
frovedis.graph.traversal.bfs(G, source, depth_limit=None, opt_level=1, hyb_threshold=0.4, 
                             verbose=0)

frovedis.graph.traversal.bfs_edges(G, source, reverse=False, depth_limit=None, 
                                   sort_neighbors=None, opt_level=1, hyb_threshold=0.4, 
                                   verbose=0)

frovedis.graph.traversal.bfs_tree(G, source, reverse=False, depth_limit=None, 
                                  sort_neighbors=None, opt_level=1, hyb_threshold=0.4, 
                                  verbose=0)

frovedis.graph.traversal.bfs_predecessors(G, source, depth_limit=None, sort_neighbors=None,
                                          opt_level=1, hyb_threshold=0.4, verbose=0)

frovedis.graph.traversal.bfs_successors(G, source, depth_limit=None, sort_neighbors=None,
                                        opt_level=1, hyb_threshold=0.4, verbose=0)

frovedis.graph.traversal.descendants_at_distance(G, source, distance, opt_level=1, 
                                                 hyb_threshold=0.4, verbose=0)
\f[R]
.fi
.SH DESCRIPTION
.PP
Breadth-first search is an algorithm for searching a tree data structure
for a node that satisfies a given property.
It starts at the tree root and explores all nodes at the present depth
prior to moving on to the nodes at the next depth level.
.PP
This module provides a client-server implementation, where the client
application is a normal python program.
The frovedis breadth first search public method interfaces are almost
same as NetworkX breadth first serach public method interface, but it
doesn\[cq]t have any dependency on NetworkX.
It can be used simply even if the system doesn\[cq]t have NetworkX
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.SS Detailed Description
.SS 1. bfs()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]G\f[I]\f[R]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[BI]source\f[I]\f[R]: A positive integer parameter that specifies
the starting node for breadth-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]depth_limit\f[I]\f[R]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[BI]opt_level\f[I]\f[R]: Zero or a positive integer parameter
that must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
- \f[B]When opt_level = 0\f[R]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
- \f[B]When opt_level = 1\f[R]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
- \f[B]When opt_level = 2\f[R]: this is much better than \f[B]`opt_level
= 0'\f[R] but slightly slower than \f[B]opt_level = 1\f[R].
It optimizes the memory usage over \f[B]`opt_level = 1'\f[R].
.PP
\f[I]\f[BI]hyb_threshold\f[I]\f[R]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]`opt_level = 2'\f[R].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method computes bfs traversal path of a graph.
.PP
\f[B]This method is not present in Networkx.
It is only provided in frovedis.\f[R]
.PP
For example,
.PP
FILE: cit-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
G = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
print (\[dq]Frovedis BFS : \[dq], list(fnx.bfs(G, source = 1, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis BFS :  [{1: [1]}, {2: [1, 2]}, {3: [1, 3]}, {4: [1, 4]}, {5: [1, 5]}, {6: [1, 6]}]
\f[R]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph `G'\f[R]
.IP
.nf
\f[C]
print (\[dq]Frovedis BFS : \[dq], list(fnx.bfs(G, source = 7, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis BFS :  [{7: [7]}, {8: [7, 8]}, {9: [7, 9]}, {10: [7, 10]}, {11: [7, 11]}]
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a dictionary with keys as destination node-id and values as
corresponding traversal path from the source.
In case any node in input graph not reachable from the source, it would
not be included in the resultant dictionary.
.SS 2. bfs_edges()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]G\f[I]\f[R]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[BI]source\f[I]\f[R]: A positive integer parameter that specifies
the starting node for breadth-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]reverse\f[I]\f[R]: A boolean parameter, in general, specifies
the direction of traversal (forward or backward) if \f[B]`G'\f[R] is a
directed graph.
Currently, it can only traverse in forward direction \f[B](reverse =
True not supported yet)\f[R].
(Default: False)
.PD 0
.P
.PD
\f[I]\f[BI]depth_limit\f[I]\f[R]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[BI]sort_neighbors\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]opt_level\f[I]\f[R]: Zero or a positive integer parameter
that must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
- \f[B]When opt_level = 0\f[R]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
- \f[B]When opt_level = 1\f[R]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
- \f[B]When opt_level = 2\f[R]: this is much better than \f[B]`opt_level
= 0'\f[R] but slightly slower than \f[B]opt_level = 1\f[R].
It optimizes the memory usage over \f[B]`opt_level = 1'\f[R].
.PP
\f[I]\f[BI]hyb_threshold\f[I]\f[R]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]`opt_level = 2'\f[R].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method iterates over edges in a breadth-first-search starting at
source.
.PP
The parameter: \[lq]sort_neighbors\[rq] is simply kept to make the
method uniform to NetworkX bfs_edges method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
G = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
print(\[dq]Frovedis BFS edges: \[dq], list(fnx.bfs_edges(G, source = 1, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis BFS edges:  [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]
\f[R]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph `G'\f[R]
.IP
.nf
\f[C]
print(\[dq]Frovedis BFS edges: \[dq], list(fnx.bfs_edges(G, source = 7, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis BFS edges:  [(7, 8), (7, 9), (7, 10), (7, 11)]
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It yields edges resulting from the breadth-first search.
.SS 3. bfs_tree()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]G\f[I]\f[R]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[BI]source\f[I]\f[R]: A positive integer parameter that specifies
the starting node for breadth-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]reverse\f[I]\f[R]: A boolean parameter, in general, specifies
the direction of traversal (forward or backward) if \f[B]`G'\f[R] is a
directed graph.
Currently, it can only traverse in forward direction \f[B](reverse =
True not supported yet)\f[R].
(Default: False)
.PD 0
.P
.PD
\f[I]\f[BI]depth_limit\f[I]\f[R]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[BI]sort_neighbors\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]opt_level\f[I]\f[R]: Zero or a positive integer parameter
that must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
- \f[B]When opt_level = 0\f[R]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
- \f[B]When opt_level = 1\f[R]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
- \f[B]When opt_level = 2\f[R]: this is much better than \f[B]`opt_level
= 0'\f[R] but slightly slower than \f[B]opt_level = 1\f[R].
It optimizes the memory usage over \f[B]`opt_level = 1'\f[R].
.PP
\f[I]\f[BI]hyb_threshold\f[I]\f[R]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]`opt_level = 2'\f[R].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method constructs a directed tree from of a breadth-first-search
starting at source.
.PP
The parameter: \[lq]sort_neighbors\[rq] is simply kept to make the
method uniform to NetworkX bfs_tree method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
G = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
fnx.bfs_tree(G, source = 1, depth_limit = 1)

# To check edges in newly created networkx directed graph
print(\[dq]Edges in Frovedis bfs_tree: \[dq])
print(fnx.bfs_tree(G, source = 1, depth_limit = 1).number_of_edges())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Edges in Frovedis bfs_tree:  
5
\f[R]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph `G'\f[R]
.IP
.nf
\f[C]
fnx.bfs_tree(G, source = 7, depth_limit = 1)

# To check edges in newly created networkx directed graph
print(\[dq]Edges in Frovedis bfs_tree: \[dq])
print(fnx.bfs_tree(G, source = 7, depth_limit = 1).number_of_edges())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Edges in Frovedis bfs_tree:  
4
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a new Networkx.DiGraph instance.
.SS 4. bfs_predecessors()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]G\f[I]\f[R]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[BI]source\f[I]\f[R]: A positive integer parameter that specifies
the starting node for breadth-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]depth_limit\f[I]\f[R]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[BI]sort_neighbors\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]opt_level\f[I]\f[R]: Zero or a positive integer parameter
that must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
- \f[B]When opt_level = 0\f[R]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
- \f[B]When opt_level = 1\f[R]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
- \f[B]When opt_level = 2\f[R]: this is much better than \f[B]`opt_level
= 0'\f[R] but slightly slower than \f[B]opt_level = 1\f[R].
It optimizes the memory usage over \f[B]`opt_level = 1'\f[R].
.PP
\f[I]\f[BI]hyb_threshold\f[I]\f[R]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]`opt_level = 2'\f[R].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method provides predecessors for each node in breadth-first-search
from source.
.PP
The parameter: \[lq]sort_neighbors\[rq] is simply kept to make the
method uniform to NetworkX bfs_tree method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
G = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
print(\[dq]Frovedis bfs_predecessors: \[dq])
print(list(fnx.bfs_predecessors(G, source = 1, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis bfs_predecessors:  
[(2, 1), (3, 1), (4, 1), (5, 1), (6, 1)]
\f[R]
.fi
.PP
Here, node 2, node 3, node 4, node 5 and node 6 were having source = 1
as thier predecessor.
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph `G'\f[R]
.IP
.nf
\f[C]
print(\[dq]Frovedis bfs_predecessors: \[dq])
print(list(fnx.bfs_predecessors(G, source = 7, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis bfs_predecessors:  
[(8, 7), (9, 7), (10, 7), (11, 7)]
\f[R]
.fi
.PP
Here, node 8, node 9, node 10 and node 11 were having source = 7 as
thier predecessor.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It yields predecessors for each node in form of \f[B](node,
predecessor)\f[R] iterator.
.SS 5. bfs_successors()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]G\f[I]\f[R]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[BI]source\f[I]\f[R]: A positive integer parameter that specifies
the starting node for breadth-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]depth_limit\f[I]\f[R]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[BI]sort_neighbors\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]opt_level\f[I]\f[R]: Zero or a positive integer parameter
that must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
- \f[B]When opt_level = 0\f[R]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
- \f[B]When opt_level = 1\f[R]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
- \f[B]When opt_level = 2\f[R]: this is much better than \f[B]`opt_level
= 0'\f[R] but slightly slower than \f[B]opt_level = 1\f[R].
It optimizes the memory usage over \f[B]`opt_level = 1'\f[R].
.PP
\f[I]\f[BI]hyb_threshold\f[I]\f[R]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]`opt_level = 2'\f[R].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method provides successors for each node in breadth-first-search
from source.
.PP
The parameter: \[lq]sort_neighbors\[rq] is simply kept to make the
method uniform to NetworkX bfs_tree method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
G = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
print(\[dq]Frovedis bfs_successors: \[dq], list(fnx.bfs_successors(G, source = 1, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis bfs_successors:  [(1, [2, 3, 4, 5, 6])]
\f[R]
.fi
.PP
Here, for source = 1, node 2, node 3, node 4, node 5 and node 6 were its
successor.
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph `G'\f[R]
.IP
.nf
\f[C]
print(\[dq]Frovedis bfs_successors: \[dq], list(fnx.bfs_successors(G, source = 7, depth_limit = 1)))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis bfs_successors:  [(7, [8, 9, 10, 11])]
\f[R]
.fi
.PP
Here, for source = 7, node 8, node 9, node 10 and node 11 were its
successor.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It yields successors for each node in form of \f[B](node,
successor)\f[R] iterator.
.SS 6. descendants_at_distance()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]G\f[I]\f[R]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[BI]source\f[I]\f[R]: A positive integer parameter that specifies
the starting node for breadth-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]distance\f[I]\f[R]: A positive integer parameter that
specifies the distance of the wanted nodes from source.
.PD 0
.P
.PD
\f[I]\f[BI]opt_level\f[I]\f[R]: Zero or a positive integer parameter
that must be in range 0 to 2.
It is an optimization parameter is used for reducing computation times
during breadth first search.
(Default: 1)
.PD 0
.P
.PD
- \f[B]When opt_level = 0\f[R]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
- \f[B]When opt_level = 1\f[R]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
- \f[B]When opt_level = 2\f[R]: this is much better than \f[B]`opt_level
= 0'\f[R] but slightly slower than \f[B]opt_level = 1\f[R].
It optimizes the memory usage over \f[B]`opt_level = 1'\f[R].
.PP
\f[I]\f[BI]hyb_threshold\f[I]\f[R]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]`opt_level = 2'\f[R].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method returns all nodes at a fixed distance from source in G.
.PP
For example,
.PP
FILE: cit-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
G = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
print(\[dq]Frovedis descendants at distance:\[dq])
print(fnx.descendants_at_distance(G, source = 1, distance = 1))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis descendants at distance: 
{2, 3, 4, 5, 6}
\f[R]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph `G'\f[R]
.IP
.nf
\f[C]
print(\[dq]Frovedis descendants at distance:\[dq])
print(fnx.descendants_at_distance(G, source = 7, distance = 1))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis descendants at distance: 
{8, 9, 10, 11}
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns an instance of Set having the descendants of source in graph
`G' at the given distance from source.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Graph in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Connected Components in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Single Source Shortest Path in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]PageRank in Frovedis\f[R]
