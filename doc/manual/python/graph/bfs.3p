.TH "Breadth First Search" "" "" "" ""
.SH NAME
.PP
Breadth First Search \- Basic algorithms for breadth\-first searching
the nodes of a graph.
.SH SYNOPSIS
.IP
.nf
\f[C]
frovedis.graph.traversal.bfs(G,\ source,\ depth_limit=None,\ opt_level=1,\ hyb_threshold=0.4,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ verbose=0)

frovedis.graph.traversal.bfs_edges(G,\ source,\ reverse=False,\ depth_limit=None,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sort_neighbors=None,\ opt_level=1,\ hyb_threshold=0.4,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ verbose=0)

frovedis.graph.traversal.bfs_tree(G,\ source,\ reverse=False,\ depth_limit=None,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sort_neighbors=None,\ opt_level=1,\ hyb_threshold=0.4,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ verbose=0)

frovedis.graph.traversal.bfs_predecessors(G,\ source,\ depth_limit=None,\ sort_neighbors=None,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ opt_level=1,\ hyb_threshold=0.4,\ verbose=0)

frovedis.graph.traversal.bfs_successors(G,\ source,\ depth_limit=None,\ sort_neighbors=None,
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ opt_level=1,\ hyb_threshold=0.4,\ verbose=0)

frovedis.graph.traversal.descendants_at_distance(G,\ source,\ distance,\ opt_level=1,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ hyb_threshold=0.4,\ verbose=0)
\f[]
.fi
.SH DESCRIPTION
.PP
Breadth\-first search is an algorithm for searching a tree data
structure for a node that satisfies a given property.
It starts at the tree root and explores all nodes at the present depth
prior to moving on to the nodes at the next depth level.
.PP
This module provides a client\-server implementation, where the client
application is a normal python program.
The frovedis breadth first search public method interfaces are almost
same as NetworkX breadth first serach public method interface, but it
doesn't have any dependency on NetworkX.
It can be used simply even if the system doesn't have NetworkX
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.SS Detailed Description
.SS 1. bfs()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]G\f[]\f[]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[B]source\f[]\f[]: A positive integer parameter that specifies
the starting node for breadth\-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[].
.PD 0
.P
.PD
\f[I]\f[B]depth_limit\f[]\f[]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[B]opt_level\f[]\f[]: Zero or a positive integer parameter that
must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
\- \f[B]When opt_level = 0\f[]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
\- \f[B]When opt_level = 1\f[]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
\- \f[B]When opt_level = 2\f[]: this is much better than
\f[B]\[aq]opt_level = 0\[aq]\f[] but slightly slower than \f[B]opt_level
= 1\f[].
It optimizes the memory usage over \f[B]\[aq]opt_level = 1\[aq]\f[].
.PP
\f[I]\f[B]hyb_threshold\f[]\f[]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]\[aq]opt_level = 2\[aq]\f[].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method computes bfs traversal path of a graph.
.PP
\f[B]This method is not present in Networkx. It is only provided in
frovedis.\f[]
.PP
For example,
.PP
FILE: cit\-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
G\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
print\ ("Frovedis\ BFS\ :\ ",\ list(fnx.bfs(G,\ source\ =\ 1,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ BFS\ :\ \ [{1:\ [1]},\ {2:\ [1,\ 2]},\ {3:\ [1,\ 3]},\ {4:\ [1,\ 4]},\ {5:\ [1,\ 5]},\ {6:\ [1,\ 6]}]
\f[]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph \[aq]G\[aq]\f[]
.IP
.nf
\f[C]
print\ ("Frovedis\ BFS\ :\ ",\ list(fnx.bfs(G,\ source\ =\ 7,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ BFS\ :\ \ [{7:\ [7]},\ {8:\ [7,\ 8]},\ {9:\ [7,\ 9]},\ {10:\ [7,\ 10]},\ {11:\ [7,\ 11]}]
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a dictionary with keys as destination node\-id and values as
corresponding traversal path from the source.
In case any node in input graph not reachable from the source, it would
not be included in the resultant dictionary.
.SS 2. bfs_edges()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]G\f[]\f[]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[B]source\f[]\f[]: A positive integer parameter that specifies
the starting node for breadth\-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[].
.PD 0
.P
.PD
\f[I]\f[B]reverse\f[]\f[]: A boolean parameter, in general, specifies
the direction of traversal (forward or backward) if \f[B]\[aq]G\[aq]\f[]
is a directed graph.
Currently, it can only traverse in forward direction \f[B](reverse =
True not supported yet)\f[].
(Default: False)
.PD 0
.P
.PD
\f[I]\f[B]depth_limit\f[]\f[]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[B]sort_neighbors\f[]\f[]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]opt_level\f[]\f[]: Zero or a positive integer parameter that
must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
\- \f[B]When opt_level = 0\f[]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
\- \f[B]When opt_level = 1\f[]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
\- \f[B]When opt_level = 2\f[]: this is much better than
\f[B]\[aq]opt_level = 0\[aq]\f[] but slightly slower than \f[B]opt_level
= 1\f[].
It optimizes the memory usage over \f[B]\[aq]opt_level = 1\[aq]\f[].
.PP
\f[I]\f[B]hyb_threshold\f[]\f[]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]\[aq]opt_level = 2\[aq]\f[].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method iterates over edges in a breadth\-first\-search starting at
source.
.PP
The parameter: "sort_neighbors" is simply kept to make the method
uniform to NetworkX bfs_edges method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit\-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
G\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
print("Frovedis\ BFS\ edges:\ ",\ list(fnx.bfs_edges(G,\ source\ =\ 1,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ BFS\ edges:\ \ [(1,\ 2),\ (1,\ 3),\ (1,\ 4),\ (1,\ 5),\ (1,\ 6)]
\f[]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph \[aq]G\[aq]\f[]
.IP
.nf
\f[C]
print("Frovedis\ BFS\ edges:\ ",\ list(fnx.bfs_edges(G,\ source\ =\ 7,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ BFS\ edges:\ \ [(7,\ 8),\ (7,\ 9),\ (7,\ 10),\ (7,\ 11)]
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It yields edges resulting from the breadth\-first search.
.SS 3. bfs_tree()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]G\f[]\f[]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[B]source\f[]\f[]: A positive integer parameter that specifies
the starting node for breadth\-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[].
.PD 0
.P
.PD
\f[I]\f[B]reverse\f[]\f[]: A boolean parameter, in general, specifies
the direction of traversal (forward or backward) if \f[B]\[aq]G\[aq]\f[]
is a directed graph.
Currently, it can only traverse in forward direction \f[B](reverse =
True not supported yet)\f[].
(Default: False)
.PD 0
.P
.PD
\f[I]\f[B]depth_limit\f[]\f[]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[B]sort_neighbors\f[]\f[]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]opt_level\f[]\f[]: Zero or a positive integer parameter that
must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
\- \f[B]When opt_level = 0\f[]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
\- \f[B]When opt_level = 1\f[]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
\- \f[B]When opt_level = 2\f[]: this is much better than
\f[B]\[aq]opt_level = 0\[aq]\f[] but slightly slower than \f[B]opt_level
= 1\f[].
It optimizes the memory usage over \f[B]\[aq]opt_level = 1\[aq]\f[].
.PP
\f[I]\f[B]hyb_threshold\f[]\f[]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]\[aq]opt_level = 2\[aq]\f[].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method constructs a directed tree from of a breadth\-first\-search
starting at source.
.PP
The parameter: "sort_neighbors" is simply kept to make the method
uniform to NetworkX bfs_tree method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit\-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
G\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
fnx.bfs_tree(G,\ source\ =\ 1,\ depth_limit\ =\ 1)

#\ To\ check\ edges\ in\ newly\ created\ networkx\ directed\ graph
print("Edges\ in\ Frovedis\ bfs_tree:\ ")
print(fnx.bfs_tree(G,\ source\ =\ 1,\ depth_limit\ =\ 1).number_of_edges())
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Edges\ in\ Frovedis\ bfs_tree:\ \ 
5
\f[]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph \[aq]G\[aq]\f[]
.IP
.nf
\f[C]
fnx.bfs_tree(G,\ source\ =\ 7,\ depth_limit\ =\ 1)

#\ To\ check\ edges\ in\ newly\ created\ networkx\ directed\ graph
print("Edges\ in\ Frovedis\ bfs_tree:\ ")
print(fnx.bfs_tree(G,\ source\ =\ 7,\ depth_limit\ =\ 1).number_of_edges())
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Edges\ in\ Frovedis\ bfs_tree:\ \ 
4
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a new Networkx.DiGraph instance.
.SS 4. bfs_predecessors()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]G\f[]\f[]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[B]source\f[]\f[]: A positive integer parameter that specifies
the starting node for breadth\-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[].
.PD 0
.P
.PD
\f[I]\f[B]depth_limit\f[]\f[]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[B]sort_neighbors\f[]\f[]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]opt_level\f[]\f[]: Zero or a positive integer parameter that
must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
\- \f[B]When opt_level = 0\f[]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
\- \f[B]When opt_level = 1\f[]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
\- \f[B]When opt_level = 2\f[]: this is much better than
\f[B]\[aq]opt_level = 0\[aq]\f[] but slightly slower than \f[B]opt_level
= 1\f[].
It optimizes the memory usage over \f[B]\[aq]opt_level = 1\[aq]\f[].
.PP
\f[I]\f[B]hyb_threshold\f[]\f[]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]\[aq]opt_level = 2\[aq]\f[].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method provides predecessors for each node in
breadth\-first\-search from source.
.PP
The parameter: "sort_neighbors" is simply kept to make the method
uniform to NetworkX bfs_tree method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit\-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
G\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
print("Frovedis\ bfs_predecessors:\ ")
print(list(fnx.bfs_predecessors(G,\ source\ =\ 1,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ bfs_predecessors:\ \ 
[(2,\ 1),\ (3,\ 1),\ (4,\ 1),\ (5,\ 1),\ (6,\ 1)]
\f[]
.fi
.PP
Here, node 2, node 3, node 4, node 5 and node 6 were having source = 1
as thier predecessor.
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph \[aq]G\[aq]\f[]
.IP
.nf
\f[C]
print("Frovedis\ bfs_predecessors:\ ")
print(list(fnx.bfs_predecessors(G,\ source\ =\ 7,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ bfs_predecessors:\ \ 
[(8,\ 7),\ (9,\ 7),\ (10,\ 7),\ (11,\ 7)]
\f[]
.fi
.PP
Here, node 8, node 9, node 10 and node 11 were having source = 7 as
thier predecessor.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It yields predecessors for each node in form of \f[B](node,
predecessor)\f[] iterator.
.SS 5. bfs_successors()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]G\f[]\f[]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[B]source\f[]\f[]: A positive integer parameter that specifies
the starting node for breadth\-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[].
.PD 0
.P
.PD
\f[I]\f[B]depth_limit\f[]\f[]: A positive integer parameter that
specifies the maximum search depth.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as maximum
value for int64 datatype.
.PD 0
.P
.PD
\f[I]\f[B]sort_neighbors\f[]\f[]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[B]opt_level\f[]\f[]: Zero or a positive integer parameter that
must be in range 0 to 2.
It is an optimization parameter that is used for reducing computation
times during breadth first search.
(Default: 1)
.PD 0
.P
.PD
\- \f[B]When opt_level = 0\f[]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
\- \f[B]When opt_level = 1\f[]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
\- \f[B]When opt_level = 2\f[]: this is much better than
\f[B]\[aq]opt_level = 0\[aq]\f[] but slightly slower than \f[B]opt_level
= 1\f[].
It optimizes the memory usage over \f[B]\[aq]opt_level = 1\[aq]\f[].
.PP
\f[I]\f[B]hyb_threshold\f[]\f[]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]\[aq]opt_level = 2\[aq]\f[].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method provides successors for each node in breadth\-first\-search
from source.
.PP
The parameter: "sort_neighbors" is simply kept to make the method
uniform to NetworkX bfs_tree method.
It is not used anywhere within the frovedis implementation.
.PP
For example,
.PP
FILE: cit\-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
G\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
print("Frovedis\ bfs_successors:\ ",\ list(fnx.bfs_successors(G,\ source\ =\ 1,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ bfs_successors:\ \ [(1,\ [2,\ 3,\ 4,\ 5,\ 6])]
\f[]
.fi
.PP
Here, for source = 1, node 2, node 3, node 4, node 5 and node 6 were its
successor.
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph \[aq]G\[aq]\f[]
.IP
.nf
\f[C]
print("Frovedis\ bfs_successors:\ ",\ list(fnx.bfs_successors(G,\ source\ =\ 7,\ depth_limit\ =\ 1)))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ bfs_successors:\ \ [(7,\ [8,\ 9,\ 10,\ 11])]
\f[]
.fi
.PP
Here, for source = 7, node 8, node 9, node 10 and node 11 were its
successor.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It yields successors for each node in form of \f[B](node, successor)\f[]
iterator.
.SS 6. descendants_at_distance()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]G\f[]\f[]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[B]source\f[]\f[]: A positive integer parameter that specifies
the starting node for breadth\-first search.
This method iterates over only those edges in the component, reachable
from this node.
It must be in range \f[B][1, G.num_vertices]\f[].
.PD 0
.P
.PD
\f[I]\f[B]distance\f[]\f[]: A positive integer parameter that specifies
the distance of the wanted nodes from source.
.PD 0
.P
.PD
\f[I]\f[B]opt_level\f[]\f[]: Zero or a positive integer parameter that
must be in range 0 to 2.
It is an optimization parameter is used for reducing computation times
during breadth first search.
(Default: 1)
.PD 0
.P
.PD
\- \f[B]When opt_level = 0\f[]: this should only be used where systems
have memory constraints.
It is slowest.
.PD 0
.P
.PD
\- \f[B]When opt_level = 1\f[]: this is fastest.
It uses comparatively large amount of memory.
.PD 0
.P
.PD
\- \f[B]When opt_level = 2\f[]: this is much better than
\f[B]\[aq]opt_level = 0\[aq]\f[] but slightly slower than \f[B]opt_level
= 1\f[].
It optimizes the memory usage over \f[B]\[aq]opt_level = 1\[aq]\f[].
.PP
\f[I]\f[B]hyb_threshold\f[]\f[]: A double (float64) parameter that
specifies a threshold value which performs optimization during breadth
first search when the number of remaining nodes to be visited becomes
less then this value.
It optimizes the execution time.
This parameter works only with \f[B]\[aq]opt_level = 2\[aq]\f[].
It must be within the range 0 to 1.
(Default: 0.4)
.PD 0
.P
.PD
For example, if it is 0.5, then optimization starts when number of
remaining nodes to be visited is less than 50%.
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method returns all nodes at a fixed distance from source in G.
.PP
For example,
.PP
FILE: cit\-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
G\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
print("Frovedis\ descendants\ at\ distance:")
print(fnx.descendants_at_distance(G,\ source\ =\ 1,\ distance\ =\ 1))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ descendants\ at\ distance:\ 
{2,\ 3,\ 4,\ 5,\ 6}
\f[]
.fi
.PP
\f[B]In case, we started from node 7 i.e source = 7 in the directed
graph \[aq]G\[aq]\f[]
.IP
.nf
\f[C]
print("Frovedis\ descendants\ at\ distance:")
print(fnx.descendants_at_distance(G,\ source\ =\ 7,\ distance\ =\ 1))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ descendants\ at\ distance:\ 
{8,\ 9,\ 10,\ 11}
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns an instance of Set having the descendants of source in graph
\[aq]G\[aq] at the given distance from source.
.SS SEE ALSO
.PP
graph, pagerank, connected_components, single_source_shortest_path
