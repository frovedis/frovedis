.TH "single_source_shortest_path()" "" "" "" ""
.SH NAME
.PP
single_source_shortest_path() \- finds the shortest path from source to
all reachable nodes in graph \[aq]G\[aq].
Here, graph \[aq]G\[aq] maybe a directed or undirected graph.
.SH SYNOPSIS
.IP
.nf
\f[C]
frovedis.graph.traversal.single_source_shortest_path(G,\ source,\ return_distance=False,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ verbose=0)\ \ 
\f[]
.fi
.SH DESCRIPTION
.PP
In graph theory, the shortest path problem is the problem of finding a
path between two vertices (or nodes) in a graph such that the sum of the
weights of its constituent edges is minimized.
.PP
This module provides a client\-server implementation, where the client
application is a normal python program.
The frovedis public single_source_shortest_path method interface is
almost same as NetworkX single_source_shortest_path public method
interface, but it doesn't have any dependency on NetworkX.
It can be used simply even if the system doesn't have NetworkX
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.PP
Python side calls for single_source_shortest_path() on the frovedis
server.
Once the shortest distances are computed for the given input graph data
at the frovedis server, it returns a dictionary of lists containing
shortest path from source to all other nodes to the client python
program.
.SS Detailed Description
.SS 1. single_source_shortest_path()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]G\f[]\f[]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[B]source\f[]\f[]: A positive integer parameter that specifies
the starting node for the path.
It must be in the range \f[B][1, G.num_vertices]\f[].
.PD 0
.P
.PD
\f[I]\f[B]return_distance\f[]\f[]: A boolean parameter if set to True,
will return the shortest distances from source to all nodes along with
traversal path.
Otherwise, it will return only the traversal path.
(Default: False)
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method computes the shortest path between source and all other
nodes reachable from source.
.PP
For example,
.PP
FILE: cit\-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
frov_graph\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
#\ use\ verbose\ =\ 1\ for\ detailed\ inforrmation\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
path,\ dist\ =\ fnx.single_source_shortest_path(frov_graph,\ source\ =\ 1,\ return_distance=True
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ verbose\ =\ 1)\ 
print("Frovedis\ sssp\ traversal\ path:\ ")
print(list(path))
print("Frovedis\ sssp\ traversal\ distance\ from\ source:\ ")
print(dist)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
sssp\ computation\ time:\ 0.001\ sec.
sssp\ res\ conversion\ time:\ 0.000\ sec.
Frovedis\ sssp\ traversal\ path:\ 
[{1:\ [1]},\ {2:\ [1,\ 2]},\ {3:\ [1,\ 3]},\ {4:\ [1,\ 4]},\ {5:\ [1,\ 5]},\ {6:\ [1,\ 6]}]
Frovedis\ sssp\ traversal\ distance\ from\ source:\ 
{1:\ 0.0,\ 2:\ 1.0,\ 3:\ 1.0,\ 4:\ 1.0,\ 5:\ 1.0,\ 6:\ 1.0}
\f[]
.fi
.PP
\f[B]Incase we had started with node 2 i.e source = 2, then,\f[]
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
frov_graph\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
path,\ dist\ =\ fnx.single_source_shortest_path(frov_graph,\ source\ =\ 2,\ return_distance=True)\ 
print("Frovedis\ sssp\ traversal\ path:\ ")
print(list(path))
print("Frovedis\ sssp\ traversal\ distance\ from\ source:\ ")
print(dist)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ sssp\ traversal\ path:
[{2:\ [2]},\ {1:\ [2,\ 1]},\ {3:\ [2,\ 1,\ 3]},\ {4:\ [2,\ 1,\ 4]},\ {5:\ [2,\ 1,\ 5]},\ {6:\ [2,\ 1,\ 6]}]
Frovedis\ sssp\ traversal\ distance\ from\ source:
{2:\ 0.0,\ 1:\ 1.0,\ 3:\ 2.0,\ 4:\ 2.0,\ 5:\ 2.0,\ 6:\ 2.0}
\f[]
.fi
.PP
\f[B]When source = 2 and return_distances = False,\f[]
.IP
.nf
\f[C]
#\ A\ directed\ graph\ loaded\ from\ edgelist\ file
import\ numpy\ as\ np
import\ networkx\ as\ nx
import\ frovedis.graph\ as\ fnx
frov_graph\ =\ fnx.read_edgelist(\[aq]input/cit\-Patents_10.txt\[aq],\ nodetype\ =\ np.int32,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ create_using\ =\ nx.DiGraph())
#\ return_distances\ =\ False,\ by\ default
path=\ fnx.single_source_shortest_path(frov_graph,\ source\ =\ 2)\ 
print("Frovedis\ sssp\ traversal\ path:\ ")
print(list(path))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis\ sssp\ traversal\ path:
[{2:\ [2]},\ {1:\ [2,\ 1]},\ {3:\ [2,\ 1,\ 3]},\ {4:\ [2,\ 1,\ 4]},\ {5:\ [2,\ 1,\ 5]},\ {6:\ [2,\ 1,\ 6]}]
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a dictionary of lists containing shortest path from source to
all other nodes.
.SS SEE ALSO
.PP
graph, bfs, connected_components, pagerank
