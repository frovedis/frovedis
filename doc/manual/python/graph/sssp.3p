.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "single_source_shortest_path" "" "" "" ""
.hy
.SH NAME
.PP
single_source_shortest_path() - finds the shortest path from source to
all reachable nodes in graph `G'.
Here, graph `G' maybe a directed or undirected graph.
.SH SYNOPSIS
.IP
.nf
\f[C]
frovedis.graph.traversal.single_source_shortest_path(G, source, return_distance=False, 
                                                     verbose=0)  
\f[R]
.fi
.SH DESCRIPTION
.PP
In graph theory, the shortest path problem is the problem of finding a
path between two vertices (or nodes) in a graph such that the sum of the
weights of its constituent edges is minimized.
.PP
This module provides a client-server implementation, where the client
application is a normal python program.
The frovedis public single_source_shortest_path method interface is
almost same as NetworkX single_source_shortest_path public method
interface, but it doesn\[cq]t have any dependency on NetworkX.
It can be used simply even if the system doesn\[cq]t have NetworkX
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.PP
Python side calls for single_source_shortest_path() on the frovedis
server.
Once the shortest distances are computed for the given input graph data
at the frovedis server, it returns a dictionary of lists containing
shortest path from source to all other nodes to the client python
program.
.SS Detailed Description
.SS 1. single_source_shortest_path()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]G\f[I]\f[R]: An instance of networkx graph or frovedis graph.
The graph can be directed or undirected.
.PD 0
.P
.PD
\f[I]\f[BI]source\f[I]\f[R]: A positive integer parameter that specifies
the starting node for the path.
It must be in the range \f[B][1, G.num_vertices]\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]return_distance\f[I]\f[R]: A boolean parameter if set to
True, will return the shortest distances from source to all nodes along
with traversal path.
Otherwise, it will return only the traversal path.
(Default: False)
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (INFO level).
But it can be set to 1 (DEBUG level) or 2 (TRACE level) for getting
training time logs from frovedis server.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method computes the shortest path between source and all other
nodes reachable from source.
.PP
For example,
.PP
FILE: cit-Patents.txt
.PP
1 2
.PD 0
.P
.PD
1 3
.PD 0
.P
.PD
1 4
.PD 0
.P
.PD
1 5
.PD 0
.P
.PD
1 6
.PD 0
.P
.PD
7 8
.PD 0
.P
.PD
7 9
.PD 0
.P
.PD
7 10
.PD 0
.P
.PD
7 11
.PD 0
.P
.PD
12 13
.PP
Here, the above file contains a list of edges between the nodes of graph
G.
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
frov_graph = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
# use verbose = 1 for detailed inforrmation                      
path, dist = fnx.single_source_shortest_path(frov_graph, source = 1, return_distance=True
                                             verbose = 1) 
print(\[dq]Frovedis sssp traversal path: \[dq])
print(list(path))
print(\[dq]Frovedis sssp traversal distance from source: \[dq])
print(dist)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
sssp computation time: 0.001 sec.
sssp res conversion time: 0.000 sec.
Frovedis sssp traversal path: 
[{1: [1]}, {2: [1, 2]}, {3: [1, 3]}, {4: [1, 4]}, {5: [1, 5]}, {6: [1, 6]}]
Frovedis sssp traversal distance from source: 
{1: 0.0, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0, 6: 1.0}
\f[R]
.fi
.PP
\f[B]Incase we had started with node 2 i.e source = 2, then,\f[R]
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
frov_graph = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
path, dist = fnx.single_source_shortest_path(frov_graph, source = 2, return_distance=True) 
print(\[dq]Frovedis sssp traversal path: \[dq])
print(list(path))
print(\[dq]Frovedis sssp traversal distance from source: \[dq])
print(dist)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis sssp traversal path:
[{2: [2]}, {1: [2, 1]}, {3: [2, 1, 3]}, {4: [2, 1, 4]}, {5: [2, 1, 5]}, {6: [2, 1, 6]}]
Frovedis sssp traversal distance from source:
{2: 0.0, 1: 1.0, 3: 2.0, 4: 2.0, 5: 2.0, 6: 2.0}
\f[R]
.fi
.PP
\f[B]When source = 2 and return_distances = False,\f[R]
.IP
.nf
\f[C]
# A directed graph loaded from edgelist file
import numpy as np
import networkx as nx
import frovedis.graph as fnx
frov_graph = fnx.read_edgelist(\[aq]input/cit-Patents_10.txt\[aq], nodetype = np.int32, 
                      create_using = nx.DiGraph())
# return_distances = False, by default
path= fnx.single_source_shortest_path(frov_graph, source = 2) 
print(\[dq]Frovedis sssp traversal path: \[dq])
print(list(path))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Frovedis sssp traversal path:
[{2: [2]}, {1: [2, 1]}, {3: [2, 1, 3]}, {4: [2, 1, 4]}, {5: [2, 1, 5]}, {6: [2, 1, 6]}]
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a dictionary of lists containing shortest path from source to
all other nodes.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Graph in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Breadth First Search in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Connected Components in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]PageRank in Frovedis\f[R]
