.TH "KMeans Clustering" "" "" "" ""
.SH NAME
.PP
KMeans\- is a clustering algorithm commonly used in EDA (exploratory
data analysis).
.SH SYNOPSIS
.PP
class frovedis.mllib.cluster.KMeans(n_clusters=8, init=\[aq]random\[aq],
n_init=10, max_iter=300,
.PD 0
.P
.PD
\  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \ 
\ tol=1e\-4, precompute_distances=\[aq]auto\[aq], verbose=0,
.PD 0
.P
.PD
\  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \ 
\ random_state=None, copy_x=True, n_jobs=1,
.PD 0
.P
.PD
\  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \  \ 
\ algorithm=\[aq]auto\[aq], use_shrink=False)
.SS Public Member Functions
.PP
fit(X, y = None, sample_weight = None)
.PD 0
.P
.PD
fit_predict(X, y = None, sample_weight = None)
.PD 0
.P
.PD
fit_transform(X, y = None, sample_weight = None)
.PD 0
.P
.PD
transform(X)
.PD 0
.P
.PD
predict(X, sample_weight = None)
.PD 0
.P
.PD
score(X, y = None, sample_weight = None)
.PD 0
.P
.PD
load(fname, dtype = None)
.PD 0
.P
.PD
save(fname)
.PD 0
.P
.PD
get_params(deep = True)
.PD 0
.P
.PD
set_params(**params)
.PD 0
.P
.PD
debug_print()
.PD 0
.P
.PD
release()
.PD 0
.P
.PD
is_fitted()
.SH DESCRIPTION
.PP
Clustering is an unsupervised learning problem whereby we aim to group
subsets of entities with one another based on some notion of similarity.
Kmeans is one of the most commonly used clustering algorithms that
clusters the data points into a predefined number of clusters.
.PP
Under unsupervised learning, there are two clustering methods\-
\[aq]k\-means\[aq] and \[aq]k\-means++\[aq].
The main difference between these two lies in the selection of the
centroids (we assume centroid is the center of the cluster) around which
the clustering takes place.
.PP
Frovedis supports only k\-means clustering method (i.e.
init =\[aq]random\[aq]) which will randomly initialize the data points
called centroid.
Further, each data point is clustered to its nearest centroid and after
every iteration the centroid is updated for each cluster.
This cycle continues for a given number of repetitions and after that we
have our final clusters.
.PP
This module provides a client\-server implementation, where the client
application is a normal python program.
Frovedis is almost same as Scikit\-learn clustering module providing
kmeans support, but it doesn't have any dependency with Scikit\-learn.
It can be used simply even if the system doesn't have Scikit\-learn
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.PP
Python side calls for Kmeans on the frovedis server.
Once the training is completed with the input data at the frovedis
server, it returns an abstract model with a unique model ID to the
client python program.
.PP
When prediction\-like request would be made on the trained model, the
python program will send the same request to the frovedis server.
After the request is served at the frovedis server, the output would be
sent back to the python client.
.SS Detailed Description
.SS 1. KMeans()
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]n_clusters\f[]\f[]: An integer parameter specifying the number
of clusters.
The number of clusters should be greater than zero and less than
n_samples.
(Default: 8)
.PD 0
.P
.PD
When it is None (specified explicitly), then it will be set as min(8,
nsamples).
.PD 0
.P
.PD
\f[I]\f[B]init\f[]\f[]: A string object parameter specifies the method
of initialization.
(Default: \[aq]random\[aq])
.PD 0
.P
.PD
Unlike Scikit\-learn, currently it only supports \[aq]random\[aq]
initialization.
.PD 0
.P
.PD
\f[I]\f[B]n_init\f[]\f[]: A positive integer specifying the number of
times the kmeans algorithm will be run with different centroid seeds.
(Default: 10)
.PD 0
.P
.PD
When it is None (specified explicitly), then it will be set as default
10.
.PD 0
.P
.PD
\f[I]\f[B]max_iter\f[]\f[]: A positive integer parameter specifying the
maximum iteration count.
(Default: 300)
.PD 0
.P
.PD
\f[I]\f[B]tol\f[]\f[]: Zero or a positive double(float64) parameter
specifying the convergence tolerance.
(Default: 1e\-4)
.PD 0
.P
.PD
\f[I]\f[B]precompute_distances\f[]\f[]: A string object parameter.
(unused)
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is set as 0 by default(for INFO mode).
But it can be set to 1(for DEBUG mode) or 2(for TRACE mode) for getting
training time logs from frovedis server.
.PD 0
.P
.PD
\f[I]\f[B]random_state\f[]\f[]: A zero or positive integer parameter.
When it is None (not specified explicitly), it will be set as 0.
(unused)
.PD 0
.P
.PD
\f[I]\f[B]copy_x\f[]\f[]: A boolean parameter.
(unused)
.PD 0
.P
.PD
\f[I]\f[B]n_jobs\f[]\f[]: An integer parameter.
(unused)
.PD 0
.P
.PD
\f[I]\f[B]algorithm\f[]\f[]: A string object parameter, specifies the
kmeans algorithm to use.
(Default: auto)
.PD 0
.P
.PD
When it is \[aq]auto\[aq], it will be set as \[aq]full\[aq].
Unlike Scikit\-learn, currently it supports only \[aq]full\[aq].
.PD 0
.P
.PD
\f[I]\f[B]use_shrink\f[]\f[]: A boolean parameter applicable only for
"sparse" input (X).
When set to True for sparse input, it can improve training performance
by reducing communication overhead across participating processes.
(Default: False)
.PP
\f[B]Attribute\f[]
.PD 0
.P
.PD
\f[I]\f[B]cluster_centers_\f[]\f[]: It is a python ndarray, containing
float or double(float64) typed values and has shape \f[B](n_clusters,
n_features)\f[].
These are the coordinates of cluster centers.
.PD 0
.P
.PD
\f[I]\f[B]labels_\f[]\f[]: A python ndarray of int64 values and has
shape \f[B](n_clusters,)\f[].
It contains predicted cluster labels for each point.
.PD 0
.P
.PD
\f[I]\f[B]inertia_\f[]\f[]: A float parameter specifies the sum of
squared distances of samples to their closest cluster center, weighted
by the sample weights if provided.
.PD 0
.P
.PD
\f[I]\f[B]n_iter_\f[]\f[]: An integer parameter specifies the number of
iterations to run.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It initializes a Kmeans object with the given parameters.
.PP
The parameters: "precompute_distances", "random_state", "copy_x" and
"n_jobs" are simply kept to make the interface uniform to Scikit\-learn
cluster module.
They are not used anywhere within frovedis implementation.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It simply returns "self" reference.
.SS 2. fit(X, y = None, sample_weight = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]X\f[]\f[]: A numpy dense or scipy sparse matrix or any python
array\-like object or an instance of FrovedisCRSMatrix for sparse data
and FrovedisRowmajorMatrix for dense data of float or double(float64)
type.
It has shape \f[B](n_samples, n_features)\f[].
.PD 0
.P
.PD
\f[I]\f[B]y\f[]\f[]: None or any python array\-like object (any shape).
It is simply ignored in frovedis implementation, like in Scikit\-learn.
.PD 0
.P
.PD
\f[I]\f[B]sample_weight\f[]\f[]: An unused parameter whose default value
is None.
It is simply ignored in frovedis implementation, like in Scikit\-learn.
.PP
\f[B]Purpose\f[]
.PP
It clusters the given data points (X) into a predefined number of
clusters (n_clusters).
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
train_mat\ =\ np.loadtxt("sample_data.txt")

#\ fitting\ input\ matrix\ on\ kmeans\ object
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1).fit(train_mat)\ \ \ 
\f[]
.fi
.PP
When native python data is provided, it is converted to frovedis\-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre\-constructed frovedis\-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
train_mat\ =\ np.loadtxt("sample_data.txt")

#\ Since\ "train_mat"\ is\ numpy\ dense\ data,\ we\ have\ created\ FrovedisRowmajorMatrix.
#\ For\ scipy\ sparse\ data,\ FrovedisCRSMatrix\ should\ be\ used\ instead.\ \ \ 
from\ frovedis.matrix.dense\ import\ FrovedisRowmajorMatrix
rmat\ =\ FrovedisRowmajorMatrix(train_mat)

#\ KMeans\ with\ pre\-constructed\ frovedis\-like\ inputs
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1).fit(rmat)
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It simply returns "self" reference.
.SS 3. fit_predict(X, y = None, sample_weight = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]X\f[]\f[]: A numpy dense or scipy sparse matrix or any python
array\-like object or an instance of FrovedisCRSMatrix for sparse data
and FrovedisRowmajorMatrix for dense data of float or double(float64)
type.
It has shape \f[B](n_samples, n_features)\f[].
.PD 0
.P
.PD
\f[I]\f[B]y\f[]\f[]: None or any python array\-like object (any shape).
It is simply ignored in frovedis implementation, like in Scikit\-learn.
.PD 0
.P
.PD
\f[I]\f[B]sample_weight\f[]\f[]: An unused parameter whose default value
is None.
It is simply ignored in frovedis implementation.
.PP
\f[B]Purpose\f[]
.PP
It clusters the given data points (X) into a predefined number of
clusters (n_clusters) and predicts the cluster index for each sample.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
train_mat\ =\ np.loadtxt("sample_data.txt")

#\ fitting\ input\ matrix\ on\ KMeans\ object
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1)
print(kmeans.fit_predict(train_mat))\ \ \ \ 
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[0\ 0\ 1\ 1\ 1]
\f[]
.fi
.PP
Like in fit() frovedis\-like input can be used to speed\-up training at
server side.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data\ \ \ \ 
train_mat\ =\ np.loadtxt("sample_data.txt")

#\ Since\ "train_mat"\ is\ numpy\ dense\ data,\ we\ have\ created\ FrovedisRowmajorMatrix.
#\ For\ scipy\ sparse\ data,\ FrovedisCRSMatrix\ should\ be\ used\ instead.
from\ frovedis.matrix.dense\ import\ FrovedisRowmajorMatrix
rmat\ =\ FrovedisRowmajorMatrix(train_mat)

#\ using\ pre\-constructed\ input\ matrix
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1)
print(kmeans.fit_predict(rmat))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[0\ 0\ 1\ 1\ 1]
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a numpy array of int64 type containing the cluster labels.
It has a shape \f[B](n_samples,)\f[].
.SS 4. fit_transform(X, y = None, sample_weight = None)
.PP
\f[I]\f[B]X\f[]\f[]: A numpy dense or scipy sparse matrix or any python
array\-like object or an instance of FrovedisCRSMatrix for sparse data
and FrovedisRowmajorMatrix for dense data of float or double(float64)
type.
It has shape \f[B](n_samples, n_features)\f[].
.PD 0
.P
.PD
\f[I]\f[B]y\f[]\f[]: None or any python array\-like object (any shape).
It is simply ignored in frovedis implementation, like in Scikit\-learn.
.PD 0
.P
.PD
\f[I]\f[B]sample_weight\f[]\f[]: An unused parameter whose default value
is None and simply ignored in frovedis implementation.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It computes clustering and transforms training data (X) to
cluster\-distance space.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
train_mat\ =\ np.loadtxt("sample_data.txt")

#\ fitting\ input\ matrix\ on\ KMeans\ object
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1)
print(kmeans.fit_transform(train_mat))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 0.08660254\ 15.58845727]
[\ 0.08660254\ 15.41525219]
[15.32864965\ \ 0.17320508]
[15.50185473\ \ 0.\ \ \ \ \ \ \ \ ]
[15.67505981\ \ 0.17320508]]
\f[]
.fi
.PP
If training data (X) is a numpy array or a scipy sparse matrix, it will
return a new numpy dense array.
.PP
Like in fit() frovedis\-like input can be used to speed\-up training at
server side.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
train_mat\ =\ np.loadtxt("sample_data.txt")

#\ Since\ "train_mat"\ is\ numpy\ dense\ data,\ we\ have\ created\ FrovedisRowmajorMatrix.
#\ For\ scipy\ sparse\ data,\ FrovedisCRSMatrix\ should\ be\ used\ instead.
from\ frovedis.matrix.dense\ import\ FrovedisRowmajorMatrix
rmat\ =\ FrovedisRowmajorMatrix(train_mat)

#\ using\ pre\-constructed\ input\ matrix
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1)
#\ it\ returns\ a\ FrovedisRowmajorMatrix\ object
kmeans.fit_transform(rmat)
\f[]
.fi
.PP
If training data (X) is a frovedis\-like input, it will return a
FrovedisRowmajorMatrix object.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
\f[B]When training data is native\-python data, then the output will be
a numpy array containing the transformed matrix.\f[]
.PD 0
.P
.PD
\f[B]When training data is frovedis\-like data is input, then the output
will be a FrovedisRowmajorMatrix.\f[]
.PD 0
.P
.PD
In both cases output would be of float or double (float64) type
(depending upon input dtype) and of shape \f[B](n_samples,
n_clusters)\f[].
.PP
Note that even if training data (X) is sparse, the output would
typically be dense.
.SS 5. transform(X)
.PP
\f[I]\f[B]X\f[]\f[]: A numpy dense or scipy sparse matrix or any python
array\-like object or an instance of FrovedisCRSMatrix for sparse data
and FrovedisRowmajorMatrix for dense data of float or double(float64)
type.
It has shape \f[B](n_samples, n_features)\f[].
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It transforms the test data (X) to a cluster\-distance space.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
test_mat\ =\ np.loadtxt("sample_data.txt")

#\ fitting\ input\ matrix\ on\ kmeans\ object
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1).fit(test_mat)
print(kmeans.transform(test_mat))\ \ \ \ 
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\ 0.08660254\ 15.58845727]
[\ 0.08660254\ 15.41525219]
[15.32864965\ \ 0.17320508]
[15.50185473\ \ 0.\ \ \ \ \ \ \ \ ]
[15.67505981\ \ 0.17320508]]
\f[]
.fi
.PP
If test data (X) is a numpy array or a scipy sparse matrix, it will
return a new numpy dense array.
.PP
Like in fit() frovedis\-like input can be used to speed\-up training the
test data at server side.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
test_mat\ =\ np.loadtxt("sample_data.txt")

#\ Since\ "test_mat"\ is\ numpy\ dense\ data,\ we\ have\ created\ FrovedisRowmajorMatrix.
#\ For\ scipy\ sparse\ data,\ FrovedisCRSMatrix\ should\ be\ used\ instead.\ \ \ 
from\ frovedis.matrix.dense\ import\ FrovedisRowmajorMatrix
tr_mat\ =\ FrovedisRowmajorMatrix(test_mat)

#\ using\ pre\-constructed\ input\ matrix
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1).fit(tr_mat)
kmeans.transform(tr_mat)
\f[]
.fi
.PP
If test data (X) is a frovedis\-like input, it will return
FrovedisRowmajorMatrix object.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
If native\-python data is input, it would output a numpy array
containing the transformed matrix.
If frovedis\-like data is input, it would output a
FrovedisRowmajorMatrix.
In both cases output would be of float or double (float64) type
(depending upon input dtype) and of shape \f[B](n_samples,
n_clusters)\f[].
.PP
Note that even if test data (X) is sparse, the output would typically be
dense.
.SS 6. predict(X, sample_weight = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]X\f[]\f[]: A numpy dense or scipy sparse matrix or any python
array\-like object or an instance of FrovedisCRSMatrix for sparse data
and FrovedisRowmajorMatrix for dense data of float or double(float64)
type.
It has shape \f[B](n_samples, n_features)\f[].
.PD 0
.P
.PD
\f[I]\f[B]sample_weight\f[]\f[]: None or any python array\-like object
containing the intended weights for each input samples.
It is simply ignored in frovedis implementation, like in Scikit\-learn.
.PD 0
.P
.PD
\f[B]Purpose\f[]
.PD 0
.P
.PD
It accepts the test data points (X) and returns the closest cluster each
sample in X belongs to.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
test_mat\ =\ np.loadtxt("sample_data.txt")
\ \ \ \ 
#\ fitting\ input\ matrix\ on\ KMeans\ object
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1).fit(test_mat)
print(kmeans.predict(test_mat))\ \ \ \ 
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[0\ 0\ 1\ 1\ 1]
\f[]
.fi
.PP
Like in fit() frovedis\-like input can be used to speed\-up prediction
on the test data at server side.
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ sample\ matrix\ data
test_mat\ =\ np.loadtxt("sample_data.txt")

#\ Since\ "test_mat"\ is\ numpy\ dense\ data,\ we\ have\ created\ FrovedisRowmajorMatrix.
#\ For\ scipy\ sparse\ data,\ FrovedisCRSMatrix\ should\ be\ used\ instead.
from\ frovedis.matrix.dense\ import\ FrovedisRowmajorMatrix
tr_mat\ =\ FrovedisRowmajorMatrix(test_mat)

#\ using\ pre\-constructed\ input\ matrix
from\ frovedis.mllib.cluster\ import\ KMeans
kmeans\ =\ KMeans(n_clusters\ =\ 2,\ n_init\ =\ 1).fit(tr_mat)
print(kmeans.predict(tr_mat))
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
[0\ 0\ 1\ 1\ 1]
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a numpy array of int32 type containing the centroid values.
It has a shape \f[B](n_samples,)\f[].
.SS 7. score(X, y = None, sample_weight = None)
.PP
\f[I]\f[B]X\f[]\f[]: A numpy dense or scipy sparse matrix or any python
array\-like object or an instance of FrovedisCRSMatrix for sparse data
and FrovedisRowmajorMatrix for dense data of float or double(float64)
type.
It has shape \f[B](n_samples, n_features)\f[].
.PD 0
.P
.PD
\f[I]\f[B]y\f[]\f[]: None or any python array\-like object (any shape).
It is simply ignored in frovedis implementation, like in Scikit\-learn.
.PD 0
.P
.PD
\f[I]\f[B]sample_weight\f[]\f[]: None or any python array\-like object
containing the intended weights for each input samples.
It is simply ignored in frovedis implementation, like in Scikit\-learn.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It is calculated as "\-1.0 * inertia", which an indication of how far
the points are from the centroids.
Bad scores will return a large negative number, whereas good scores
return a value close to zero.
.PP
For example,
.IP
.nf
\f[C]
kmeans.score(test_mat)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
\-0.07499999552965164
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a score of float type.
.SS 8. load(fname, dtype = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]fname\f[]\f[]: A string object containing the name of the file
having model information to be loaded.
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: A data\-type is inferred from the input data.
Currently, expected input data\-type is either float or double(float64).
(Default: None)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It loads the model from the specified file(having little\-endian binary
data).
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ the\ same\ model
kmeans.load("./out/MyKMeansModel",dtype=np.float64)
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It simply returns "self" instance.
.SS 9. save(fname)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]fname\f[]\f[]: A string object containing the name of the file
on which the target model is to be saved.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
On success, it writes the model information in the specified file as
little\-endian binary data.
Otherwise, it throws an exception.
.PP
For example,
.IP
.nf
\f[C]
#\ saving\ the\ model
kmeans.save("./out/MyKMeansModel")
\f[]
.fi
.PP
The MyKMeansModel contains below directory structure:
.PD 0
.P
.PD
\f[B]MyKMeansModel\f[]
.PD 0
.P
.PD
|\-\-\-\-\-\-metadata
.PD 0
.P
.PD
|\-\-\-\-\-\-\f[B]model\f[]
.PP
\[aq]metadata\[aq] represents the detail about model_id, model_kind and
datatype of training vector.
.PD 0
.P
.PD
Here, the \f[B]model\f[] directory contains information about
n_clusters_, n_features, model_kind and datatype of training vector.
.PP
This will save the Kmeans model on the path ‘/out/MyKMeansModel'.
It would raise exception if the directory already exists with same name.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns nothing.
.SS 10. get_params(deep = True)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]deep\f[]\f[]: A boolean parameter, used to get parameters and
their values for an estimator.
If True, will return the parameters for an estimator and contained
subobjects that are estimators.
(Default: True)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by Kmeans.
It is used to get parameters and their values of Kmeans class.
.PP
For example,
.IP
.nf
\f[C]
\ \ print(kmeans.get_params())
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
\ {\[aq]algorithm\[aq]:\ \[aq]auto\[aq],\ \[aq]copy_x\[aq]:\ True,\ \[aq]init\[aq]:\ \[aq]random\[aq],\ \[aq]max_iter\[aq]:\ 300,\ \[aq]n_clusters\[aq]:\ 2,\ 
\ \[aq]n_init\[aq]:\ 1,\ \[aq]n_jobs\[aq]:\ 1,\ \[aq]precompute_distances\[aq]:\ \[aq]auto\[aq],\ \[aq]random_state\[aq]:\ None,\ \[aq]tol\[aq]:\ 0.0001,\ 
\ \[aq]use_shrink\[aq]:\ False,\ \[aq]verbose\[aq]:\ 0}
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
A dictionary of parameter names mapped to their values.
.SS 11. set_params(**params)
.PP
\f[B]Parameters\f[]
.PP
\f[I]\f[B]params\f[]\f[]: All the keyword arguments are passed this
function as dictionary.
This dictionary contains parameters of an estimator with its given
values to set.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by Kmeans, used
to set parameter values.
.PP
For example,
.IP
.nf
\f[C]
print("get\ parameters\ before\ setting:",\ kmeans.get_params())
kmeans.set_params(n_clusters\ =\ 4,\ n_init\ =\ 5)
print("get\ parameters\ after\ setting:",\ kmeans.get_params())
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
get\ parameters\ before\ setting:\ {\[aq]algorithm\[aq]:\ \[aq]auto\[aq],\ \[aq]copy_x\[aq]:\ True,\ \[aq]init\[aq]:\ \[aq]random\[aq],\ 
\[aq]max_iter\[aq]:\ 300,\ \[aq]n_clusters\[aq]:\ 2,\ \[aq]n_init\[aq]:\ 1,\ \[aq]n_jobs\[aq]:\ 1,\[aq]precompute_distances\[aq]:\ \[aq]auto\[aq],\ 
\[aq]random_state\[aq]:\ None,\[aq]tol\[aq]:\ 0.0001,\[aq]use_shrink\[aq]:\ False,\ \[aq]verbose\[aq]:\ 0}
get\ parameters\ after\ setting:\ {\[aq]algorithm\[aq]:\ \[aq]auto\[aq],\ \[aq]copy_x\[aq]:\ True,\ \[aq]init\[aq]:\ \[aq]random\[aq],
\[aq]max_iter\[aq]:\ 300,\ \[aq]n_clusters\[aq]:\ 4,\ \[aq]n_init\[aq]:\ 5,\ \[aq]n_jobs\[aq]:\ 1,\ \[aq]precompute_distances\[aq]:\ \[aq]auto\[aq],\ 
\[aq]random_state\[aq]:\ None,\ \[aq]tol\[aq]:\ 0.0001,\[aq]use_shrink\[aq]:\ False,\ \[aq]verbose\[aq]:\ 0}
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It simply returns "self" reference.
.SS 12. debug_print()
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It shows the target model information on the server side user terminal.
It is mainly used for debugging purpose.
.PP
For example,
.IP
.nf
\f[C]
kmeans.debug_print()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
centroid:
node\ =\ 0,\ local_num_row\ =\ 2,\ local_num_col\ =\ 3,\ val\ =\ 0.15\ 0.15\ 0.15\ 9.1\ 9.1\ 9.1
\f[]
.fi
.PP
It displays the centroid information on the trained model which is
currently present on the server.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns nothing.
.SS 13. release()
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It can be used to release the in\-memory model at frovedis server.
.PP
For example,
.IP
.nf
\f[C]
kmeans.release()
\f[]
.fi
.PP
This will reset the after\-fit populated attributes to None, along with
releasing server side memory.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns nothing.
.SS 14. is_fitted()
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It can be used to confirm if the model is already fitted or not.
In case, predict() is used before training the model, then it can prompt
the user to train the clustering model first.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns ‘True', if the model is already fitted otherwise, it returns
‘False'.
.SS SEE ALSO
.PP
rowmajor_matrix, crs_matrix
