.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Spectral Embedding" "" "" "" ""
.hy
.SH NAME
.PP
Spectral Embedding - One of the accurate method for extraction of
meaningful patterns in high dimensional data.
It forms an affinity matrix given by the specified function and applies
spectral decomposition to the corresponding graph laplacian.
The resulting transformation is given by the value of the normalized
eigenvectors for each data point.
.SH SYNOPSIS
.IP
.nf
\f[C]
class frovedis.mllib.manifold.SpectralEmbedding(n_components=2, affinity=\[aq]nearest_neighbors\[aq],  
                                                gamma=1.0, random_state=None, eigen_solver=None,  
                                                n_neighbors=None, n_jobs=None, verbose=0,  
                                                norm_laplacian=True, mode=3, drop_first=True)  
\f[R]
.fi
.SS Public Member Functions
.PP
fit(X, y = None)
.PD 0
.P
.PD
load(fname, dtype = None)
.PD 0
.P
.PD
save(fname)
.PD 0
.P
.PD
get_params(deep = True)
.PD 0
.P
.PD
set_params(**params)
.PD 0
.P
.PD
debug_print()
.PD 0
.P
.PD
release()
.PD 0
.P
.PD
is_fitted()
.SH DESCRIPTION
.PP
Spectral embedding is particularly useful for reducing the
dimensionality of data that is expected to lie on a low-dimensional
manifold contained within a high-dimensional space.
It yields a low-dimensional representation of the data that best
preserves the structure of the original manifold in the sense that
points that are close to each other on the original manifold will also
be close after embedding.
At the same time, the embedding emphasizes clusters in the original
data.
.PP
This module provides a client-server implementation, where the client
application is a normal python program.
Frovedis is almost same as Scikit-learn manifold module providing
Spectral Embedding support, but it doesn\[cq]t have any dependency with
Scikit-learn.
It can be used simply even if the system doesn\[cq]t have Scikit-learn
installed.
Thus, in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.PP
Python side calls for Spectral Embedding on the frovedis server.
Once the training is completed with the input data at the frovedis
server, it returns an abstract model with a unique model ID to the
client python program.
.PP
When prediction-like request would be made on the trained model, the
python program will send the same request to the frovedis server.
After the request is served at the frovedis server, the output would be
sent back to the python client.
.SS Detailed Description
.SS 1. SpectralEmbedding()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]n_components\f[I]\f[R]: An integer parameter containing the
number of component count.
(Default: 2)
.PD 0
.P
.PD
\f[I]\f[BI]affinity\f[I]\f[R]: A string object parameter which specifies
how to construct the affinity matrix.
(Default: `nearest_neighbors')
.PD 0
.P
.PD
- \f[B]`nearest_neighbors'\f[R]: construct the affinity matrix by
computing a graph of nearest neighbors.
.PD 0
.P
.PD
- \f[B]`precomputed'\f[R]: interpret X as a precomputed affinity matrix,
where larger values indicate greater similarity between instances.
.PP
Only `nearest_neighbors' and `precomputed' are supported.
.PD 0
.P
.PD
\f[I]\f[BI]gamma\f[I]\f[R]: The double (float64) parameter required for
computing nearby relational meaningful eigenvalues.
(Default: 1.0)
.PD 0
.P
.PD
\f[I]\f[BI]random_state\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]eigen_solver\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]n_neighbors\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]n_jobs\f[I]\f[R]: An unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (for INFO mode and not specified explicitly).
But it can be set to 1 (for DEBUG mode) or 2 (for TRACE mode) for
getting training time logs from frovedis server.
.PD 0
.P
.PD
\f[I]\f[BI]norm_laplacian\f[I]\f[R]: A boolean parameter if set to True,
then computes the normalized Laplacian.
(Default: True)
.PD 0
.P
.PD
\f[I]\f[BI]mode\f[I]\f[R]: An integer parameter required to set the
eigen computation method.
It can be either 1 (for generic) or 3 (for shift-invert).
(Default: 3)
.PD 0
.P
.PD
\f[I]\f[BI]drop_first\f[I]\f[R]: A boolean parameter if set to True,
then drops the first eigenvector.
The first eigenvector of a normalized Laplacian is full of constants,
thus if it is set to true, then (n_components + 1) eigenvectors are
computed and will drop the first vector.
Otherwise, it will calculate `n_components' number of eigenvectors.
(Default: True)
.PP
\f[B]Attribute\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]affinity_matrix\f[I]\f[R]:
.IP "1." 3
\f[B]For python native dense input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `precomputed', it returns a numpy array
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `nearest_neighbors', it returns a numpy array
.RE
.IP "2." 3
\f[B]For frovedis-like dense input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `precomputed', returns a FrovedisRowmajorMatrix
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `nearest_neighbors', returns a FrovedisRowmajorMatrix
.RE
.IP "3." 3
\f[B]For python native sparse input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `precomputed', it returns a scipy matrix
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `nearest_neighbors', it returns a numpy array
.RE
.IP "4." 3
\f[B]For frovedis-like sparse input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `nearest_neighbors', it a returns a
FrovedisRowmajorMatrix
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `precomputed', it returns a FrovedisRowmajorMatrix
.RE
.PP
In all cases, the output is of float or double (float64) type and of
shape \f[B](n_samples, n_samples)\f[R].
.PP
\f[I]\f[BI]embedding_\f[I]\f[R]:
.IP "1." 3
\f[B]For python native dense input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `precomputed', it returns a numpy array
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `nearest_neighbors', it returns a numpy array
.RE
.IP "2." 3
\f[B]For frovedis-like dense input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `precomputed', returns a FrovedisRowmajorMatrix
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `nearest_neighbors', returns a FrovedisRowmajorMatrix
.RE
.IP "3." 3
\f[B]For python native sparse input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `precomputed', it returns a numpy array
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `nearest_neighbors', it returns a numpy array
.RE
.IP "4." 3
\f[B]For frovedis-like sparse input:\f[R]
.RS 4
.IP \[bu] 2
When affinity = `nearest_neighbors', it a returns a
FrovedisRowmajorMatrix
.PD 0
.P
.PD
.IP \[bu] 2
When affinity = `precomputed', it returns a FrovedisRowmajorMatrix
.RE
.PP
In all cases, the output is of float or double (float64) type and of
shape \f[B](n_samples, n_components)\f[R].
.PP
\f[B]Note: affinity = `precomputed' should be used with square matrix
input only, Otherwise, it throws an exception.\f[R]
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It initializes a Spectral Embedding object with the given parameters.
.PP
The parameters: `random_state', `eigen_solver', `n_neighbors' and
`n_jobs' are simply kept in to make the interface uniform to the
Scikit-learn Spectral Embedding module.
They are not used anywhere within frovedis implementation.
.PP
After getting the affinity matrix by computing distance co-relation,
this is used to extract meaningful patterns in high dimensional data.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 2. fit(X, y = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]X\f[I]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object or an instance of FrovedisCRSMatrix for sparse
data and FrovedisRowmajorMatrix for dense data of float or double
(float64) type.
It has shape \f[B](n_samples, n_features)\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]y\f[I]\f[R]: None or any python array-like object (any
shape).
It is simply ignored in frovedis implementation, like in Scikit-learn.
.PP
\f[B]Purpose\f[R]
.PP
It extracts meaningful or co-related patterns obtained from normalized
eigenvector computation.
.PP
For example,
.IP
.nf
\f[C]
# loading sample matrix data
train_mat = np.loadtxt(\[dq]spectral_data.txt\[dq])

# fitting input matrix on Spectral Embedding object
from frovedis.mllib.manifold import SpectralEmbedding
sem = SpectralEmbedding(n_components = 2, drop_first = True).fit(train_mat)  
\f[R]
.fi
.PP
When native python data is provided, it is converted to frovedis-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre-constructed frovedis-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
# loading sample matrix data
train_mat = np.loadtxt(\[dq]spectral_data.txt\[dq])

# Since \[dq]train_mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix.
# For scipy sparse data, FrovedisCRSMatrix should be used instead.   
from frovedis.matrix.dense import FrovedisRowmajorMatrix
rmat = FrovedisRowmajorMatrix(train_mat)

# fitting input matrix on Spectral Embedding object
from frovedis.mllib.manifold import SpectralEmbedding
sem = SpectralEmbedding(n_components = 2, drop_first = True).fit(rmat)  
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 3. load(fname, dtype = None)
.PP
\f[B]Parameters\f[R]
.PP
\f[I]\f[BI]fname\f[I]\f[R]: A string object containing the name of the
file having model information to be loaded.
.PD 0
.P
.PD
\f[I]\f[BI]dtype\f[I]\f[R]: A data-type is inferred from the input data.
Currently, expected input data-type is either float or double (float64).
(Default: None)
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It loads the model from the specified file(having little-endian binary
data).
.PP
For example,
.IP
.nf
\f[C]
# loading the same model
sem.load(\[dq]./out/MySemModel\[dq],dtype=np.float64)
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] instance.
.SS 4. save(fname)
.PP
\f[B]Parameters\f[R]
.PP
\f[I]\f[BI]fname\f[I]\f[R]: A string object containing the name of the
file on which the target model is to be saved.
.PP
\f[B]Purpose\f[R]
.PP
On success, it writes the model information(metadata and model) in the
specified file as little-endian binary data.
Otherwise, it throws an exception.
.PP
For example,
.IP
.nf
\f[C]
# saving the model
sem.save(\[dq]./out/MySemModel\[dq])
\f[R]
.fi
.PP
The MySemModel contains below directory structure:
.PD 0
.P
.PD
\f[B]MySemModel\f[R]
.PD 0
.P
.PD
|\[em]\[em]metadata
.PD 0
.P
.PD
|\[em]\[em]\f[B]model\f[R]
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ |\[em]\[em]aff_type
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ |\[em]\[em]\f[B]affinity\f[R]
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ |\[em]\[em]\f[B]embedding\f[R]
.PP
`metadata' represents the detail about n_components, model_kind and
datatype of training vector.
Here, the \f[B]model\f[R] directory contains information about type of
affinity matrix, affinity matrix and embedding matrix.
.PP
If the directory already exists with the same name then it will raise an
exception.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 5. get_params(deep = True)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]deep\f[I]\f[R]: A boolean parameter, used to get parameters
and their values for an estimator.
If True, will return the parameters for an estimator and contained
subobjects that are estimators.
(Default: True)
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by Spectral
Embedding.
It is used to get parameters and their values of Spectral Embedding
class.
.PP
For example,
.IP
.nf
\f[C]
print(sem.get_params())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
{\[aq]affinity\[aq]: \[aq]nearest_neighbors\[aq], \[aq]drop_first\[aq]: True, \[aq]eigen_solver\[aq]: None, \[aq]gamma\[aq]: 1.0, 
\[aq]mode\[aq]: 3, \[aq]n_components\[aq]: 2, \[aq]n_jobs\[aq]: None, \[aq]n_neighbors\[aq]: None, \[aq]norm_laplacian\[aq]: True, 
\[aq]random_state\[aq]: None, \[aq]verbose\[aq]: 0}
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
A dictionary of parameter names mapped to their values.
.SS 6. set_params(**params)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]**params\f[I]\f[R]: All the keyword arguments are passed this
function as dictionary.
This dictionary contains parameters of an estimator with its given
values to set.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by Spectral
Embedding, used to set parameter values.
.PP
For example,
.IP
.nf
\f[C]
print(\[dq]get parameters before setting:\[dq])
print(sem.get_params())
# User just needs to provide the arguments and internally it will create a 
dictionary over the arguments given by user
sem.set_params(n_components = 3, drop_first = False)
print(\[dq]get parameters after setting:\[dq])
print(sem.get_params())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
get parameters before setting: 
{\[aq]affinity\[aq]: \[aq]nearest_neighbors\[aq], \[aq]drop_first\[aq]: True, \[aq]eigen_solver\[aq]: None, 
\[aq]gamma\[aq]: 1.0, \[aq]mode\[aq]: 3, \[aq]n_components\[aq]: 2, \[aq]n_jobs\[aq]: None, \[aq]n_neighbors\[aq]: None, 
\[aq]norm_laplacian\[aq]: True, \[aq]random_state\[aq]: None, \[aq]verbose\[aq]: 0}
get parameters after setting: 
{\[aq]affinity\[aq]: \[aq]nearest_neighbors\[aq], \[aq]drop_first\[aq]: False, \[aq]eigen_solver\[aq]: None, 
\[aq]gamma\[aq]: 1.0, \[aq]mode\[aq]: 3, \[aq]n_components\[aq]: 3, \[aq]n_jobs\[aq]: None, \[aq]n_neighbors\[aq]: None, 
\[aq]norm_laplacian\[aq]: True, random_state\[aq]: None, \[aq]verbose\[aq]: 0}  
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 7. debug_print()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It shows the target model information (affinity and embed matrix) on the
server side user terminal.
It is mainly used for debugging purpose.
.PP
For example,
.IP
.nf
\f[C]
sem.debug_print()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
affinity matrix:
num_row = 5, num_col = 5
node 0
node = 0, local_num_row = 5, local_num_col = 5, val = 1 0.970446 6.2893e-104 2.92712e-106 
1.28299e-108 0.970446 1 1.27264e-101 6.2893e-104 2.92712e-106 6.2893e-104 1.27264e-101 
1 0.970446 0.88692 2.92712e-106 6.2893e-104 0.970446 1 0.970446 1.28299e-108 2.92712e-106 
0.88692 0.970446 1
embed matrix:
num_row = 5, num_col = 2
node 0
node = 0, local_num_row = 5, local_num_col = 2, val = -0.628988 -0.345834 -0.628988 
-0.345834 -0.202594 0.368471 -0.202594 0.368471 -0.202594 0.368471
\f[R]
.fi
.PP
This output will be visible on server side.
It displays the affinity matrix and embedding matrix on the trained
model which is currently present on the server.
.PP
\f[B]No such output will be visible on client side.\f[R]
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 8. release()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to release the in-memory model at frovedis server.
.PP
For example,
.IP
.nf
\f[C]
sem.release()
\f[R]
.fi
.PP
This will reset the after-fit populated attributes to None, along with
releasing server side memory.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 9. is_fitted()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to confirm if the model is already fitted or not.
In case, affinity_matrix is used before training the model, then it can
prompt the user to train the clustering model first.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns `True', if the model is already fitted otherwise, it returns
`False'.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Introduction to FrovedisRowmajorMatrix\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Introduction to FrovedisCRSMatrix\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Spectral Clustering in Frovedis\f[R]
