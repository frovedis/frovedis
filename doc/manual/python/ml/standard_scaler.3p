.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "StandardScaler" "" "" "" ""
.hy
.SH NAME
.PP
StandardScaler - It is a preprocessing technique which is used to
perform scaling of distribution values so that mean of observed values
is zero and the standard deviation is unit variance.
.SH SYNOPSIS
.IP
.nf
\f[C]
frovedis.mllib.preprocessing.StandardScaler(copy = True, with_mean= True, 
                                            with_std=True, sam_std = False, verbose=0)  
\f[R]
.fi
.SS Public Member Functions
.PP
fit(X, y = None, sample_weight = None)
.PD 0
.P
.PD
fit_transform(X, y = None)
.PD 0
.P
.PD
get_params(deep = True)
.PD 0
.P
.PD
inverse_transform(X, copy = None)
.PD 0
.P
.PD
is_fitted()
.PD 0
.P
.PD
partial_fit(X, y = None, sample_weight = None)
.PD 0
.P
.PD
release()
.PD 0
.P
.PD
set_params(**params)
.PD 0
.P
.PD
transform(X, copy = None)
.SH DESCRIPTION
.PP
This machine learning algorithm standardizes the features by removing
the mean and scaling to unit variance.
.PP
The standard score of a sample x is calculated as:
.IP
.nf
\f[C]
z = (x - u) / s
\f[R]
.fi
.PP
where,
.PD 0
.P
.PD
- u is the mean of the training samples or zero if with_mean = False.
.PD 0
.P
.PD
- s is the standard deviation of the training samples or one if with_std
= False.
.PP
Centering and scaling happens independently on each feature by computing
the relevant statistics on the samples in the training set.
Mean and standard deviation are then stored to be used later on during
\f[B]transform()\f[R].
.PP
\f[B]Currently, this class in frovedis will first create a copy of input
data and then will perform standard scaling.
It does not support inplace scaling yet.\f[R]
.PP
This module provides a client-server implementation, where the client
application is a normal python program.
The frovedis interface is almost same as Scikit-learn StandardScaler
interface, but it doesn\[cq]t have any dependency with Scikit-learn.
It can be used simply even if the system doesn\[cq]t have Scikit-learn
installed.
Thus in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.PP
Python side calls for StandardScaler on the frovedis server.
Once the training is completed with the input data at the frovedis
server, it returns an abstract model with a unique model ID to the
client python program.
.PP
When transform-like request would be made on the trained model, python
program will send the same request to the frovedis server.
After the request is served at the frovedis server, the output would be
sent back to the python client.
.SS Detailed Description
.SS 1. StandardScaler()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]copy\f[B]\f[R]: This is an unused parameter.
(Default: True)
.PD 0
.P
.PD
\f[B]\f[BI]with_mean\f[B]\f[R]: It is a boolean parameter that specifies
whether to perform centering before scaling of data.
(Default: True)
.PD 0
.P
.PD
When it is True (not specified explicitly), it will center the data
before scaling.
.PD 0
.P
.PD
\f[B]Note: Also, use `with_mean = False' when attempting centering on
sparse matrices.
Otherwise it raises an exception.\f[R]
.PD 0
.P
.PD
When it is set as None (specified explicitly), it will be set as False.
.PD 0
.P
.PD
\f[B]\f[BI]with_std\f[B]\f[R]: It is a boolean parameter that specifies
whether to scale the data to unit variance or not.
(Default: True)
.PD 0
.P
.PD
When it is True (not specified explicitly), it will scale the data to
unit variance.
.PD 0
.P
.PD
When it is set as None (specified explicitly), it will be set as False.
.PD 0
.P
.PD
\f[B]\f[BI]sam_std\f[B]\f[R]: It is a boolean parameter that specifies
whether to enable unbiased or biased sample standard deviation.
(Default: False)
.IP \[bu] 2
If it is False (not specified explicitly), it will compute biased
standard deviation (where \f[B]1 / n_samples\f[R] is used).
.PD 0
.P
.PD
.IP \[bu] 2
If it is True (specified explicitly), it will compute unbiased standard
deviation (where \f[B]1 / (`n_samples' - 1)\f[R] is used).
.PP
\f[B]\f[BI]verbose\f[B]\f[R]: An integer parameter specifying the log
level to use.
Its value is set as 0 by default (for INFO mode).
But it can be set to 1 (for DEBUG mode) or 2 (for TRACE mode) for
getting training time logs from frovedis server.
.PP
\f[B]Attributes\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]mean_\f[B]\f[R]: It is a numpy ndarray of shape
\f[B](n_features,)\f[R] and having double (float64) type values.
It specifies the mean value for each feature in the training set.
.PD 0
.P
.PD
\f[B]\f[BI]var_\f[B]\f[R]: It is a numpy ndarray of shape
\f[B](n_features,)\f[R] and having double (float64) type values.
It specifies the variance for each feature in the training set.
.PD 0
.P
.PD
\f[B]\f[BI]scale_\f[B]\f[R]: It is a numpy ndarray of shape
\f[B](n_features,)\f[R] and having double (float64) type values.
It specifies the per feature relative scaling of the data to achieve
zero mean and unit variance.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It initializes a StandardScaler object with the given parameters.
.PP
The parameters: \[lq]copy\[rq] is simply kept in to make the interface
uniform to the Scikit-learn StandardScaler module.
They are not used in frovedis implementation internally.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 2. fit(X, y = None, sample_weight = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object of int, float (float32) or double (float64)
type values.
It can also be an instance of FrovedisCRSMatrix for sparse data and
FrovedisRowmajorMatrix for dense data of float (float32) or double
(float64) type.
It has shape \f[B](n_samples, n_features)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]y\f[B]\f[R]: None or any python array-like object (any
shape).
It is simply ignored in frovedis implementation, like in Scikit-learn.
.PD 0
.P
.PD
\f[B]\f[BI]sample_weight\f[B]\f[R]: None or any python array-like object
(any shape).
It is simply ignored in frovedis implementation.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes the mean and standard deviation to be used for later
scaling.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])
            
# fitting input matrix on StandardScaler object  
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler().fit(mat)  
\f[R]
.fi
.PP
When native python data is provided, it is converted to frovedis-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre-constructed frovedis-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])

# Since \[dq]mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix.  
# For scipy sparse data, FrovedisCRSMatrix should be used instead.  
from frovedis.matrix.dense import FrovedisRowmajorMatrix  
rmat = FrovedisRowmajorMatrix(mat)  

# StandardScaler with pre-constructed frovedis-like inputs  
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler().fit(rmat)  
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 3. fit_transform(X, y = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object of int, float (float32) or double (float64)
type values.
It can also be an instance of FrovedisCRSMatrix for sparse data and
FrovedisRowmajorMatrix for dense data of float (float32) or double
(float64) type.
It has shape \f[B](n_samples, n_features)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]y\f[B]\f[R]: None or any python array-like object (any
shape).
It is simply ignored in frovedis implementation.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It will fit the model with input matrix (X) and then returns a
transformed version of input matrix (X).
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])

# fitting input matrix on StandardScaler object and perform transform 
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler()
print(ss.fit_transform(mat))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[[-1.23598774 -1.23598774 -1.23598774]
 [-1.21318353 -1.21318353 -1.21318353]
 [ 0.79358622  0.79358622  0.79358622]
 [ 0.81639042  0.81639042  0.81639042]
 [ 0.83919462  0.83919462  0.83919462]]    
\f[R]
.fi
.PP
When native python data is provided, it is converted to frovedis-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre-constructed frovedis-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])   

# Since \[dq]mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix.  
# For scipy sparse data, FrovedisCRSMatrix should be used instead.  
from frovedis.matrix.dense import FrovedisRowmajorMatrix  
rmat = FrovedisRowmajorMatrix(mat)  

# Fitting StandardScaler with pre-constructed frovedis-like inputs and perform transform  
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler()
print(ss.fit_transform(rmat)) 
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[[-1.23598774 -1.23598774 -1.23598774]
 [-1.21318353 -1.21318353 -1.21318353]
 [ 0.79358622  0.79358622  0.79358622]
 [ 0.81639042  0.81639042  0.81639042]
 [ 0.83919462  0.83919462  0.83919462]]    
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.IP \[bu] 2
\f[B]When dense data is used as input:\f[R]
.PD 0
.P
.PD
For both frovedis-like input and python input, it returns a numpy matrix
of shape \f[B](n_samples, n_features)\f[R] and double (float64) type
values.
It contains transformed values.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]When sparse data is used as input:\f[R]
.PD 0
.P
.PD
For both frovedis-like input and python input, it returns a scipy sparse
matrix of shape \f[B](n_samples, n_features)\f[R] and double (float64)
type values.
It contains transformed values.
.SS 4. get_params(deep = True)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]deep\f[I]\f[R]: A boolean parameter, used to get parameters
and their values for an estimator.
If True, it will return the parameters for an estimator and contained
subobjects that are estimators.
(Default: True)
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by
StandardScaler.
It is used to get parameters and their values of StandardScaler class.
.PP
For example,
.IP
.nf
\f[C]
print(ss.get_params())  
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
{\[aq]copy\[aq]: True, \[aq]sam_std\[aq]: False, \[aq]verbose\[aq]: 0, \[aq]with_mean\[aq]: True, \[aq]with_std\[aq]: True}
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
A dictionary of parameter names mapped to their values.
.SS 5. inverse_transform(X, copy = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object of int, float (float32) or double (float64)
type values.
It can also be an instance of FrovedisCRSMatrix for sparse data and
FrovedisRowmajorMatrix for dense data of float (float32) or double
(float64) type.
It has shape \f[B](n_samples, n_features)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]copy\f[B]\f[R]: This is an unsed parameter.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It scales back the data to the original representation.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])

# fitting input matrix on StandardScaler object and perform transform 
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler()
ss.fit(mat)
X1 = ss.transform(mat)

# inverse_transform() demo to get original input data
print(ss.inverse_transform(X1))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[[0.1 0.1 0.1]
 [0.2 0.2 0.2]
 [9.  9.  9. ]
 [9.1 9.1 9.1]
 [9.2 9.2 9.2]]
\f[R]
.fi
.PP
When native python data is provided, it is converted to frovedis-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre-constructed frovedis-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])   

# Since \[dq]mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix.  
# For scipy sparse data, FrovedisCRSMatrix should be used instead.  
from frovedis.matrix.dense import FrovedisRowmajorMatrix  
rmat = FrovedisRowmajorMatrix(mat)  

# StandardScaler with pre-constructed frovedis-like inputs and perform transform
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler()
ss.fit(rmat)
X1 = ss.transform(rmat)

# inverse_transform() demo to get original frovedis-like input data
print(ss.inverse_transform(X1))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[[0.1 0.1 0.1]
 [0.2 0.2 0.2]
 [9.  9.  9. ]
 [9.1 9.1 9.1]
 [9.2 9.2 9.2]]
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.IP \[bu] 2
\f[B]When dense data is used as input:\f[R]
.PD 0
.P
.PD
For both frovedis-like input and python input, it returns a numpy matrix
of shape \f[B](n_samples, n_features)\f[R] and double (float64) type
values.
It contains transformed values (original data).
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]When sparse data is used as input:\f[R]
.PD 0
.P
.PD
For both frovedis-like input and python input, it returns a scipy sparse
matrix of shape \f[B](n_samples, n_features)\f[R] and double (float64)
type values.
It contains transformed values (original data).
.SS 6. is_fitted()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to confirm if the model is already fitted or not.
In case, transform() is used before training the model, then it can
prompt the user to train the pca model first.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns `True', if the model is already fitted otherwise, it returns
`False'.
.SS 7. partial_fit(X, y = None, sample_weight = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object of int, float (float32) or double (float64)
type values.
It can also be an instance of FrovedisCRSMatrix for sparse data and
FrovedisRowmajorMatrix for dense data of float (float32) or double
(float64) type.
It has shape \f[B](n_samples, n_features)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]y\f[B]\f[R]: None or any python array-like object (any
shape).
It is simply ignored in frovedis implementation, like in Scikit-learn.
.PD 0
.P
.PD
\f[B]\f[BI]sample_weight\f[B]\f[R]: None or any python array-like object
(any shape).
It is simply ignored in frovedis implementation.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs incremental computation of mean and standard deviation on
each new batch of samples present in input matrix (X) and the finalised
mean and standard deviation computed is later used for scaling.
.PP
All of input matrix (X) is processed as a single batch.
This is intended for cases when fit is not feasible due to very large
number of `n_samples' or because input matrix (X) is read from a
continuous stream.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])
            
# partial_fit() demo with input matrix on StandardScaler object  
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler().partial_fit(mat)  
\f[R]
.fi
.PP
When native python data is provided, it is converted to frovedis-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre-constructed frovedis-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])

# Since \[dq]mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix.  
# For scipy sparse data, FrovedisCRSMatrix should be used instead.  
from frovedis.matrix.dense import FrovedisRowmajorMatrix  
rmat = FrovedisRowmajorMatrix(mat)  

# StandardScaler with pre-constructed frovedis-like inputs  
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler().partial_fit(rmat)  
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 8. release()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to release the in-memory model at frovedis server.
.PP
For example,
.IP
.nf
\f[C]
ss.release()
\f[R]
.fi
.PP
This will reset the after-fit populated attributes to None, along with
releasing server side memory.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 9. set_params(**params)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]**params\f[I]\f[R]: All the keyword arguments are passed to
this function as dictionary.
This dictionary contains parameters of an estimator with its given
values to set.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by
StandardScaler, used to set parameter values.
.PP
For example,
.IP
.nf
\f[C]
print(\[dq]get parameters before setting:\[dq]) 
print(ss.get_params())
# User just needs to provide the arguments and internally it will create a 
dictionary over the arguments given by user
ss.set_params(with_mean = False, sam_std = False, verbose = 1)  
print(\[dq]get parameters after setting:\[dq]) 
print(ss.get_params())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
get parameters before setting:
{\[aq]copy\[aq]: True, \[aq]sam_std\[aq]: False, \[aq]verbose\[aq]: 0, \[aq]with_mean\[aq]: True, \[aq]with_std\[aq]: True}
get parameters after setting:
{\[aq]copy\[aq]: True, \[aq]sam_std\[aq]: False, \[aq]verbose\[aq]: 1, \[aq]with_mean\[aq]: False, \[aq]with_std\[aq]: True}
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 10. transform(X, copy = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object of int, float (float32) or double (float64)
type values.
It can also be an instance of FrovedisCRSMatrix for sparse data and
FrovedisRowmajorMatrix for dense data of float (float32) or double
(float64) type.
It has shape \f[B](n_samples, n_features)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]copy\f[B]\f[R]: This is an unsed parameter.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs standardization by centering and scaling.
.PP
It will always perform transform on a copy of input matrix (X).
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])

# fitting input matrix on StandardScaler object and perform transform 
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler()
ss.fit(mat)
print(ss.transform(mat))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[[-1.23598774 -1.23598774 -1.23598774]
 [-1.21318353 -1.21318353 -1.21318353]
 [ 0.79358622  0.79358622  0.79358622]
 [ 0.81639042  0.81639042  0.81639042]
 [ 0.83919462  0.83919462  0.83919462]]  
\f[R]
.fi
.PP
When native python data is provided, it is converted to frovedis-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre-constructed frovedis-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
# loading a sample numpy dense data    
import numpy as np
mat = np.matrix([[0.1, 0.1, 0.1],
                 [0.2, 0.2, 0.2],
                 [9., 9., 9. ],
                 [9.1, 9.1, 9.1],
                 [9.2, 9.2, 9.2]])   

# Since \[dq]mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix.  
# For scipy sparse data, FrovedisCRSMatrix should be used instead.  
from frovedis.matrix.dense import FrovedisRowmajorMatrix  
rmat = FrovedisRowmajorMatrix(mat)  

# Fitting StandardScaler with pre-constructed frovedis-like inputs and perform transform  
from frovedis.mllib.preprocessing import StandardScaler
ss = StandardScaler()
ss.fit(rmat)
print(ss.transform(rmat)) 
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[[-1.23598774 -1.23598774 -1.23598774]
 [-1.21318353 -1.21318353 -1.21318353]
 [ 0.79358622  0.79358622  0.79358622]
 [ 0.81639042  0.81639042  0.81639042]
 [ 0.83919462  0.83919462  0.83919462]]  
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.IP \[bu] 2
\f[B]When dense data is used as input:\f[R]
.PD 0
.P
.PD
For both frovedis-like input and python input, it returns a numpy matrix
of shape \f[B](n_samples, n_features)\f[R] and double (float64) type
values.
It contains transformed values.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]When sparse data is used as input:\f[R]
.PD 0
.P
.PD
For both frovedis-like input and python input, it returns a scipy sparse
matrix of shape \f[B](n_samples, n_features)\f[R] and double (float64)
type values.
It contains transformed values.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Introduction to FrovedisRowmajorMatrix\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Introduction to FrovedisCRSMatrix\f[R]
