.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "Spectral Clustering" "" "" "" ""
.hy
.SH NAME
.PP
Spectral Clustering - A clustering algorithm commonly used in EDA
(exploratory data analysis).
It uses the spectrum (eigenvalues) of the similarity matrix of the data
to perform clustering.
.SH SYNOPSIS
.IP
.nf
\f[C]
class frovedis.mllib.cluster.SpectralClustering(n_clusters=8, eigen_solver=None, 
                                                n_components=None, random_state=None, 
                                                n_init=10, gamma=1.0, affinity=\[aq]rbf\[aq], 
                                                n_neighbors=10, eigen_tol=0.0,
                                                assign_labels=\[aq]kmeans\[aq], degree=3, coef0=1,
                                                kernel_params=None, n_jobs=None, verbose=0,
                                                max_iter=300, eps=1e-4, norm_laplacian=True,
                                                mode=3, drop_first=True)  
\f[R]
.fi
.SS Public Member Functions
.PP
fit(X, y = None)
.PD 0
.P
.PD
fit_predict(X, y = None)
.PD 0
.P
.PD
score(X, y, sample_weight = None)
.PD 0
.P
.PD
get_params(deep = True)
.PD 0
.P
.PD
set_params(**params)
.PD 0
.P
.PD
load(fname, dtype = None)
.PD 0
.P
.PD
save(fname)
.PD 0
.P
.PD
debug_print()
.PD 0
.P
.PD
release()
.PD 0
.P
.PD
is_fitted()
.SH DESCRIPTION
.PP
Clustering is an unsupervised learning problem where we aim to group
subsets of entities with one another based on some notion of similarity.
.PP
In Spectral Clustering, the data points are treated as nodes of a graph.
Thus, clustering is treated as a graph partitioning problem.
The nodes are then mapped to a low-dimensional space that can be easily
segregated to form clusters.
.PP
This module provides a client-server implementation, where the client
application is a normal python program.
The frovedis interface is almost same as Scikit-learn Spectral
Clustering interface, but it doesn\[cq]t have any dependency with
Scikit-learn.
It can be used simply even if the system doesn\[cq]t have Scikit-learn
installed.
Thus in this implementation, a python client can interact with a
frovedis server sending the required python data for training at
frovedis side.
Python data is converted into frovedis compatible data internally and
the python ML call is linked with the respective frovedis ML call to get
the job done at frovedis server.
.PP
Python side calls for Spectral Clustering on the frovedis server.
Once the training is completed with the input data at the frovedis
server, it returns an abstract model with a unique model ID to the
client python program.
.PP
When prediction-like request would be made on the trained model, python
program will send the same request to the frovedis server.
After the request is served at the frovedis server, the output would be
sent back to the python client.
.SS Detailed Description
.SS 1. SpectralClustering()
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]n_clusters\f[B]\f[R]: A positive integer parameter specifying
the number of clusters.
The number of clusters should be greater than 0 and less than or equal
to n_samples.
(Default: 8)
.PD 0
.P
.PD
\f[B]\f[BI]eigen_solver\f[B]\f[R]: A string object parameter.
It is the eigenvalue decomposition strategy to use.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as `arpack'.
Only `arpack' eigen solver is supported.
.PD 0
.P
.PD
\f[B]\f[BI]n_components\f[B]\f[R]: A positive integer parameter
containing the number of components for clusters.
It is used to compute the number of eigenvectors for spectral embedding.
The number of components should be in between 1 to n_features.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be equal to the
number of clusters.
.PD 0
.P
.PD
\f[B]\f[BI]random_state\f[B]\f[R]: Zero or positive integer parameter.
It is None by default.
.PD 0
.P
.PD
When it is None (not specified explicitly), it will be set as 0.
(unused)
.PD 0
.P
.PD
\f[B]\f[BI]n_init\f[B]\f[R]: A positive integer parameter that specifies
the number of times the k-means algorithm will be run with different
centroid seeds.
(Default: 10)
.PD 0
.P
.PD
\f[B]\f[BI]gamma\f[B]\f[R]: The double (float64) parameter required for
computing nearby relational meaningful eigenvalues.
(Default: 1.0)
.PD 0
.P
.PD
When it is None (specified explicitly), it will be set as 1.0.
.PD 0
.P
.PD
Kernel coefficient for rbf is \[lq][np.exp(-gamma * d(X,X) ** 2)]\[rq]
kernel.
Ignored for affinity=`nearest_neighbors'.
.PD 0
.P
.PD
\f[B]\f[BI]affinity\f[B]\f[R]: A string object parameter which tells how
to construct the affinity matrix.
(Default: `rbf')
.PD 0
.P
.PD
When it is None (specified explicitly), it will be set as `rbf'.
Only `rbf', `nearest_neighbors' and `precomputed' are supported.
.PD 0
.P
.PD
- \f[B]`nearest_neighbors'\f[R]: construct the affinity matrix by
computing a graph of nearest neighbors.
.PD 0
.P
.PD
- \f[B]`rbf'\f[R]: construct the affinity matrix using a radial basis
function (RBF) kernel.
.PD 0
.P
.PD
- \f[B]`precomputed'\f[R]: interpret X as a precomputed affinity matrix,
where larger values indicate greater similarity between instances.
.PP
\f[B]\f[BI]n_neighbors\f[B]\f[R]: A positive integer parameter that
specifies the number of neighbors to be used when constructing the
affinity matrix using the nearest neighbors method.
It must be in between 1 to n_samples.
It is applicable only when affinity = `nearest_neighbors'.
(Default: 10)
.PD 0
.P
.PD
\f[B]\f[BI]eigen_tol\f[B]\f[R]: Stopping criterion for eigen
decomposition of the Laplacian matrix when using `arpack' eigen_solver.
(unused)
.PD 0
.P
.PD
\f[B]\f[BI]assign_labels\f[B]\f[R]: A string object parameter that
specifies the strategy to use to assign labels in the embedding space.
When it is None (specified explicitly), it will be set as `kmeans'.
Only `kmeans' is supported.
(Default: `kmeans')
.PD 0
.P
.PD
\f[B]\f[BI]degree\f[B]\f[R]: Degree of the polynomial kernel.
(unused)
.PD 0
.P
.PD
\f[B]\f[BI]coef0\f[B]\f[R]: Zero coefficient for polynomial and sigmoid
kernels.
(unused)
.PD 0
.P
.PD
\f[B]\f[BI]kernel_params\f[B]\f[R]: Parameters (keyword arguments) and
values for kernel.
(unused)
.PD 0
.P
.PD
\f[B]\f[BI]n_jobs\f[B]\f[R]: The number of parallel jobs to run.
(unused)
.PD 0
.P
.PD
\f[B]\f[BI]verbose\f[B]\f[R]: An integer parameter specifying the log
level to use.
Its value is 0 by default (for INFO mode and not specified explicitly).
But it can be set to 1 (for DEBUG mode) or 2 (for TRACE mode) for
getting training time logs from frovedis server.
.PD 0
.P
.PD
\f[B]\f[BI]max_iter\f[B]\f[R]: A positive integer parameter containing
the maximum number of iteration count for kmeans assignment.
(Default: 300)
.PD 0
.P
.PD
\f[B]\f[BI]eps\f[B]\f[R]: Zero or a positive double parameter containing
the tolerance value for kmeans.
(Default: 1e-4)
.PD 0
.P
.PD
\f[B]\f[BI]norm_laplacian\f[B]\f[R]: A boolean parameter if set to True,
then compute normalized Laplacian, else not.
(Default: True)
.PD 0
.P
.PD
\f[B]\f[BI]mode\f[B]\f[R]: An integer parameter required to set the
eigen computation method.
It can be either 1 (for generic) or 3 (for shift-invert).
It is applicable only for dense data.
For more details refer ARPACK computation modes.
(Default: 3)
.PD 0
.P
.PD
\f[B]\f[BI]drop_first\f[B]\f[R]: A boolean parameter if set to True,
then drops the first eigenvector.
The first eigenvector of a normalized Laplacian is full of constants,
thus if it is set to True, then (n_components + 1) eigenvectors are
computed and will drop the first vector.
Otherwise, it will calculate `n_components' number of eigenvectors.
(Default: True)
.PP
\f[B]Attributes\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]affinity_matrix_\f[B]\f[R]:
.PD 0
.P
.PD
1.
\f[B]For python native dense input:\f[R]
.PD 0
.P
.PD
- When affinity = `precomputed/rbf', it returns a numpy array
.PD 0
.P
.PD
- When affinity = `nearest_neighbors', it returns a scipy matrix
.PD 0
.P
.PD
2.
\f[B]For frovedis-like dense input:\f[R]
.PD 0
.P
.PD
- When affinity = `precomputed/rbf', returns a FrovedisRowmajorMatrix
.PD 0
.P
.PD
- When affinity = `nearest_neighbors', returns a FrovedisCRSMatrix
.PD 0
.P
.PD
3.
\f[B]For python native sparse input:\f[R]
.PD 0
.P
.PD
- When affinity = `precomputed/nearest_neighbors', it returns a scipy
matrix
.PD 0
.P
.PD
- When affinity = `rbf', it returns a numpy array
.PD 0
.P
.PD
4.
\f[B]For frovedis-like sparse input:\f[R]
.PD 0
.P
.PD
- When affinity = `precomputed/nearest_neighbors', it a returns
FrovedisCRSMatrix
.PD 0
.P
.PD
- When affinity = `rbf', it returns a FrovedisRowmajorMatrix
.PP
In all cases, the output is of float or double (float64) type and of
shape \f[B](n_samples, n_samples)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]labels_\f[B]\f[R]: A python ndarray of int64 type values and
has shape \f[B](n_clusters,)\f[R].
It contains the predicted cluster labels for each point.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It initializes a Spectral Clustering object with the given parameters.
.PP
The parameters: \[lq]eigen_tol\[rq], \[lq]degree\[rq], \[lq]coef0\[rq],
\[lq]kernel_params\[rq] and \[lq]n_jobs\[rq], \[lq]random_state\[rq] are
simply kept in to make the interface uniform to the Scikit-learn
Spectral Clustering module.
They are not used anywhere within the frovedis implementation.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 2. fit(X, y = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object or an instance of FrovedisCRSMatrix for sparse
data and FrovedisRowmajorMatrix for dense data.
If affinity=\[lq]precomputed\[rq], it needs to be of shape
\f[B](n_samples, n_samples)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]y\f[B]\f[R]: None or any python array-like object (any
shape).
It is simply ignored in frovedis implementation, as in Scikit-learn as
well.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It clusters the given data points (X) into a predefined number of
clusters.
.PP
For example,
.IP
.nf
\f[C]
# loading sample matrix data
mat = np.loadtxt(\[dq]./input/spectral_data.txt\[dq])

# fitting input matrix on SpectralClustering object
from frovedis.mllib.cluster import SpectralClustering
spec = SpectralClustering(n_clusters = 2).fit(mat)   
\f[R]
.fi
.PP
When native python data is provided, it is converted to frovedis-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre-constructed frovedis-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
# loading sample matrix data
mat = np.loadtxt(\[dq]./input/spectral_data.txt\[dq])

# Since \[dq]mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix. 
# For scipy sparse data, FrovedisCRSMatrix should be used instead.
from frovedis.matrix.dense import FrovedisRowmajorMatrix
rmat = FrovedisRowmajorMatrix(mat)

# Spectral Clustering with pre-constructed frovedis-like inputs
from frovedis.mllib.cluster import SpectralClustering
spec = SpectralClustering(n_clusters = 2).fit(rmat)
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 3. fit_predict(X, y = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object or an instance of FrovedisCRSMatrix for sparse
data and FrovedisRowmajorMatrix for dense data.
If affinity=\[lq]precomputed\[rq], it needs to be of shape
\f[B](n_samples, n_samples)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]y\f[B]\f[R]: None or any python array-like object (any
shape).
It is simply ignored in frovedis implementation, as in Scikit-learn as
well.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It fits the given data points (X) and returns the predicted labels based
on cluster formed during the fit.
.PP
For example,
.IP
.nf
\f[C]
# loading sample matrix data
mat = np.loadtxt(\[dq]./input/spectral_data.txt\[dq])

# fitting input matrix on Spectral Clustering object
from frovedis.mllib.cluster import SpectralClustering
spec = SpectralClustering(n_clusters = 2)
print(spec.fit_predict(mat)) 
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[0 0 1 1 1]
\f[R]
.fi
.PP
It prints the predicted cluster labels after training is completed.
.PP
Like in fit(), we can also provide frovedis-like input in fit_predict()
for faster computation.
.PP
For example,
.IP
.nf
\f[C]
# loading sample matrix data
mat = np.loadtxt(\[dq]./input/sample_data.txt\[dq])

# Since \[dq]mat\[dq] is numpy dense data, we have created FrovedisRowmajorMatrix. 
# For scipy sparse data, FrovedisCRSMatrix should be used instead.
from frovedis.matrix.dense import FrovedisRowmajorMatrix
rmat = FrovedisRowmajorMatrix(mat)

# using pre-constructed input matrix
from frovedis.mllib.cluster import SpectralClustering
spec = SpectralClustering(n_clusters = 2)
print(spec.fit_predict(rmat))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[0 0 1 1 1]
\f[R]
.fi
.PP
It prints the predicted cluster labels after training is completed.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a numpy array of int32 type values containing the cluster
labels.
It has a shape \f[B](n_samples,)\f[R].
.SS 4. score(X, y, sample_weight = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]X\f[B]\f[R]: A numpy dense or scipy sparse matrix or any
python array-like object or an instance of FrovedisCRSMatrix for sparse
data and FrovedisRowmajorMatrix for dense data.
If affinity=\[lq]precomputed\[rq], it needs to be of shape
\f[B](n_samples, n_samples)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]y\f[B]\f[R]: A python ndarray or an instance of
FrovedisVector containing the true labels for X.
It has shape \f[B](n_samples,)\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]sample_weight\f[B]\f[R]: An unused parameter whose default
value is None.
It is simply ignored in frovedis implementation.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It uses homogeneity score on given true labels and predicted labels i.e
homogeneity score of self.predict(X, y) wrt.
y.
.PP
For example,
.IP
.nf
\f[C]
spec.score(train_mat, [0, 0, 1, 1, 1])  
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
1.0 
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a homogeneity score of float type.
.SS 5. get_params(deep = True)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]deep\f[I]\f[R]: A boolean parameter, used to get parameters
and their values for an estimator.
If True, it will return the parameters for an estimator and contained
subobjects that are estimators.
(Default: True)
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by
SpectralClustering.
It is used to get parameters and their values of SpectralClustering
class.
.PP
For example,
.IP
.nf
\f[C]
print(spec.get_params())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
{\[aq]affinity\[aq]: \[aq]rbf\[aq], \[aq]assign_labels\[aq]: \[aq]kmeans\[aq], \[aq]coef0\[aq]: 1, \[aq]degree\[aq]: 3, 
\[aq]drop_first\[aq]: True, \[aq]eigen_solver\[aq]: \[aq]arpack\[aq], \[aq]eigen_tol\[aq]: 0.0, \[aq]eps\[aq]: 0.0001, 
\[aq]gamma\[aq]: 1.0, \[aq]kernel_params\[aq]: None, \[aq]max_iter\[aq]: 300, \[aq]mode\[aq]: 3, \[aq]n_clusters\[aq]: 2, 
\[aq]n_components\[aq]: 2, \[aq]n_init\[aq]: 10, \[aq]n_jobs\[aq]: None, \[aq]n_neighbors\[aq]: 10, 
\[aq]norm_laplacian\[aq]: True, \[aq]random_state\[aq]: None, \[aq]verbose\[aq]: 0}
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
A dictionary of parameter names mapped to their values.
.SS 6. set_params(**params)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]**params\f[I]\f[R]: All the keyword arguments are passed to
this function as dictionary.
This dictionary contains parameters of an estimator with its given
values to set.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method belongs to the BaseEstimator class inherited by
SpectralClustering, used to set parameter values.
.PP
For example,
.IP
.nf
\f[C]
print(\[dq]get parameters before setting:\[dq]) 
print(spec.get_params())
# User just needs to provide the arguments and internally it will create a 
dictionary over the arguments given by user
spec.set_params(n_clusters = 3, affinity = \[aq]precomputed\[aq]) 
print(\[dq]get parameters after setting:\[dq]) 
print(spec.get_params())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
get parameters before setting:
{\[aq]affinity\[aq]: \[aq]rbf\[aq], \[aq]assign_labels\[aq]: \[aq]kmeans\[aq], \[aq]coef0\[aq]: 1, \[aq]degree\[aq]: 3, 
\[aq]drop_first\[aq]: True, \[aq]eigen_solver\[aq]: \[aq]arpack\[aq], \[aq]eigen_tol\[aq]: 0.0, \[aq]eps\[aq]: 0.0001, 
\[aq]gamma\[aq]: 1.0, \[aq]kernel_params\[aq]: None, \[aq]max_iter\[aq]: 300, \[aq]mode\[aq]: 3, \[aq]n_clusters\[aq]: 2, 
\[aq]n_components\[aq]: 2, \[aq]n_init\[aq]: 10, \[aq]n_jobs\[aq]: None, \[aq]n_neighbors\[aq]: 10, 
\[aq]norm_laplacian\[aq]: True, \[aq]random_state\[aq]: None, \[aq]verbose\[aq]: 0}
get parameters after setting:
{\[aq]affinity\[aq]: \[aq]precomputed\[aq], \[aq]assign_labels\[aq]: \[aq]kmeans\[aq], \[aq]coef0\[aq]: 1, \[aq]degree\[aq]: 3, 
\[aq]drop_first\[aq]: True, \[aq]eigen_solver\[aq]: \[aq]arpack\[aq], \[aq]eigen_tol\[aq]: 0.0, \[aq]eps\[aq]: 0.0001, 
\[aq]gamma\[aq]: 1.0, \[aq]kernel_params\[aq]: None, \[aq]max_iter\[aq]: 300, \[aq]mode\[aq]: 3, \[aq]n_clusters\[aq]: 3, 
\[aq]n_components\[aq]: 2, \[aq]n_init\[aq]: 10, \[aq]n_jobs\[aq]: None, \[aq]n_neighbors\[aq]: 10, 
\[aq]norm_laplacian\[aq]: True, \[aq]random_state\[aq]: None, \[aq]verbose\[aq]: 0}
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 7. load(fname, dtype = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]fname\f[B]\f[R]: A string object containing the name of the
file having model information to be loaded.
.PD 0
.P
.PD
\f[B]\f[BI]dtype\f[B]\f[R]: A data-type is inferred from the input data.
Currently, expected input data-type is either float or double (float64).
(Default: None)
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It loads a spectral clustering model stored previously from the
specified file (having little-endian binary data).
.PP
For example,
.IP
.nf
\f[C]
spec.load(\[dq]./out/MySpecClusteringModel\[dq], dtype = np.float64)
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It simply returns \[lq]self\[rq] reference.
.SS 8. save(fname)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]fname\f[B]\f[R]: A string object containing the name of the
file on which the target model is to be saved.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
On success, it writes the model information (metadata and model) in the
specified file as little-endian binary data.
Otherwise, it throws an exception.
.PP
For example,
.IP
.nf
\f[C]
# To save the spectral clustering model
spec.save(\[dq]./out/MySpecClusteringModel\[dq])  
\f[R]
.fi
.PP
This will save the spectral clustering model on the path
\[lq]/out/MySpecClusteringModel\[rq].
.PD 0
.P
.PD
It would raise exception if the directory already exists with same name.
.PP
The `MySpecClusteringModel' directory has
.PP
\f[B]MySpecClusteringModel\f[R]
.PD 0
.P
.PD
|\[em]\[en]metadata
.PD 0
.P
.PD
|\[em]\[en]\f[B]model\f[R]
.PD 0
.P
.PD
\ \ \ \ \ \ |\[em]\[em]\[en] aff_type
.PD 0
.P
.PD
\ \ \ \ \ \ |\[em]\[em]\[en] \f[B]affinity\f[R]
.PD 0
.P
.PD
\ \ \ \ \ \ |\[em]\[em]\[en] cluster_size
.PD 0
.P
.PD
\ \ \ \ \ \ |\[em]\[em]\[en] label
.PP
The metadata file contains the number of clusters, number of components,
model kind, input datatype used for trained model.
.PD 0
.P
.PD
Here, the \f[B]model\f[R] directory contains information about affinity
type, labels, cluster size and \f[B]affinity\f[R] matrix (sparse or
dense, depending upon python/frovedis input and affinity is `rbf',
`precomputed' or `nearest_neighbors').
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 9. debug_print()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It shows the target model information (affinity matrix) on the server
side user terminal.
It is mainly used for debugging purpose.
.PP
For example,
.IP
.nf
\f[C]
spec.debug_print() 
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
affinity matrix:
num_row = 5, num_col = 5
node 0
node = 0, local_num_row = 5, local_num_col = 5, val = 1 0.970446 6.2893e-104 2.92712e-106 
1.28299e-108 0.970446 1 1.27264e-101 6.2893e-104 2.92712e-106 6.2893e-104 1.27264e-101 1 
0.970446 0.88692 2.92712e-106 6.2893e-104 0.970446 1 0.970446 1.28299e-108 2.92712e-106 
0.88692 0.970446 1
labels:
0 0 1 1 1
ncluster: 2
\f[R]
.fi
.PP
This output will be visible on server side.
It dispays the affinity matrix.
.PP
\f[B]No such output will be visible on client side.\f[R]
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 10. release()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to release the in-memory model at frovedis server.
.PP
For example,
.IP
.nf
\f[C]
spec.release()
\f[R]
.fi
.PP
This will reset the after-fit populated attributes to None, along with
releasing server side memory.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 11. is_fitted()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It can be used to confirm if the model is already fitted or not.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns `True', if the model is already fitted otherwise, it returns
`False'.
.SH SEE ALSO
.IP \[bu] 2
\f[B]Introduction to FrovedisRowmajorMatrix\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Introduction to FrovedisCRSMatrix\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Agglomerative Clustering in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DBSCAN in Frovedis\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]KMeans in Frovedis\f[R]
