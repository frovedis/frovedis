.TH "Matrix Factorization using ALS" "" "" "" ""
.SH NAME
.PP
Matrix Factorization using Alternating Least Square (ALS) \- is a matrix
factorization algorithm commonly used for recommender systems.
.SH SYNOPSIS
.IP
.nf
\f[C]
class\ frovedis.mllib.recommendation.ALS(rank=None,\ max_iter=100,\ alpha=0.01,\ \ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ reg_param=0.01,\ similarity_factor=0.1,\ \ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ seed=0,\ verbose=0)\ \ \ \ \ 
\f[]
.fi
.SS Public Member Functions
.PP
fit(X)
.PD 0
.P
.PD
predict(ids)
.PD 0
.P
.PD
recommend_users(pid, k)
.PD 0
.P
.PD
recommend_products(uid, k)
.PD 0
.P
.PD
load(fname, dtype = None)
.PD 0
.P
.PD
save(fname)
.PD 0
.P
.PD
debug_print()
.PD 0
.P
.PD
release()
.PD 0
.P
.PD
is_fitted()
.SH DESCRIPTION
.PP
Collaborative filtering is commonly used for recommender systems.
These techniques aim to fill in the missing entries of a user\-item
association matrix.
Frovedis currently supports model\-based collaborative filtering, in
which users and products are described by a small set of latent factors
that can be used to predict missing entries.
.PP
Frovedis uses the alternating least squares(ALS) algorithm to learn
these latent factors.
The algorithm is based on a paper “Collaborative Filtering for Implicit
Feedback Datasets” by Hu, et al.
.PP
This module provides a client\-server implementation, where the client
application is a normal python program.
Scikit\-learn does not have any collaborative filtering recommender
algorithms like ALS.
In this implementation, python side recommender interfaces are provided,
where a python client can interact with a frovedis server sending the
required python data for training at frovedis side.
Python data is converted into frovedis compatible data internally and
the python ALS call is linked with the frovedis ALS call to get the job
done at frovedis server.
.PP
Python side calls for ALS on the frovedis server.
Once the training is completed with the input data at the frovedis
server, it returns an abstract model with a unique model ID to the
client python program.
.PP
When recommendation\-like request would be made on the trained model,
python program will send the same request to the frovedis server.
After the request is served at the frovedis server, the output would be
sent back to the python client.
.SS Detailed Description
.SS 1. ALS()
.PP
\f[I]\f[B]rank\f[]\f[]: A positive integer parameter containing the user
given rank for the input matrix.
(Default: None)
.PD 0
.P
.PD
When rank is None (not specified explicitly), it will be the
minimum(256, min(M,N)), where M is number of users and N is number of
items in input data.
It must be within the range of 0 to max(M, N).
.PD 0
.P
.PD
\f[I]\f[B]max_iter\f[]\f[]: A positive integer specifying maximum
iteration count.
(Default: 100)
.PD 0
.P
.PD
\f[I]\f[B]alpha\f[]\f[]: A positive double(float64) parameter containing
the learning rate.
(Default: 0.01)
.PD 0
.P
.PD
\f[I]\f[B]reg_param\f[]\f[]: A positive double(float64) parameter, also
called as the regularization parameter.
(Default: 0.01)
.PD 0
.P
.PD
\f[I]\f[B]similarity_factor\f[]\f[]: A double(float64) parameter, which
helps to identify whether the algorithm will optimize the computation
for similar user/item or not.
If similarity percentage of user or item features is more than or equal
to the given similarity_factor, the algorithm will optimize the
computation for similar user/item.
Otherwise, each user and item feature will be treated uniquely.
Similarity factor must be in range of >= 0.0 to <= 1.0.
(Default: 0.1)
.PD 0
.P
.PD
\f[I]\f[B]seed\f[]\f[]: An int64 parameter containing the seed value to
initialize the model structures with random values.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[B]verbose\f[]\f[]: An integer parameter specifying the log level
to use.
Its value is 0 by default (for INFO mode and not speicifed explicitly).
But it can be set to 1 (for DEBUG mode) or 2 (for TRACE mode) for
getting training time logs from frovedis server.
.PP
\f[B]Purpose\f[]
.PP
It initializes an ALS object with the given parameters.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It simply returns "self" reference.
.SS 2. fit(X)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]X\f[]\f[]: A scipy sparse matrix or any python array\-like
object or an instance of FrovedisCRSMatrix.
It has shape \f[B](n_samples, n_features)\f[].
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It accepts the training sparse matrix (X) and trains a matrix
factorization model on that at frovedis server.
.PP
It starts with initializing the model structures of the size MxF and NxF
(where M is the number of users, N is the products in the given rating
matrix and F is the given rank) with random values and keeps updating
them until maximum iteration count is reached.
.PP
For example,
.IP
.nf
\f[C]
#\ creating\ csr\ matrix\ 
import\ numpy\ as\ np
from\ scipy.sparse\ import\ csr_matrix\ 
row\ =\ np.array([0,\ 0,\ 1,\ 2,\ 2,\ 3,\ 3,\ 3,\ 4,\ 4,\ 5,\ 6,\ 6,\ 7,\ 7,\ 7])
col\ =\ np.array([0,\ 4,\ 0,\ 2,\ 3,\ 0,\ 1,\ 6,\ 0,\ 4,\ 0,\ 2,\ 3,\ 0,\ 1,\ 6])
data\ =\ np.array([2.0,\ 9.0,\ 1.0,\ 4.0,\ 8.0,\ 2.0,\ 3.0,\ 8.9,\ 2.0,\ 
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 9.0,\ 1.0,\ 4.0,\ 8.0,\ 2.0,3.0,\ 8.9])
csr_matrix\ =\ csr_matrix((data,\ (row,\ col)),\ shape\ =\ (8,\ 7))
\ \ \ \ 
#\ fitting\ input\ matrix\ on\ ALS\ object
from\ frovedis.mllib.recommendation\ import\ ALS
als\ =\ ALS(rank\ =\ 4).fit(csr_matrix)
\f[]
.fi
.PP
When native python data is provided, it is converted to frovedis\-like
inputs and sent to frovedis server which consumes some data transfer
time.
Pre\-constructed frovedis\-like inputs can be used to speed up the
training time, especially when same data would be used for multiple
executions.
.PP
For example,
.IP
.nf
\f[C]
#\ Since\ "mat"\ is\ scipy\ csr\ sparse\ matrix,\ we\ have\ created\ FrovedisCRSMatrix.
from\ frovedis.matrix.crs\ import\ FrovedisCRSMatrix
crs_mat\ =\ FrovedisCRSMatrix(mat)\ \ 

#\ ALS\ with\ pre\-constructed\ frovedis\-like\ inputs
from\ frovedis.mllib.recommendation\ import\ ALS
als\ =\ ALS(rank\ =\ 4).fit(crs_mat)\ \ 
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It simply returns "self" reference.
.SS 3. predict(ids)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]ids\f[]\f[]: A python tuple or list object containing the
pairs of user id and product id to predict.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It accepts a list of pair of user ids and product ids (0\-based Id) in
order to make prediction for their ratings from the trained model at
frovedis server.
.PP
For example,
.IP
.nf
\f[C]
#\ prints\ the\ predicted\ ratings\ for\ the\ given\ list\ of\ id\ pairs
als.predict([(1,1),(0,1),(2,3),(3,1)])\ \ \ 
\f[]
.fi
.PP
Output:
.IP
.nf
\f[C]
[\ 0.00224735\ \ 0.00152505\ \ 0.99515575\ \ 0.99588757]
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a numpy array containing the predicted ratings, of float or
double (float64) type depending upon the input type.
.SS 4. recommend_users(pid, k)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]pid\f[]\f[]: An integer parameter specifying the product ID
(0\-based Id) for which to recommend users.
.PD 0
.P
.PD
\f[I]\f[B]k\f[]\f[]: An integer parameter specifying the number of users
to be recommended.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It recommends the best "k" users with highest rating confidence in
sorted order for the given product.
.PP
If k > number of rows (number of users in the given matrix when training
the model), then it resets the k as "number of rows in the given
matrix".
This is done in order to recommend all the users with rating confidence
values in descending order.
.PP
For example,
.IP
.nf
\f[C]
#\ recommend\ 2\ users\ for\ second\ product
als.recommend_users(1,2)
\f[]
.fi
.PP
Output:
.IP
.nf
\f[C]
(\[aq]uids:\[aq],\ array([7,\ 3],\ dtype=int32))
(\[aq]scores:\[aq],\ array([\ 0.99588757,\ \ 0.99588757]))
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a python list containing the pairs of recommended users and
their corresponding rating confidence values (double (float64)) in
descending order.
.SS 5. recommend_products(uid, k)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]uid\f[]\f[]: An integer parameter specifying the user ID
(0\-based Id) for which to recommend products.
.PD 0
.P
.PD
\f[I]\f[B]k\f[]\f[]: An integer parameter specifying the number of
products to be recommended.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It recommends the best "k" products with highest rating confidence in
sorted order for the given user.
.PP
If k > number of columns (number of products in the given matrix when
training the model), then it resets the k as "number of columns in the
given matrix".
This is done in order to recommend all the products with rating
confidence values in descending order.
.PP
For example,
.IP
.nf
\f[C]
#\ recommend\ 2\ products\ for\ second\ user
print\ als.recommend_products(1,2)
\f[]
.fi
.PP
Output:
.IP
.nf
\f[C]
(\[aq]\ recommend_product\ \ pids:\[aq],\ array([0,\ 4],\ dtype=int32))
(\[aq]scores:\[aq],\ array([\ 0.99494576,\ \ 0.0030741\ ]))[(0,\ 0.9949457612078868),\ (4,\ 0.0030740973144160397)]
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a python list containing the pairs of recommended products
and their corresponding rating confidence values (double (float64)) in
descending order.
.SS 6. save(fname)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]fname\f[]\f[]: A string object containing the name of the file
on which the target model is to be saved.
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
On success, it writes the model information(metadata and model) in the
specified file as little\-endian binary data.
Otherwise, it throws an exception.
.PP
For example,
.IP
.nf
\f[C]
#\ saving\ the\ model
als.save("./out/MyALSModel")
\f[]
.fi
.PP
The MyALSModel contains below directory structure:
.PD 0
.P
.PD
\f[B]MyALSModel\f[]
.PD 0
.P
.PD
|\-\-\-\-\-\-metadata
.PD 0
.P
.PD
|\-\-\-\-\-\-\f[B]model\f[]
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ |\-\-\-\-\-\-\f[B]X\f[]
.PD 0
.P
.PD
\ \ \ \ \ \ \ \ |\-\-\-\-\-\-\f[B]Y\f[]
.PP
\[aq]metadata\[aq] represents the detail about model_kind and datatype
of training vector.
Here, the \f[B]model\f[] directory contains information about user and
product features.
.PP
If the directory already exists with the same name then it will raise an
exception.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns nothing.
.SS 7. load(fname, dtype = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[I]\f[B]fname\f[]\f[]: A string object containing the name of the file
having model information to be loaded.
.PD 0
.P
.PD
\f[I]\f[B]dtype\f[]\f[]: A data\-type is inferred from the input data.
Currently, expected input data\-type is either float or double
(float64).
(Default: None)
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It loads the model from the specified file(having little\-endian binary
data).
.PP
For example,
.IP
.nf
\f[C]
#\ loading\ the\ same\ model
als.load("./out/MyALSModel")
\f[]
.fi
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It simply returns "self" instance.
.SS 8. debug_print()
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It shows the target model information on the server side user terminal.
It is mainly used for debugging purpose.
.PP
For example,
.IP
.nf
\f[C]
als.debug_print()
\f[]
.fi
.PP
Output:
.IP
.nf
\f[C]
\ ==========\ Matrix::X\ ==========
\ 0.829524\ \-0.84477\ \-0.152624\ 0.569863
\ 0.829528\ \-0.844775\ \-0.152625\ 0.569867
\ 0.829921\ \-0.845174\ \-0.152697\ 0.570136
==========\ Matrix::Y\ ==========
\ 0.473117\ \-0.481813\ \-0.087049\ 0.32502
\ 0.473117\ \-0.481813\ \-0.087049\ 0.32502
\ 0.473117\ \-0.481813\ \-0.087049\ 0.32502
\ 
\f[]
.fi
.PP
This output will be visible on server side.
It will print the matrix and labels of training data.
.PP
\f[B]No such output will be visible on client side.\f[]
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns nothing.
.SS 9. release()
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It can be used to release the in\-memory model at frovedis server.
.PP
For example,
.IP
.nf
\f[C]
als.release()
\f[]
.fi
.PP
This will reset the after\-fit populated attributes to None, along with
releasing server side memory.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns nothing.
.SS 10. is_fitted()
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It can be used to confirm if the model is already fitted or not.
In case, predict() is used before training the model, then it can prompt
the user to train the model first.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns \[aq]True\[aq], if the model is already fitted otherwise, it
returns \[aq]False\[aq].
.SH SEE ALSO
.PP
crs_matrix
