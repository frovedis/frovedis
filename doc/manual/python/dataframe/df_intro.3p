.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "DataFrame Introduction" "" "" "" ""
.hy
.SH NAME
.PP
DataFrame - here refers to a Frovedis dataframe.
It is a two-dimensional, size-mutable, potentially heterogeneous tabular
data structure.
.SH DESCRIPTION
.PP
Dataframe is a two-dimensional data structure, i.e., data is aligned in
a tabular fashion in rows and columns.
This data structure also contains labeled axes (rows and columns).
Arithmetic operations align on both row and column labels.
It can be thought of as a dict-like container for Series objects or it
can be thought of as an SQL table or a spreadsheet data representation.
.PP
Features of DataFrame:
.PD 0
.P
.PD
- Columns can be of different types.
.PD 0
.P
.PD
- DataFrame is mutable i.e.\ the number of rows and columns can be
increased or decreased.
.PD 0
.P
.PD
- DataFrame supports indexing and labeled columns name.
.PD 0
.P
.PD
- Supports arithmetic operations on rows and columns.
.PP
Frovedis contains dataframe implementation over a client server
architecture (which uses Vector Engine on server side to perform fast
computations) where pandas dataframe will be converted to frovedis
dataframe and then will be used to perform dataframe related operations.
.PP
\f[B]In frovedis, currently dataframe can only support atomic data
i.e.\ a column in a frovedis dataframe can only have primitve type
values such as string, integer, float, double, boolean).\f[R]
.SS Detailed description
.SS 1. Creating frovedis DataFrame instance
.PP
\f[B]a) Using DataFrame constructor\f[R]
.PP
\f[B]DataFrame(df = None)\f[R]
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]df\f[B]\f[R]: A pandas DataFrame instance or pandas Series
instance.
(Default: None)
.PD 0
.P
.PD
When this parameter is not None (specified explicitly), it will load the
pandas dataframe (or series) to perform conversion into frovedis
dataframe.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It is used to create a Frovedis dataframe from the given pandas
dataframe or series.
.PP
For example,
.IP
.nf
\f[C]
# a pandas dictionary having key and values pairs
peopleDF = {
            \[aq]Ename\[aq] : [\[aq]Michael\[aq], \[aq]Andy\[aq], \[aq]Tanaka\[aq], \[aq]Raul\[aq], \[aq]Yuta\[aq]], 
            \[aq]Age\[aq] : [29, 30, 27, 19, 31],
            \[aq]Country\[aq] : [\[aq]USA\[aq], \[aq]England\[aq], \[aq]Japan\[aq], \[aq]France\[aq], \[aq]Japan\[aq]],
            \[aq]isMale\[aq]: [False, False, False, False, True]
           }

# creating a pandas dataframe from key value pair
pdf1 = pd.DataFrame(peopleDF)

# creating frovedis dataframe
fdf1 = fd.DataFrame(pdf1) 

# display created frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Age     Country Ename   isMale  
0       29      USA     Michael 0  
1       30      England Andy    0  
2       27      Japan   Tanaka  0  
3       19      France  Raul    0  
4       31      Japan   Yuta    1  
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns self reference.
.PP
\f[B]Attributes\f[R]
.PP
\f[B]\f[BI]columns\f[B]\f[R]: It returns a list of string having the
column labels of the frovedis dataframe.
.PP
For example,
.IP
.nf
\f[C]
# fdf1 is same from above example
print(fdf1.columns)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[\[aq]Age\[aq], \[aq]Country\[aq], \[aq]Ename\[aq], \[aq]isMale\[aq]]
\f[R]
.fi
.PP
\f[B]\f[BI]count\f[B]\f[R]: It returns an integer value having the
number of rows in the frovedis dataframe
.PP
For example,
.IP
.nf
\f[C]
# fdf1 is same from above example
print(fdf1.count)  
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
5  
\f[R]
.fi
.PP
\f[B]\f[BI]dtypes\f[B]\f[R]: It returns the dtypes of all columns in the
frovedis dataFrame.
It returns a Series object with the data type of each column.
.PP
For example,
.IP
.nf
\f[C]
# fdf1 is same from above example
print(fdf1.dtypes)  
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Age         int64
Country    object
Ename      object
isMale       bool
dtype: object
\f[R]
.fi
.PP
\f[B]\f[BI]ndim\f[B]\f[R]: It returns an integer representing the number
of axes / array dimensions.
.PP
For example,
.IP
.nf
\f[C]
# fdf1 is same from above example
print(fdf1.ndim)  
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
2  
\f[R]
.fi
.PP
\f[B]\f[BI]shape\f[B]\f[R]: It returns a tuple representing the
dimensions of the frovedis dataframe in form: \f[B](nrows, ncols)\f[R]
.PP
For example,
.IP
.nf
\f[C]
# fdf1 is same from above example
print(fdf1.shape)  
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
(5, 4)  
\f[R]
.fi
.PP
\f[B]\f[BI]values\f[B]\f[R]: It returns a numpy representation of the
frovedis dataframe.
.PP
For example,
.IP
.nf
\f[C]
# fdf1 is same from above example 
print(fdf1.values)  
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
[[\[aq]Michael\[aq] \[aq]29\[aq] \[aq]USA\[aq] \[aq]0\[aq]]
[\[aq]Andy\[aq] \[aq]30\[aq] \[aq]England\[aq] \[aq]0\[aq]]
[\[aq]Tanaka\[aq] \[aq]27\[aq] \[aq]Japan\[aq] \[aq]0\[aq]]
[\[aq]Raul\[aq] \[aq]19\[aq] \[aq]France\[aq] \[aq]0\[aq]]
[\[aq]Yuta\[aq] \[aq]31\[aq] \[aq]Japan\[aq] \[aq]1\[aq]]]   
\f[R]
.fi
.PP
\f[B]b) By loading data using read_csv() method\f[R]
.PP
\f[B]read_csv(filepath_or_buffer, sep = `,', delimiter = None, header =
\[lq]infer\[rq], names = None, index_col = None, usecols = None, squeeze
= False, prefix = None, mangle_dupe_cols = True, dtype = None, na_values
= None, verbose = False, comment = None, low_memory = True, rows_to_see
= 1024, separate_mb = 1024)\f[R]
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]filepath_or_buffer\f[I]\f[R]: It accepts any valid string
value that contains the name of the file to access as parameter.
The string path can be a URL as well.
In case, a file is to be read, then the pathname can be absolute path or
relative path to the current working directory of the file to be opened.
.PD 0
.P
.PD
Also, like pandas, it accepts os.PathLike instance for storing file path
name as well.
.PD 0
.P
.PD
\f[I]\f[BI]sep\f[I]\f[R]: It accepts string value as paramter that
specifies delimiter to use.
(Default: `,')
.PD 0
.P
.PD
\f[B]Currently, it supports only single character delimiter.\f[R]
.PD 0
.P
.PD
When it is None (if specified explicitly), it will use `,' as delimiter.
.PD 0
.P
.PD
\f[I]\f[BI]delimiter\f[I]\f[R]: It accepts string value as paramter.
It is an alias for `sep' parameter.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will set `,' as the
delimiter.
.PP
\f[I]\f[BI]header\f[I]\f[R]: It accepts integer or string value that
specifies the row number(s) to use as the column names, and the start of
the data.
(Default: `infer')
.PD 0
.P
.PD
\f[B]Currently, frovedis supports only `infer', 0 or None as values for
this parameter.\f[R]
.PD 0
.P
.PD
The default behavior is to \f[B]`infer'\f[R] the column names:
.PD 0
.P
.PD
- \f[B]If no column names are passed\f[R], then the behavior is
identical to \f[B]header = 0\f[R] and column names are inferred from the
first line of the file.
.PD 0
.P
.PD
- \f[B]If column names are passed explicitly\f[R], then the behavior is
identical to \f[B]header = None\f[R] and column names are inferred from
the explicitly specified list.
.PP
\f[I]\f[BI]names\f[I]\f[R]: It accepts array like input as parameter
that specifies the list of column names to use.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will get the column names
from the first line of the file.
Otherwise, it will override with the given list of column names.
Since, \f[B]header = 0 or None is only supported in frovedis\f[R], the
first line of the file will be used as column names.
\f[B]Duplicates in this list of column names are not allowed.\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]index_col\f[I]\f[R]: It accepts boolean and integer type
values as parameter.
It specifies the column(s) to use as the row labels of the frovedis
dataframe.
(Default: None)
.PD 0
.P
.PD
- If boolean type value is passed, then currently it can only be set as
False.
Also, when \f[B]index_col = False\f[R], it can be used to force to not
use the first column as the index.
\f[B]Also, `names' parameter must be provided\f[R].
.PD 0
.P
.PD
- It integer type value is passed, then it must be in the range \f[B](0,
nCols - 1)\f[R], where \f[B]nCols\f[R] is the number of columns present
in the input file.
.PD 0
.P
.PD
\f[B]Currently, multi-index is not supported in frovedis.\f[R]
.PD 0
.P
.PD
\f[I]\f[BI]usecols\f[I]\f[R]: It accepts currently a list-like input of
integer values as parameter.
It specifies the subset of the columns to be used while loading data
into frovedis dataframe.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will use all columns
while creating frovedis dataframe.
.PD 0
.P
.PD
Also, if the column names are provided and do not match the number of
columns in the input file, then the list of names must be same in length
as the list of `usecols' parameter values.
Otherwise, it raises an exception.
.PD 0
.P
.PD
\f[I]\f[BI]squeeze\f[I]\f[R]: An unused parameter.
(Default: False)
.PD 0
.P
.PD
\f[I]\f[BI]prefix\f[I]\f[R]: It accepts a string value as parameter.
It specifies the prefix which needs to be added to the column numbers.
(Default: None)
.PD 0
.P
.PD
For example, `X' for X0, X1, X2, \&...
.PD 0
.P
.PD
\f[B]This is an optional paramter which will be used when column names
are not provided and header is None (no header)\f[R].
.PD 0
.P
.PD
When it is None (not specified explicitly), it will create list of
numbers as column labels of length N - 1, where \f[B]`N'\f[R] is the
number of columns in the input file.
.PD 0
.P
.PD
\f[I]\f[BI]mangle_dupe_cols\f[I]\f[R]: It accepts boolean value as
parameter that specifies the action taken for duplicate columns present
in the input file.
(Default: True)
.PD 0
.P
.PD
- \f[B]When set to True (not specified explicitly) and if duplicate
columns are present\f[R], they will be specified as `X', `X.1',
\&...\[cq]X.N\[cq], rather than `X'\&...\[cq]X\[cq].
.PD 0
.P
.PD
- \f[B]When set to False and duplicate columns are present\f[R], it will
raise an exeption \f[B](not supported in frovedis yet)\f[R].
.PD 0
.P
.PD
\f[I]\f[BI]dtype\f[I]\f[R]: It accepts datatype or dictionary of columns
which is used for explicitly setting type for data or columns in
frovedis dataframe.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]na_values\f[I]\f[R]: It accepts scalar value or array-like
input as parameter that specifies the additional strings to recognize as
missing values (NA/NaN).
Currently, it doesn\[cq]t accept dictionary as value for this parameter.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it will interpret the list
of following values as missing values:
.IP
.nf
\f[C]
[\[aq]null\[aq], \[aq]NULL\[aq], \[aq]nan\[aq], \[aq]-nan\[aq], \[aq]NaN\[aq], \[aq]-NaN\[aq], \[aq]NA\[aq], \[aq]N/A\[aq], \[aq]n/a\[aq]]  
\f[R]
.fi
.PP
In case we want some other value to be interpreted as missing value, it
is explicitly provided.
.PD 0
.P
.PD
\f[I]\f[BI]verbose\f[I]\f[R]: It accepts a bollean values as parameter
that specifies the log level to use.
Its value is \f[B]False by default (for INFO mode)\f[R] and it can be
set to \f[B]True (for DEBUG mode)\f[R].
This is used for getting the loading time logs from frovedis server.
It is useful for debugging purposes.
(Default: False)
.PD 0
.P
.PD
\f[I]\f[BI]comment\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]low_memory\f[I]\f[R]: It accepts boolean value as parameter
that specifies if the dataframe is to be loaded chunk wise.
The chunk size then would be specified by the `separate_mb' parameter.
(Default: True)
.PP
For example,
.IP
.nf
\f[C]
import time
train_time = []
start_time = time.time()
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names=[\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], 
                   low_memory = False)
train_time.append(round(time.time() - start_time, 4))
print(\[aq]loading time: \[aq]train_time)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
loading time:  [0.0063]
\f[R]
.fi
.PP
Here, it is False, by default.
So, it will load entire data into frovedis dataframe at once.
.PP
For example,
.IP
.nf
\f[C]
import time
train_time = []
start_time = time.time()
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names=[\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], 
                   low_memory = False)
train_time.append(round(time.time() - start_time, 4))
print(\[aq]loading time: \[aq]train_time)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
loading time:  [0.0021]
\f[R]
.fi
.PP
Here it is True, so it will load data chunk wise.
.PP
\f[I]\f[BI]rows_to_see\f[I]\f[R]: It accepts integer value as parameter.
It is useful when creating frovedis dataframe by loading from large
files.
While using big files, only some rows would be used to infer the data
types of columns.
This paramter specifies the number of such rows which will used to infer
data types.
(Default: 1024)
.PD 0
.P
.PD
\f[I]\f[BI]separate_mb\f[I]\f[R]: It accepts double (float64) value as
parameter.
It is a memory optimization parameter.
(Default: 1024)
.PD 0
.P
.PD
- \f[B]If low_memory = True\f[R], then internally frovedis dataframes of
size \f[B]`separate_mb'\f[R] will be loaded separately and would be
combined later into a single frovedis dataframe.
.PD 0
.P
.PD
- \f[B]If low_memory = False\f[R], then complete frovedis dataframe will
be loaded at once.
.PP
\f[B]Purpose\f[R]
.PP
This method reads a comma-separated values (csv) file into frovedis
dataframe.
.PP
\f[B]Note:- While loading file into frovedis dataframe, the file should
not contain blank line at beginning.\f[R]
.PP
The parameters: \[lq]squeeze\[rq] and \[lq]comment\[rq] are simply kept
in to to make the interface uniform to the pandas read_csv() method.
These are not used internally within the frovedis implementation.
.PP
\f[B]File: numbers.csv\f[R]
.PP
10,10.23,F,0
.PD 0
.P
.PD
12,12.20,nan,0
.PD 0
.P
.PD
13,34.90,D,1
.PD 0
.P
.PD
15,100.12,A,2
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with csv file path
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq])
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   10      10.23   F       0
0       12      12.2    NULL    0
1       13      34.8999 D       1
2       15      100.12  A       2
\f[R]
.fi
.PP
Here, by default it uses `,' delimiter while loading csv data into
frovedis dataframe.
.PP
Also, since no column names were provided and header = `infer', so the
newly created frovedis dataframe contains column names inferred from the
first line of input file.
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with header = None and column names not provided
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], header = None)
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   0       1       2       3
0       10      10.23   F       0
1       12      12.2    NULL    0
2       13      34.8999 D       1
3       15      100.12  A       2
\f[R]
.fi
.PP
Here, it creates list of column numbers which is used as column names in
newly created frovedis dataframe.
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with header = None and column names are provided
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names = [\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], header = None)
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   one     two     three   four
0       10      10.23   F       0
1       12      12.2    NULL    0
2       13      34.8999 D       1
3       15      100.12  A       2
\f[R]
.fi
.PP
Here, given list of names will be used as column names in the newly
generated frovedis dataframe.
.PP
Also, the input file, no duplicates column names were present in its
header.
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with prefix = True
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], header = None, prefix = \[dq]X\[dq])
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   X0      X1      X2      X3
0       10      10.23   F       0
1       12      12.2    NULL    0
2       13      34.8999 D       1
3       15      100.12  A       2
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with usecols parameter
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq],names=[\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], usecols = [1,2])
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   two     three
0       10.23   F
1       12.2    NULL
2       34.8999 D
3       100.12  A
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with dtype parameter
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names = [\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], 
                   dtype = {\[aq]two\[aq]: int})
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   one     two     three   four
0       10      9823    F       0
1       12      11820   NULL    0
2       13      33890   D       1
3       15      99812   A       2
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with index_col parameter with integer values
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names = [\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], index_col = 1)
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
two     one     three   four
10.23   10      F       0
12.2    12      NULL    0
34.8999 13      D       1
100.12  15      A       2
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with index_col = False
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names = [\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], index_col = False)
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   one     two     three   four
0       10      10.23   E       0
1       12      12.2    NULL    0
2       13      34.8999 D       1
3       15      100.12  A       2
\f[R]
.fi
.PP
Here, it will force the first column to not be used as index.
.PP
In case the input file contains duplicate columns in header, then,
.PP
\f[B]File: numbers_dupl.csv\f[R]
.PP
score,score,grade,pass
.PD 0
.P
.PD
11.2,10.23,F,0
.PD 0
.P
.PD
21.2,12.20,nan,0
.PD 0
.P
.PD
43.6,34.90,D,1
.PD 0
.P
.PD
75.1,100.12,A,1
.PP
For example,
.IP
.nf
\f[C]
# demo for read_csv() with mangle_dupe_cols = True
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers_dupl.csv\[dq],mangle_dupe_cols = True)
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   score   score.1 grade   pass
0       10      10.23   F       0
1       12      12.2    NULL    0
2       13      34.8999 D       1
3       15      100.12  A       1
\f[R]
.fi
.PP
For example,
.PP
\f[B]File: numbers.csv\f[R]
.PP
10,10.23,F,0
.PD 0
.P
.PD
12,12.20,None,0
.PD 0
.P
.PD
13,34.90,D,1
.PD 0
.P
.PD
15,100.12,A,2
.PP
The above file contains None as data, so by default it will be loaded in
frovedis dataframe as string (inferred dtype).
.IP
.nf
\f[C]
# demo for read_csv() with na_values parameter provided
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names = [\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]])
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   one     two     three   four
0       10      10.23   F       0
1       12      12.2    None    0
2       13      34.8999 D       1
3       15      100.12  A       2
\f[R]
.fi
.PP
It can be interpreted by passing \f[B]\[lq]na_values\[rq]\f[R]
parameter.
.IP
.nf
\f[C]
# demo for read_csv() with na_values parameter provided
import frovedis.dataframe as fdf
df = fdf.read_csv(\[dq]./input/numbers.csv\[dq], names = [\[aq]one\[aq], \[aq]two\[aq], \[aq]three\[aq], \[aq]four\[aq]], 
                   na_values = None)
df.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   one     two     three   four
0       10      10.23   F       0
1       12      12.2    NULL    0
2       13      34.8999 D       1
3       15      100.12  A       2
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance.
.SS 2. Destructing the frovedis DataFrame instance
.PP
\f[B]Using release() method\f[R]
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method acts like a destructor.
.PD 0
.P
.PD
It is used to release dataframe pointer from server heap and it resets
all its attributes to None.
.PP
For example,
.IP
.nf
\f[C]
# fdf1 is same from above example 
# releasing dataframe pointers
fdf1.release()
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns nothing.
.SS 3. Public Member Functions of DataFrame
.PP
DataFrame provides a lot of utilities to perform various operations.
For simplicity we have categorized them into three lists:
\f[B]\f[BI]Basic functions\f[B]\f[R], \f[B]\f[BI]Application, groupby
functions\f[B]\f[R], \f[B]\f[BI]Aggregate functions\f[B]\f[R] and
\f[B]\f[BI]Binary operator functions\f[B]\f[R].
.SS a) List of Basic Functions
.PP
\f[B]Basic functions\f[R] are further categorized into two sub parts -
\f[B]\f[BI]conversion and sorting functions\f[B]\f[R] and
\f[B]\f[BI]selection and combination functions\f[B]\f[R].
.PP
In the basic functions, we will discuss the common and essential
functionalities of dataframe like conversion of dataframes, sorting of
data, selection of specified data and combining two or more data.
.SS Conversion Functions:
.PP
Conversion functions are essential part of DataFrame which are basically
used to perform conversions to other types and to narrow down the data
as per specification.
.IP "1." 3
\f[B]asDF()\f[R] - Returns a Frovedis DataFrame after suitable
conversion from other DataFrame types.
.PD 0
.P
.PD
.IP "2." 3
\f[B]to_dict()\f[R] - Convert the dataframe to a dictionary.
.PD 0
.P
.PD
.IP "3." 3
\f[B]to_numpy()\f[R] - Converts a frovedis dataframe to numpy array.
.PD 0
.P
.PD
.IP "4." 3
\f[B]to_pandas()\f[R] - Returns a pandas dataframe object from frovedis
dataframe.
.PD 0
.P
.PD
.IP "5." 3
\f[B]to_frovedis_rowmajor_matrix()\f[R] - Converts a frovedis dataframe
to FrovedisRowmajorMatrix.
.PD 0
.P
.PD
.IP "6." 3
\f[B]to_frovedis_colmajor_matrix()\f[R] - Converts a frovedis dataframe
to FrovedisColmajorMatrix.
.PD 0
.P
.PD
.IP "7." 3
\f[B]to_frovedis_crs_matrix()\f[R] - Converts a frovedis dataframe to
FrovedisCRSMatrix.
.PD 0
.P
.PD
.IP "8." 3
\f[B]to_frovedis_crs_matrix_using_info()\f[R] - Converts a frovedis
dataframe to FrovedisCRSMatrix provided an info object of
df_to_sparse_info class.
.SS Sorting Functions:
.PP
Sorting functions are essential part of DataFrame.
.IP "1." 3
\f[B]nlargest()\f[R] - Return the first n rows ordered by columns in
descending order.
.PD 0
.P
.PD
.IP "2." 3
\f[B]nsmallest()\f[R] - Return the first n rows ordered by columns in
ascending order.
.PD 0
.P
.PD
.IP "3." 3
\f[B]sort()\f[R] - Sort by the values on a column.
.PD 0
.P
.PD
.IP "4." 3
\f[B]sort_index()\f[R] - Sort dataframes according to index.
.PD 0
.P
.PD
.IP "5." 3
\f[B]sort_values()\f[R] - Sort by the values along either axis.
.SS Generic Functions:
.PP
DataFrame provides various facilities to easily select and combine
together specified values and support join/merge operations.
.IP " 1." 4
\f[B]add_index()\f[R] - Adds index column to the dataframe in-place.
.PD 0
.P
.PD
.IP " 2." 4
\f[B]append()\f[R] - Union of dataframes according to rows.
.PD 0
.P
.PD
.IP " 3." 4
\f[B]apply()\f[R] - Apply a function along an axis of the DataFrame.
.PD 0
.P
.PD
.IP " 4." 4
\f[B]astype()\f[R] - Cast a selected column to a specified dtype.
.PD 0
.P
.PD
.IP " 5." 4
\f[B]between()\f[R] - Filters rows according to the specified bound over
a single column at a time.
.PD 0
.P
.PD
.IP " 6." 4
\f[B]copy()\f[R] - Make a copy of this object\[cq]s indices and data.
.PD 0
.P
.PD
.IP " 7." 4
\f[B]countna()\f[R] - Count NA values for each column/row.
.PD 0
.P
.PD
.IP " 8." 4
\f[B]describe()\f[R] - Generate descriptive statistics.
.PD 0
.P
.PD
.IP " 9." 4
\f[B]drop()\f[R] - Drop specified labels from rows or columns.
.PD 0
.P
.PD
.IP "10." 4
\f[B]drop_duplicates()\f[R] - Return DataFrame with duplicate rows
removed.
.PD 0
.P
.PD
.IP "11." 4
\f[B]dropna()\f[R] - Remove missing values.
.PD 0
.P
.PD
.IP "12." 4
\f[B]fillna()\f[R] - Fill NA/NaN values using specified values.
.PD 0
.P
.PD
.IP "13." 4
\f[B]filter()\f[R] - Subset the dataframe rows or columns according to
the specified index labels.
.PD 0
.P
.PD
.IP "14." 4
\f[B]get_index_loc()\f[R] - Returns integer location, slice or boolean
mask for specified value in index column.
.PD 0
.P
.PD
.IP "15." 4
\f[B]head()\f[R] - Return the first n rows.
.PD 0
.P
.PD
.IP "16." 4
\f[B]insert()\f[R] - Insert column into DataFrame at specified location.
.PD 0
.P
.PD
.IP "17." 4
\f[B]isna()\f[R] - Detect missing values.
.PD 0
.P
.PD
.IP "18." 4
\f[B]isnull()\f[R] - Is an alias of isna().
.PD 0
.P
.PD
.IP "19." 4
\f[B]join()\f[R] - Join columns of another DataFrame.
.PD 0
.P
.PD
.IP "20." 4
\f[B]merge()\f[R] - Merge dataframes according to specified parameters.
.PD 0
.P
.PD
.IP "21." 4
\f[B]rename()\f[R] - Used to rename column.
.PD 0
.P
.PD
.IP "22." 4
\f[B]rename_index()\f[R] - Renames index field (inplace).
.PD 0
.P
.PD
.IP "23." 4
\f[B]reset_index()\f[R] - Reset the index.
.PD 0
.P
.PD
.IP "24." 4
\f[B]set_index()\f[R] - Set the DataFrame index using existing columns.
.PD 0
.P
.PD
.IP "25." 4
\f[B]show()\f[R] - Displays the selected dataframe values on console.
.PD 0
.P
.PD
.IP "26." 4
\f[B]tail()\f[R] - Return the last n rows.
.PD 0
.P
.PD
.IP "27." 4
\f[B]update_index()\f[R] - Updates/sets index values.
.SS b) List of Aggregate Functions
.PP
Aggregate functions of dataframe help to perform computations on the
specified values and helps with efficient summarization of data.
The calculated values gives insight into the nature of potential data.
.IP " 1." 4
\f[B]agg()\f[R] - Aggregate using the specified functions and columns.
.PD 0
.P
.PD
.IP " 2." 4
\f[B]cov()\f[R] - Returns the pairwise covariance of columns, excluding
missing values.
.PD 0
.P
.PD
.IP " 3." 4
\f[B]mad()\f[R] - Returns the mean absolute deviation of the values over
the requested axis.
.PD 0
.P
.PD
.IP " 4." 4
\f[B]max()\f[R] - Returns the maximum of the values over the requested
axis.
.PD 0
.P
.PD
.IP " 5." 4
\f[B]mean()\f[R] - Returns the mean of the values over the requested
axis.
.PD 0
.P
.PD
.IP " 6." 4
\f[B]median()\f[R] - Returns the median of the values over the requested
axis.
.PD 0
.P
.PD
.IP " 7." 4
\f[B]min()\f[R] - Returns the minimum of the values over the requested
axis.
.PD 0
.P
.PD
.IP " 8." 4
\f[B]mode()\f[R] - Returns the mode(s) of each element along the
selected axis.
.PD 0
.P
.PD
.IP " 9." 4
\f[B]sem()\f[R] - Returns the unbiased standard error of the mean over
requested axis.
.PD 0
.P
.PD
.IP "10." 4
\f[B]std()\f[R] - Returns the sample standard deviation over requested
axis.
.PD 0
.P
.PD
.IP "11." 4
\f[B]sum()\f[R] - Returns the sum of the values over the requested axis.
.PD 0
.P
.PD
.IP "12." 4
\f[B]var()\f[R] - Returns unbiased variance over requested axis.
.SS c) List of Math Functions
.PP
DataFrame has methods for carrying out binary operations like add(),
sub(), etc and related functions like radd(), rsub(), etc.
for carrying out reverse binary operations.
.IP " 1." 4
\f[B]abs()\f[R] - Return a DataFrame with absolute numeric value of each
element.
.PD 0
.P
.PD
.IP " 2." 4
\f[B]add()\f[R] - Get addition of dataframe and other specified value.
It is equivalent to dataframe + other.
.PD 0
.P
.PD
.IP " 3." 4
\f[B]div()\f[R] - Get floating division of dataframe and other specified
value.
It is equivalent to dataframe / other.
.PD 0
.P
.PD
.IP " 4." 4
\f[B]floordiv()\f[R] - Get integer division of dataframe and other
specified value.
It is equivalent to dataframe // other.
.PD 0
.P
.PD
.IP " 5." 4
\f[B]mod()\f[R] - Get modulo of dataframe and other specified value.
It is equivalent to dataframe % other.
.PD 0
.P
.PD
.IP " 6." 4
\f[B]mul()\f[R] - Get multiplication of dataframe and other specified
value.
It is equivalent to dataframe * other.
.PD 0
.P
.PD
.IP " 7." 4
\f[B]pow()\f[R] - Get exponential power of dataframe and other specified
value.
It is equivalent to dataframe ** other.
.PD 0
.P
.PD
.IP " 8." 4
\f[B]sub()\f[R] - Get subtraction of dataframe and other specified
value.
It is equivalent to dataframe - other.
.PD 0
.P
.PD
.IP " 9." 4
\f[B]truediv()\f[R] - Get floating division of dataframe and other
specified value.
It is equivalent to dataframe / other.
.PD 0
.P
.PD
.IP "10." 4
\f[B]radd()\f[R] - Get addition of other specified value and dataframe.
It is equivalent to other + dataframe.
.PD 0
.P
.PD
.IP "11." 4
\f[B]rdiv()\f[R] - Get floating division of other specified value and
dataframe.
It is equivalent to other / dataframe.
.PD 0
.P
.PD
.IP "12." 4
\f[B]rfloordiv()\f[R] - Get integer division of other specified value
and dataframe.
It is equivalent to other // dataframe.
.PD 0
.P
.PD
.IP "13." 4
\f[B]rmod()\f[R] - Get modulo of other specified value and dataframe.
It is equivalent to other % dataframe.
.PD 0
.P
.PD
.IP "14." 4
\f[B]rmul()\f[R] - Get multiplication of other specified value and
dataframe.
It is equivalent to other * dataframe.
.PD 0
.P
.PD
.IP "15." 4
\f[B]rpow()\f[R] - Get exponential power of other specified value and
dataframe.
It is equivalent to other ** dataframe.
.PD 0
.P
.PD
.IP "16." 4
\f[B]rsub()\f[R] - Get subtraction of other specified value and
dataframe.
It is equivalent to other - dataframe.
.PD 0
.P
.PD
.IP "17." 4
\f[B]rtruediv()\f[R] - Get floating division of other specified value
and dataframe.
It is equivalent to other / dataframe.
.SS Indexing in frovedis Dataframe
.PP
Indexing means simply selecting particular rows and columns of data from
a dataframe.
Indexing can also be known as Subset Selection.
.PP
There are a lot of ways to pull the rows and columns from a dataframe.
There are some indexing method which help in getting an element from a
dataframe.
These indexing methods appear very similar but behave very differently.
\f[B]Currently, frovedis supports only one type of indexing\f[R].
It is:
.IP \[bu] 2
\f[B]Dataframe.[ ]\f[R]: This function also known as indexing operator.
It helps in filtering rows and columns from a dataframe.
Also, it returns a pandas dataframe as output.
.PP
\f[B]Indexing using [ ]\f[R]
.PP
Indexing operator is used to refer to the square brackets following an
object.
.PP
In order to select a single column, we simply put the name of the column
in-between the brackets.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4], 
                      \[dq]Bonus\[dq]: [5, 2, 2, 4], 
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58], 
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [\[dq]John\[dq], \[dq]Marry\[dq], \[dq]Sam\[dq], \[dq]Jo\[dq]]
                   ) 
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# selcting a single column
fdf1[\[aq]Bonus\[aq]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Bonus
John    5
Marry   2
Sam     2
Jo      4
\f[R]
.fi
.PP
In order to select multiple columns, we have to pass a list of columns
in an indexing operator.
.PP
For example,
.IP
.nf
\f[C]
# selecting multiple columns
fdf1[[\[aq]Bonus\[aq],\[aq]Salary,\[aq]]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Bonus   Salary
John    5       60
Marry   2       60
Sam     2       64
Jo      4       59
\f[R]
.fi
.PP
In order to select rows between given range using indexing operator, it
can be done as follows:
.PP
For example,
.IP
.nf
\f[C]
# filtering dataframe using slice operation with row numbers
fdf1[1:2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering dataframe using slice operation with row labels
fdf1[\[aq]John\[aq]:\[aq]Sam\[aq]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
\f[R]
.fi
.PP
\f[B]Note:- Frovedis also supports use of attribute operators to
filter/select column(s) in dataframe\f[R]
.PP
For example, in previous example which selects \f[B]Bonus\f[R] column
from the dataframe can be expressed as:
.IP
.nf
\f[C]
fdf1.Bonus
\f[R]
.fi
.PP
This returns a FrovedisColumn instance.
.PP
Filtering can be done with help of attribute operators as follows:
.PP
For example,
.IP
.nf
\f[C]
# filtering data using given condition
fdf1[fdf1.Bonus == 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus  Bonus  Last Salary  Salary
Marry   2           2      59           60
Sam     2           2      63           64
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering data using \[aq]>\[aq] operator
fdf1[fdf1.Bonus > 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
John    5            5       58            60
Jo      4            4       58            59
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering data using \[aq]<\[aq] operator
fdf1[fdf1.Bonus < 5].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
Sam     2            2       63            64
Jo      4            4       58            59
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering data using \[aq]!=\[aq] operator
fdf1[fdf1.Bonus != 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus    Bonus   Last Salary    Salary
John    5             5       58             60
Jo      4             4       58             59
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# using \[aq]&\[aq] operation to filter data
fdf1[(fdf1.Bonus == 5) & (fdf1.Salary == 60)].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
John    5            5       58            60
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# using \[aq]|\[aq] operation to filter data
fdf1[(fdf1.Bonus == 5) | (fdf1.Salary == 60)].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus    Bonus   Last Salary   Salary
John    5             5       58            60
Marry   2             2       59            60
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# using \[aq]\[ti]\[aq] operation to filter data
fdf1[\[ti](fdf1.Bonus == 5)].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
Sam     2            2       63            64
Jo      4            4       58            59
\f[R]
.fi
.SH SEE ALSO
.IP \[bu] 2
\f[B]DataFrame - Generic Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Conversion Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Sorting Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Math Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Aggregate Functions\f[R]
