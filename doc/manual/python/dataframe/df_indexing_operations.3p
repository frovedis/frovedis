.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "DataFrame Indexing Operations" "" "" "" ""
.hy
.SH NAME
.PP
Indexing in frovedis Dataframe - it means simply selecting particular
rows and columns of data from a dataframe.
.SH DESCRIPTION
.PP
There are a lot of ways to pull the rows and columns from a dataframe.
Frovedis DataFrame class provides some indexing methods which help in
filtering data from a dataframe.
These indexing methods appear very similar but behave very differently.
\f[B]Currently, frovedis supports the below mentioned types of
indexing\f[R].
They are as follows:
.IP \[bu] 2
\f[B]Dataframe.[ ]\f[R]: This function is also known as
\f[B]getitem\f[R].
It helps in filtering rows and columns from a dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Dataframe.loc[]\f[R]: It is primarily label based, but may also be
used with a boolean array.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Dataframe.iloc[]\f[R]: It is primarily integer position based, but
may also be used with a boolean array.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Dataframe.at[]\f[R]: Similar to loc, both provide label-based
lookups.
It is used when only needed to get a single value in a DataFrame.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Dataframe.iat[]\f[R]: Similar to iloc, both provide integer-based
lookups.
It is used when only needed to get a single value in a DataFrame.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]Dataframe.take()\f[R]: This function is used to return the elements
in the given positional indices along an axis.
.SS Detailed description
.PP
\f[B]1.
Indexing using [ ]\f[R]
.PP
Indexing operator is used to refer to the square brackets following an
object.
.PP
In order to select a single column, we simply put the name of the column
in-between the brackets.
.PP
\f[B]Selecting a single column:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58],
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [\[dq]John\[dq], \[dq]Marry\[dq], \[dq]Sam\[dq], \[dq]Jo\[dq]]
                   )
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()

print(\[aq]selecting single column: \[aq])
fdf1[\[aq]Bonus\[aq]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59

selecting single column:
index   Bonus
John    5
Marry   2
Sam     2
Jo      4
\f[R]
.fi
.PP
\f[B]Note:- Frovedis also supports use of attribute operators to
filter/select column(s) in dataframe\f[R]
.PP
In previous example, \f[B]Bonus\f[R] column can also be selected from
the dataframe as follows:
.PP
For example,
.IP
.nf
\f[C]
fdf1.Bonus
\f[R]
.fi
.PP
This returns a FrovedisColumn instance.
.PP
\f[B]To select multiple columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# selecting multiple columns
fdf1[[\[aq]Bonus\[aq],\[aq]Salary\[aq]]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Bonus   Salary
John    5       60
Marry   2       60
Sam     2       64
Jo      4       59
\f[R]
.fi
.PP
Here, list of columns are passed in the indexing operator.
.PP
\f[B]Filtering dataframe using slice operation with row numbers:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1[1:2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
\f[R]
.fi
.PP
\f[B]Filtering dataframe using slice operation with row labels:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1[\[aq]John\[aq]:\[aq]Sam\[aq]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
\f[R]
.fi
.PP
\f[B]Filtering can be done with help of attribute operators:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# filtering data using given condition
fdf1[fdf1.Bonus == 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus  Bonus  Last Salary  Salary
Marry   2           2      59           60
Sam     2           2      63           64
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering data using \[aq]>\[aq] operator
fdf1[fdf1.Bonus > 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
John    5            5       58            60
Jo      4            4       58            59
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering data using \[aq]<\[aq] operator
fdf1[fdf1.Bonus < 5].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
Sam     2            2       63            64
Jo      4            4       58            59
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering data using \[aq]!=\[aq] operator
fdf1[fdf1.Bonus != 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus    Bonus   Last Salary    Salary
John    5             5       58             60
Jo      4             4       58             59
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# using \[aq]&\[aq] operation to filter data
fdf1[(fdf1.Bonus == 5) & (fdf1.Salary == 60)].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
John    5            5       58            60
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# using \[aq]|\[aq] operation to filter data
fdf1[(fdf1.Bonus == 5) | (fdf1.Salary == 60)].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus    Bonus   Last Salary   Salary
John    5             5       58            60
Marry   2             2       59            60
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# using \[aq]\[ti]\[aq] operation to filter data
fdf1[\[ti](fdf1.Bonus == 5)].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
Marry   2            2       59            60
Sam     2            2       63            64
Jo      4            4       58            59
\f[R]
.fi
.PP
The above filtering expressions can also be done with the help of
indexing operator.
.PP
For example,
.IP
.nf
\f[C]
# filtering data using given condition
fdf1[fdf1[\[dq]Bonus\[dq]] == 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus  Bonus  Last Salary  Salary
Marry   2           2      59           60
Sam     2           2      63           64
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# filtering data using \[aq]>\[aq] operator
fdf1[fdf1[\[dq]Bonus\[dq]] > 2].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
John    5            5       58            60
Jo      4            4       58            59
\f[R]
.fi
.PP
\f[B]2.
Indexing a DataFrame using .loc[ ] :\f[R]
.PP
This function selects data by the label of the rows and columns.
.PP
Allowed inputs are:
.IP \[bu] 2
A single label, e.g.\ 5 or `a'.
Here, 5 is interpreted as a label of the index, and not as an integer
position along the index.
.PD 0
.P
.PD
.IP \[bu] 2
A list or array of labels, e.g.\ [`a', `b', `c'].
.PD 0
.P
.PD
.IP \[bu] 2
A slice object with labels, e.g.\ `a':`f'.
Here while using slices, both the start and the stop are included.
.PD 0
.P
.PD
.IP \[bu] 2
A boolean array of the same length as number of rows, e.g.\ [True,
False, True].
.PP
\f[B]Currently, .loc[] cannot be used to set values for items in
dataframe.\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.loc[\[aq]0\[aq],:] = \[aq]Jai\[aq]              #not supported
fdf1.loc[\[aq]0\[aq],:] = 12                 #not supported
\f[R]
.fi
.PP
The above expression will give an error.
.PP
Also, it cannot be used to filter data using given condition.
.PP
For example,
.IP
.nf
\f[C]
fdf1.loc[fdf1[\[aq]Bonus\[aq]] > 2].show()   #not supported
\f[R]
.fi
.PP
The above expression will give an error.
.PP
\f[B]Selecting a single column:\f[R]
.PP
In order to select a single row using .loc[], we put a single row label
in a .loc function.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58],
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [\[dq]John\[dq], \[dq]Marry\[dq], \[dq]Sam\[dq], \[dq]Jo\[dq]]
                   )
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()

print(\[aq]selecting single column: \[aq])
fdf1.loc[\[aq]John\[aq]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59

selecting single column:
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
\f[R]
.fi
.PP
\f[B]To select multiple columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# selecting multiple columns
fdf1.loc[[\[aq]Marry\[aq],\[aq]Sam\[aq],\[aq]Jo\[aq]]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59
\f[R]
.fi
.PP
\f[B]Filtering dataframe using slice operation with row labels:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.loc[\[aq]Marry\[aq]:\[aq]Sam\[aq]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
Marry   2            2       59           60
Sam     2            2       63           64
\f[R]
.fi
.PP
\f[B]Selecting two rows and three columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.loc[\[aq]Marry\[aq]:\[aq]Sam\[aq], [\[aq]Bonus\[aq], \[aq]Last Salary\[aq], \[aq]Salary\[aq]]]
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Bonus    Last Salary   Salary
Marry   2        59            60
Sam     2        63            64
\f[R]
.fi
.PP
\f[B]Selecting all rows and some columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.loc[:, [\[aq]Bonus\[aq], \[aq]Last Salary\[aq], \[aq]Salary\[aq]]]
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Bonus    Last Salary   Salary
John    5        58            60
Marry   2        59            60
Sam     2        63            64
Jo      4        58            59
\f[R]
.fi
.PP
\f[B]To select data using boolean list:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# selecting using boolean list
fdf1.loc[[True, False, True, False]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
John    5            5       58            60
Sam     2            2       63            64
\f[R]
.fi
.PP
In case a dataframe having boolean indices is used, then .loc[] must be
used with such boolean labels only.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58],
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [True, False, False, True]
                   )
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()

fdf1.loc[[False, False, True, False]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
1       5            5       58            60
0       2            2       59            60
0       2            2       63            64
1       4            4       58            59

index   Last Bonus   Bonus   Last Salary   Salary
0       2            2       63            64
\f[R]
.fi
.PP
\f[B]3.
Indexing a DataFrame using .iloc[ ] :\f[R]
.PP
This function allows us to retrieve rows and columns by position.
.PP
The df.iloc indexer is very similar to df.loc but only uses integer
locations to make its selections.
.PP
Allowed inputs are:
.IP \[bu] 2
An integer, e.g.\ 5.
.PD 0
.P
.PD
.IP \[bu] 2
A list or array of integers, e.g.\ [4, 3, 0].
.PD 0
.P
.PD
.IP \[bu] 2
A slice object with ints, e.g.\ 1:7.
.PD 0
.P
.PD
.IP \[bu] 2
A boolean array of the same length as number of rows, e.g.\ [True,
False, True].
.PP
\f[B]Currently, .iloc[] cannot be used to set values for items in
dataframe.\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.iloc[0,:] = \[aq]Jai\[aq]               #not supported
fdf1.iloc[0,:] = 12                  #not supported
\f[R]
.fi
.PP
The above expression will give an error.
.PP
Also, it cannot be used to filter data using given condition.
.PP
For example,
.IP
.nf
\f[C]
fdf1.iloc[fdf1[\[aq]Bonus\[aq]] > 2].show()  #not supported
\f[R]
.fi
.PP
The above expression will give an error.
.PP
\f[B]Selecting a single column:\f[R]
.PP
In order to select a single row using .iloc[], we can pass a single
integer to .iloc[] function.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58],
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [\[dq]John\[dq], \[dq]Marry\[dq], \[dq]Sam\[dq], \[dq]Jo\[dq]]
                   )
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()

print(\[aq]selecting single column: \[aq])
fdf1.iloc[3].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59

selecting single column:
index   Last Bonus   Bonus   Last Salary  Salary
Jo      4            4       58           59
\f[R]
.fi
.PP
\f[B]To select multiple columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# selecting multiple columns
fdf1.iloc[[0, 1 ,3]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Jo      4            4       58           59
\f[R]
.fi
.PP
\f[B]Filtering dataframe using slice operation with row labels:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.iloc[1:3].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
Marry   2            2       59           60
Sam     2            2       63           64
\f[R]
.fi
.PP
\f[B]Selecting two rows and two columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.iloc[[1, 3],[2, 3]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Salary  Salary
Marry   59           60
Jo      58           59
\f[R]
.fi
.PP
\f[B]Selecting all rows and some columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.iloc[:, [2, 3]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Salary   Salary
John    58            60
Marry   59            60
Sam     63            64
Jo      58            59
\f[R]
.fi
.PP
\f[B]To select data using boolean list:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# selecting using boolean list
fdf1.iloc[[True, False, True, False]].show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary   Salary
John    5            5       58            60
Sam     2            2       63            64
\f[R]
.fi
.PP
\f[B]4.
Indexing a DataFrame using .at[ ] :\f[R]
.PP
This function is used to access single value for a row/column label
pair.
.PP
This method works in a similar way to .loc[ ] but .at[ ] is used to
return an only single value and hence it works faster than .loc[].
.PP
\f[B]Currently, .at[] cannot be used to set values for items in
dataframe.\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.at[\[aq]John\[aq], \[aq]Bonus\[aq]] = 52       #not supported
\f[R]
.fi
.PP
The above expression will give an error.
.PP
\f[B]Accesing a single value:\f[R]
.PP
In order to access a single value, we can pass a pair of row and column
labels to .at[] function.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58],
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [\[dq]John\[dq], \[dq]Marry\[dq], \[dq]Sam\[dq], \[dq]Jo\[dq]]
                   )
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()

print(\[aq]selecting single value: \[aq])
fdf1.at[\[aq]John\[aq], \[aq]Bonus\[aq]]
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59

selecting single value:
5
\f[R]
.fi
.PP
In case the given row/column label is not found then, it will give
KeyError.
.PP
Also, it does not allow to perform slicing and will give an error.
.PP
\f[B]5.
Indexing a DataFrame using .iat[ ] :\f[R]
.PP
This function is used to access single value for a row/column pair by
integer position.
.PP
This method works in a similar way to .iloc[ ] but .iat[ ] is used to
return an only single value and hence it works faster than .iloc[].
.PP
\f[B]Currently, .iat[] cannot be used to set values for items in
dataframe.\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.iat[0, 2] = 52       #not supported
\f[R]
.fi
.PP
The above expression will give an error.
.PP
\f[B]Accesing a single value:\f[R]
.PP
In order to access a single value, we can pass a pair of row and column
index positions to .iat[] function.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58],
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [\[dq]John\[dq], \[dq]Marry\[dq], \[dq]Sam\[dq], \[dq]Jo\[dq]]
                   )
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()

print(\[aq]selecting single value: \[aq])
fdf1.iat[0, 2]
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59

selecting single value:
58
\f[R]
.fi
.PP
In case the given row/column index position is not found then, it will
give IndexError.
.PP
Also, it does not allow to perform slicing and will give an error.
.PP
\f[B]6.
Indexing a DataFrame using take() :\f[R]
.PP
\f[B]DataFrame.take(indices, axis = 0, is_copy = None, **kwargs)\f[R]
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]indices\f[B]\f[R]: An array of integers indicating which
positions to take.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to select elements.
(Default: 0)
.PD 0
.P
.PD
- 0 or `index': used to select rows.
.PD 0
.P
.PD
- 1 or `columns': used to select columns.
.PP
\f[B]\f[BI]is_copy\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: This is an unused parameter.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It returns the elements in the given positional indices along an axis.
.PP
Here, indexing is not according to actual values in the index attribute
of the object rather indexing is done according to the actual position
of the element in the object.
.PP
\f[B]Selecting elements along axis = 0 (default) :\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a pandas dataframe from key value pair
pdf2 = pd.DataFrame({ \[dq]Last Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Bonus\[dq]: [5, 2, 2, 4],
                      \[dq]Last Salary\[dq]: [58, 59, 63, 58],
                      \[dq]Salary\[dq]: [60, 60, 64, 59]
                    }, index= [\[dq]John\[dq], \[dq]Marry\[dq], \[dq]Sam\[dq], \[dq]Jo\[dq]]
                   )
# creating frovedis dataframe
fdf1 = fdf.DataFrame(pdf2)

# display created frovedis dataframe
fdf1.show()

print(\[aq]selecting along axis = 0: \[aq])
fdf1.take(indices = [0, 2], axis = 0)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Marry   2            2       59           60
Sam     2            2       63           64
Jo      4            4       58           59

selecting along axis = 0:
index   Last Bonus   Bonus   Last Salary  Salary
John    5            5       58           60
Sam     2            2       63           64
\f[R]
.fi
.PP
\f[B]Selecting elements along axis = 1 (column selection) :\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.take(indices = [1, 2], axis = 1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Bonus   Last Salary
John    5       58
Marry   2       59
Sam     2       63
Jo      4       58
\f[R]
.fi
.PP
\f[B]Selecting elements from the end along axis = 0:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.take(indices = [-1, -2], axis = 0)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Last Bonus  Bonus   Last Salary    Salary
Jo      4           4       58             59
Sam     2           2       63             64
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance or FrovedisColumn instance.
.SH SEE ALSO
.IP \[bu] 2
\f[B]DataFrame - Introduction\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Generic Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Conversion Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Sorting Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Math Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Aggregate Functions\f[R]
