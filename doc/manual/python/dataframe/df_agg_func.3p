.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "DataFrame Aggregate Functions" "" "" "" ""
.hy
.SH NAME
.PP
DataFrame Aggregate Functions - list of all functions related to
aggregate operations on frovedis dataframe are illustrated here.
.SS DESCRIPTION
.PP
An essential piece of analysis of large data is efficient summarization:
computing aggregations like sum(), mean(), median(), min(), and max(),
which gives insight into the nature of a potentially large dataset.
In this section, we\[cq]ll explore list of all such aggregation
operations done on frovedis dataframe.
.PP
Aggregation can be performed in \f[B]two ways\f[R] on frovedis
dataframe:
.IP \[bu] 2
Either using agg().
.PD 0
.P
.PD
.IP \[bu] 2
Or using aggregation functions such as min(), max() median(), mode(),
etc.
on frovedis dataframe.
.SS Public Member Functions
.IP
.nf
\f[C]
1. agg(func)  
2. cov((min_periods = None, ddof = 1.0, low_memory = True, other = None)
3. mad(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)  
4. max(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)  
5. mean(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)  
6. median(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)  
7. min(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)  
8. mode(axis = 0, numeric_only = False, dropna = True)
9. sem(axis = None, skipna = None, level = None, ddof = 1, numeric_only = None, **kwargs)  
10. std(axis = None, skipna = None, level = None, ddof = 1, numeric_only = None, **kwargs)  
11. sum(axis = None, skipna = None, level = None, numeric_only = None, 
        min_count = 0, **kwargs)
12. var(axis = None, skipna = None, level = None, ddof = 1, numeric_only = None, **kwargs)  
\f[R]
.fi
.SS Detailed Description
.SS 1. DataFrame.agg(func)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]func\f[B]\f[R]: Names of functions to use for aggregating the
data.
The input to be used with the function must be a frovedis DataFrame
instance having atleast one numeric column.
.PD 0
.P
.PD
Accepted combinations for this parameter are:
.IP \[bu] 2
A string function name such as `max', `min', etc.
.PD 0
.P
.PD
.IP \[bu] 2
list of functions and/or function names, For example, [`max', `mean'].
.PD 0
.P
.PD
.IP \[bu] 2
dictionary with keys as column labels and values as function name or
list of such functions.
.PD 0
.P
.PD
For Example, {`Age': [`max',`min',`mean'], `Ename': [`count']}
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes an aggregate operation based on the condition specified in
`func'.
.PP
\f[B]Currently, this method will perform aggregation operation along the
rows.\f[R]
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Aggregate these functions over the rows, where func is a function
string name:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1.agg(\[aq]max\[aq]))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
Name             nan
Age               36
City             nan
Qualification    nan
Score             52
Name: max, dtype: object
\f[R]
.fi
.PP
It displays a pandas dataframe containing numeric column(s) with newly
computed aggregates of each groups.
.PP
\f[B]Performing aggregation along the rows where func is a
dictionary:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1.agg({\[dq]Age\[dq]: [\[dq]std\[dq], \[dq]mean\[dq]]}))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
            Age
mean  29.125000
std    4.853202
\f[R]
.fi
.PP
\f[B]Aggregation along the rows where func is a list of functions:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1[\[aq]Age\[aq]].agg([\[aq]max\[aq],\[aq]min\[aq],\[aq]mean\[aq]])
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
         Age
max   36.000
min   22.000
mean  29.125
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.IP "1." 3
\f[B]If one `func' provided and `func' is a string:\f[R]
.RS 4
.IP \[bu] 2
It returns a pandas Series instance with numeric column(s) only, after
aggregation function is completed.
.PD 0
.P
.PD
.RE
.IP "2." 3
\f[B]If one or more `func' provided and `func' is list/dict of
string:\f[R]
.RS 4
.IP \[bu] 2
It returns a pandas DataFrame instance with numeric column(s) only,
after aggregation function is completed.
.RE
.SS 2. DataFrame.cov(min_periods = None, ddof = 1.0, low_memory = True, other = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]min_periods\f[B]\f[R]: It accepts an integer as parameter.
It specifies the minimum number of observations required per pair of
columns to have a valid result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), then \f[B]min_periods =
1\f[R].
.PD 0
.P
.PD
\f[B]\f[BI]ddof\f[B]\f[R]: It accepts a float parameter that specifies
the delta degrees of freedom.
(Default: 1.0)
.PD 0
.P
.PD
\f[B]\f[BI]low_memory\f[B]\f[R]: It accepts boolean parameter that
specifies whethet to enable memory optimised computation or time
optimsed computation.
(Default: True)
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It accepts frovedis dataframe as parameter,
where it must be expressed in \f[B]\[lq]df[col_name]\[rq]\f[R] form.
Also, it can be expressed in \f[B]\[lq]df.col_name\[rq]\f[R] form as
well.
(Default: None)
.IP \[bu] 2
\f[B]When it is not None (specified explicitly)\f[R], it performs
covariance operation between both the given frovedis dataframes.
Although, the input dataframe must be used as expressions mentioned
above.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]When it is None (not specified explicitly)\f[R], it will perform
covarince on input dataframe to give covraince matrix represented as a
dataframe.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes pairwise covariance of columns, excluding missing values.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]Score\[aq]: [23, 34, 35, 45, 23, 50, 52, 34]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Age     Score
0       27      23
1       24      34
2       22      35
3       32      45
4       33      23
5       36      50
6       27      52
7       32      34
\f[R]
.fi
.PP
\f[B]Compute covariance on frovedis dataframe:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# cov() demo
fdf1.cov().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Age     Score
Age     23.5535 11
Score   11      124.571
\f[R]
.fi
.PP
It displays a covariance matrix as the frovedis DataFrame instance.
.PP
\f[B]Using min_periods parameter to calculate covariance:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# cov() demo using min_periods = 8
fdf1.cov(min_periods = 8).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Age     Score
Age     NULL    NULL
Score   NULL    NULL
\f[R]
.fi
.PP
\f[B]Using ddof parameter to calculate covariance:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# cov() demo using ddof = 2 
fdf1.cov(ddof = 2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Age     Score
Age     27.4791 12.8333
Score   12.8333 145.333
\f[R]
.fi
.PP
\f[B]In the below example, while using `other' parameter, both inputs
must be frovedis series.
Also, the output returned by this method will be a float value.\f[R]
.PP
For example,
.IP
.nf
\f[C]
# create another dataframe
pdf2 = pd.DataFrame({\[aq]Score\[aq]: [51, 34, 33, 45, 12, 82, 67, 91]})
fdf2 = fdf.DataFrame(pdf2)

# cov() demo using \[aq]other\[aq] parameter 
print(fdf1[\[aq]Score\[aq]].cov(other = fdf2[\[aq]Score\[aq]]))
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
158.28571428571428
\f[R]
.fi
.PP
Here, it could also be expressed as \f[B]\[lq]fdf1[`Score'].cov(other =
fdf2[`Score'])\[rq]\f[R].
.PP
\f[B]Note:-\f[R] While using input dataframe in the form
\f[B]`fdf1[\[cq]Score\[cq]]' or `fdf1.Score'\f[R], \f[B]`other'\f[R]
parameter must be provided.
.PP
\f[B]Return Value\f[R]
.IP \[bu] 2
\f[B]If other = None:\f[R]
.PD 0
.P
.PD
It returns a covariance matrix represented as frovedis DataFrame
instance.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]If other != None:\f[R]
.PD 0
.P
.PD
It returns covariance as scalar value.
.SS 3. DataFrame.mad(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform mean absolute deviation along
the columns or rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform mean absolute deviation along the
indices.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform mean absolute deviation along the
columns.
.PP
When it is None (not specified explicitly), it performs mean absolute
deviation along the rows.
.PP
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during mean absolute deviation computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsed parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes the mean absolute deviation of the values over the requested
axis.
.PP
\f[B]Currently, mean absolute deviation will be calculated for dataframe
having atleast one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.mad().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Mean absolute deviation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mad() demo, axis = 0 by default
fdf1.mad().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mad
Age     4.125
Score   9.16666
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed mean absolute deviation for each column.
.PP
Also, it excludes the missing value in \f[B]`Score'\f[R] column while
computing the mean absolute deviation.
.PP
\f[B]Mean absolute deviation along the rows and using skipna
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mad() demo using skipna = False
fdf1.mad(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mad
Age     4.125
Score   NULL
\f[R]
.fi
.PP
Here, it includes the missing value in \f[B]`Score'\f[R] column while
computing the mean absolute deviation.
.PP
\f[B]Mean absolute deviation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mad() demo using axis = 1
fdf1.mad(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mad
0       2
1       5
2       6.5
3       6.5
4       0
5       7
6       12.5
7       0
\f[R]
.fi
.PP
\f[B]Mean absolute deviation along the columns and using skipna
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mad() demo using axis = 1 and skipna = False
fdf1.mad(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mad
0       2
1       5
2       6.5
3       6.5
4       NULL
5       7
6       12.5
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance with the result of the
specified aggregate operation.
.SS 4. DataFrame.max(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform maximum operation along the
columns or rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform maximum operation along the indices to
get the maximum value.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform maximum operation along the columns to
get the maximum value.
.PP
When it is None (not specified explicitly), it performs maximum
operation along the rows.
.PP
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during maximum value computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsed parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes the maximum of the values over the requested axis.
.PP
\f[B]Currently, maximum operation will be calculated for dataframe
having atleast one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.max().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Max operation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# max() demo
fdf1.max().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   max
Age     36
Score   52
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed maximum value for each column.
.PP
Also, it excludes the missing value in \f[B]`Score'\f[R] column while
computing the maximum value.
.PP
\f[B]Max operation along the rows and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# max() demo using skipna = False
fdf1.max(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   max
Age     36
Score   NULL
\f[R]
.fi
.PP
Here, it includes the missing value in \f[B]`Score'\f[R] column while
computing the maximum value.
.PP
\f[B]Max operation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# max() demo using axis = 1
fdf1.max(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   max
0       27
1       34
2       35
3       45
4       33
5       50
6       52
7       32
\f[R]
.fi
.PP
\f[B]Max operation along the columns and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# max() demo using axis = 1 and skipna = False
fdf1.max(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   max
0       27
1       34
2       35
3       45
4       NULL
5       50
6       52
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance with the result of the
specified aggregate operation.
.SS 5. DataFrame.mean(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform mean along the columns or rows.
(Default: None)
.PD 0
.P
.PD
- \f[B]0 or `index'\f[R]: perform mean along the indices.
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform mean along the columns.
.PP
When it is None (not specified explicitly), it performs mean operation
along the rows.
.PP
\f[I]\f[BI]skipna\f[I]\f[R]: It is a boolean parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during mean computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsued parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes mean of the values over the requested axis.
.PP
\f[B]Currently, mean will be calculated for dataframe having atleast one
numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.mean().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Mean computation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mean() demo
fdf1.mean(),show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mean
Age     29.125
Score   39.8333
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed mean for each column.
.PP
Also, it excludes the missing value in \f[B]`Score'\f[R] column while
computing the mean.
.PP
\f[B]Mean computation along the rows and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mean() demo using skipna = False
fdf1.mean(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mean
Age     29.125
Score   NULL
\f[R]
.fi
.PP
Here, it includes the missing value in \f[B]`Score'\f[R] column while
computing the mean.
.PP
\f[B]Max operation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mean() demo using axis = 1
fdf1.mean(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mean
0       25
1       29
2       28.5
3       38.5
4       33
5       43
6       39.5
7       32
\f[R]
.fi
.PP
\f[B]Max operation along the columns and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mean() demo using axis = 1 and skipna = False
fdf1.mean(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   mean
0       25
1       29
2       28.5
3       38.5
4       NULL
5       43
6       39.5
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance.
.SS 6. DataFrame.median(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform median operation along the
columns or rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform median operation along the indices.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform median operation along the columns.
.PP
When it is None (not specified explicitly), it performs median operation
along the rows.
.PP
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during median computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsued parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes median of the values over the requested axis.
.PP
\f[B]Currently, median will be calculated for dataframe having atleast
one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.median().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Median computation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# median() demo
fdf1.median().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   median
Age     29.5
Score   40
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed median for each column.
.PP
Also, it excludes the missing value in \f[B]`Score'\f[R] column while
computing the median.
.PP
\f[B]Median computation along the rows and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# median() demo using skipna = False
fdf1.median(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   median
Age     29.5
Score   NULL
\f[R]
.fi
.PP
Here, it includes the missing value in \f[B]`Score'\f[R] column while
computing the median.
.PP
\f[B]Median computation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# median() demo using axis = 1
fdf1.median(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   median
0       25
1       29
2       28.5
3       38.5
4       33
5       43
6       39.5
7       32
\f[R]
.fi
.PP
\f[B]Median computation along the columns and using skipna
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# median() demo using axis = 1 and skipna = False
fdf1.median(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   median
0       25
1       29
2       28.5
3       38.5
4       NULL
5       43
6       39.5
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance.
.SS 7. DataFrame.min(axis = None, skipna = None, level = None, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform minimum operation along the
columns or rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform minimum operation along the indices to
get the minimum value.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform minimum operation along the columns to
get the minimum value.
.PP
When it is None (not specified explicitly), it performs minimum
operation along the rows.
.PP
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during minimum value computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsed parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes the minimum of the values over the requested axis.
.PP
\f[B]Currently, minimum operation will be calculated for dataframe
having atleast one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.min().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Min operation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# min() demo
fdf1.min().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   min
Age     22
Score   23
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed minimum value for each column.
.PP
Also, it excludes the missing value in \f[B]`Score'\f[R] column while
computing the minimum value.
.PP
\f[B]Min operation along the rows and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# min() demo using skipna = False
fdf1.min(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   min
Age     22
Score   NULL
\f[R]
.fi
.PP
Here, it includes the missing value in \f[B]`Score'\f[R] column while
computing the median.
.PP
\f[B]Min operation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# min() demo using axis = 1
fdf1.min(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   min
0       23
1       24
2       22
3       32
4       33
5       36
6       27
7       32
\f[R]
.fi
.PP
\f[B]Min operation along the columns and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# min() demo using axis = 1 and skipna = False
fdf1.min(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   min
0       23
1       24
2       22
3       32
4       NULL
5       36
6       27
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance with the result of the
specified aggregate operation.
.SS 8. DataFrame.mode(axis = 0, numeric_only = False, dropna = True)
.PP
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform standard error of the mean along
the columns or rows.
(Default: 0)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform mode along the indices.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform mode along the columns.
.PP
When it is None (not specified explicitly), it performs standard error
of the mean along the rows.
.PP
\f[I]\f[BI]numeric_only\f[I]\f[R]: It accepts string object as
parameter.
If True, mode operation will result in a dataframe having only numeric
columns.
Otherwise, it will result in a dataframe having both numeric and
non-numeric columns.
(Default: False)
.PD 0
.P
.PD
\f[I]\f[BI]dropna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result of mode operation.
(Default: True)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during mode computation.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
This method gets the mode(s) of each element along the selected axis.
.PP
The mode of a set of values is the value that appears most often.
It can be multiple values.
.PP
\f[B]When input with non-numeric columns is used with mode(), then it
ignores the non-numeric columns for mode computation.\f[R]
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Mode computation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mode() demo
fdf1.mode().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Score   Name    Age     City    Qualification
0       23      Anuj    27      Kanpur  B.Tech
1       34      Jai     32      NULL    Phd
2       35      Princi  NULL    NULL    NULL
3       45      NULL    NULL    NULL    NULL
4       50      NULL    NULL    NULL    NULL
5       52      NULL    NULL    NULL    NULL
\f[R]
.fi
.PP
\f[B]Mode will be calculated for dataframe having string and numeric
columns when axis = 0 or `index'.\f[R]
.PD 0
.P
.PD
\f[B]Also, resultant dataframe has both numeric and non-numeric
columns.\f[R]
.PP
\f[B]Mode computation along the rows and using numeric_only
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mode() demo using numeric_ony = True
fdf1.mode(numeric_ony = True).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Score   Age
0       23      27
1       34      32
2       35      NULL
3       45      NULL
4       50      NULL
5       52      NULL
\f[R]
.fi
.PP
Here, resultant dataframe has only numeric columns.
.PP
\f[B]Mode computation along the rows and using dropna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mode() demo using dropna = False
fdf1.mode(dropna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City    Qualification  Score
0       Anuj    27      Kanpur  B.Tech         NULL
1       Jai     32      NULL    Phd            NULL
2       Princi  NULL    NULL    NULL           NULL
\f[R]
.fi
.PP
\f[B]For axis = 1 or `columns', mode will be calculated for dataframe
having only numeric columns.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
bmiDF = {
        \[aq]height\[aq]:[157, 124, 162, np.nan, 133, 176, np.nan, 152],
        \[aq]weight\[aq]: [53, 64, np.nan, 65, 63, 80, np.nan, 84]
        }

# create pandas dataframe with only numeric columns
pdf1 = pd.DataFrame(bmiDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   height  weight
0       157     53
1       124     64
2       162     NULL
3       NULL    65
4       133     63
5       176     80
6       NULL    NULL
7       152     84
\f[R]
.fi
.PP
\f[B]Mode computation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mode() demo using axis = 1
fdf1.mode(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   0
0       157
1       124
2       162
3       65
4       133
5       176
6       0
7       152
\f[R]
.fi
.PP
\f[B]Mode computation along the columns and using dropna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mode() demo using axis = 1 and dropna = False
fdf1.mode(axis = 1, dropna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   0
0       157
1       124
2       162
3       NULL
4       133
5       176
6       NULL
7       152
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.IP \[bu] 2
\f[B]If numeric_only = False\f[R]:
.PD 0
.P
.PD
It returns a frovedis DataFrame instance having both numeric and
non-numeric columns (if any).
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]If numeric_only = True\f[R]:
.PD 0
.P
.PD
It returns a frovedis DataFrame instance having only numeric columns.
.SS 9. DataFrame.sem(axis = None, skipna = None, level = None, ddof = 1, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform standard error of the mean along
the columns or rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform standard error of the mean along the
indices.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform standard error of the mean along the
columns.
.PP
When it is None (not specified explicitly), it performs standard error
of the mean along the rows.
.PP
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during standard error of the mean computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]ddof\f[B]\f[R]: It accepts an integer parameter that
specifies the delta degrees of freedom.
(Default: 1)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsed parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes standard error of the mean over requested axis.
.PP
\f[B]Currently, standard error of the mean will be calculated for
dataframe having atleast one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.sem().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Standard error of the mean operation along the rows (by
default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sem() demo
fdf1.sem().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sem
Age     1.71586
Score   4.54178
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed standard error of the mean for each column.
.PP
\f[B]Standard error of the mean operation along the rows and using ddof
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sem() demo using ddof = 2 
fdf1.sem(ddof = 2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sem
Age     1.85334
Score   5.07786
\f[R]
.fi
.PP
\f[B]Standard error of the mean operation along the rows and using
skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sem() demo using skipna = False
fdf1.sem(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sem
Age     1.71586
Score   NULL
\f[R]
.fi
.PP
\f[B]Standard error of the mean operation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sem() demo using axis = 1
fdf1.sem(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sem
0       2
1       5
2       6.49999
3       6.49999
4       NULL
5       6.99999
6       12.5
7       NULL
\f[R]
.fi
.PP
\f[B]Standard error of the mean operation along the columns and using
skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sem() demo using axis = 1 and skipna = False
fdf1.sem(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sem
0       2
1       5
2       6.49999
3       6.49999
4       NULL
5       6.99999
6       12.5
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance with the result of the
specified aggregate operation.
.SS 10. DataFrame.std(axis = None, skipna = None, level = None, ddof = 1, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform standard deviation along the
columns or rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform standard deviation along the indices.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform standard deviation along the columns.
.PP
When it is None (not specified explicitly), it performs standard
deviation along the rows.
.PD 0
.P
.PD
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during standard deviation computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]ddof\f[B]\f[R]: It accepts an integer parameter that
specifies the delta degrees of freedom.
(Default: 1)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsed parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes standard deviation over requested axis.
.PP
\f[B]Currently, standard deviation will be calculated for dataframe
having atleast one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.std().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Standard deviation computation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# std() demo
fdf1.std().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   std
Age     4.8532
Score   11.125
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed standard deviation for each column.
.PP
\f[B]Standard deviation computation along the rows and using skipna
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# std() demo using skipna = False
fdf1.std(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   std
Age     4.8532
Score   NULL
\f[R]
.fi
.PP
\f[B]Standard deviation computation along the rows and using ddof
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# std() demo using ddof = 2 
fdf1.std(ddof = 2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   std
Age     5.24205
Score   12.4381
\f[R]
.fi
.PP
\f[B]Standard deviation computation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# std() demo using axis = 1
fdf1.std(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   std
0       2.82842
1       7.07106
2       9.19238
3       9.19238
4       NULL
5       9.89949
6       17.6776
7       NULL
\f[R]
.fi
.PP
\f[B]Standard deviation computation along the columns and using skipna
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# std() demo using axis = 1 and skipna = False
fdf1.std(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   std
0       2.82842
1       7.07106
2       9.19238
3       9.19238
4       NULL
5       9.89949
6       17.6776
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance with the result of the
specified aggregate functions.
.SS 11. DataFrame.sum(axis = None, skipna = None, level = None, numeric_only = None, min_count = 0, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform summation operation along the
columns or rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform summation operation along the indices.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform summation operation along the columns.
.PP
When it is None (not specified explicitly), it performs summation
operation along the rows.
.PD 0
.P
.PD
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during summation computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsed parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]min_count\f[I]\f[R]: It is an integer, float or double
(float64) parameter that specifies the minimum number of values that
needs to be present to perform the action.
(Default: 0)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes the sum of the values over the requested axis.
.PP
\f[B]Currently, summation will be calculated for dataframe having
atleast one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.sum().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Sum operation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sum() demo
fdf1.sum().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sum
Age     233
Score   239
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed summation for each column.
.PP
Also, it excludes the missing value in \f[B]`Score'\f[R] column while
computing summation.
.PP
\f[B]Sum operation along the rows and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sum() demo using skipna = False
fdf1.sum(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sum
Age     233
Score   NULL
\f[R]
.fi
.PP
Here, it includes the missing value in \f[B]`Score'\f[R] column while
computing the sum.
.PP
\f[B]Sum operation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sum() demo using axis = 1
fdf1.sum(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sum
0       50
1       58
2       57
3       77
4       33
5       86
6       79
7       32
\f[R]
.fi
.PP
\f[B]Sum operation along the columns and using skipna parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sum() demo using axis = 1 and skipna = False
fdf1.sum(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   sum
0       50
1       58
2       57
3       77
4       NULL
5       86
6       79
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance with the result of the
specified aggregate functions.
.SS 12. DataFrame.var(axis = None, skipna = None, level = None, ddof = 1, numeric_only = None, **kwargs)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform variance along the columns or
rows.
(Default: None)
.IP \[bu] 2
\f[B]0 or `index'\f[R]: perform variance along the indices.
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform variance along the columns.
.PP
When it is None (not specified explicitly), it performs variance along
the rows.
.PD 0
.P
.PD
\f[I]\f[BI]skipna\f[I]\f[R]: It accepts boolean as parameter.
When set to True, it will exclude missing values while computing the
result.
(Default: None)
.PD 0
.P
.PD
When it is None (not specified explicitly), it excludes missing values
during variance computation.
.PD 0
.P
.PD
\f[I]\f[BI]level\f[I]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]ddof\f[B]\f[R]: It accepts an integer parameter that
specifies the delta degrees of freedom.
(Default: 1)
.PD 0
.P
.PD
\f[I]\f[BI]numeric_only\f[I]\f[R]: This is an unsed parameter.
(Default: None)
.PD 0
.P
.PD
\f[I]\f[BI]**kwargs\f[I]\f[R]: Additional keyword arguments to be passed
to the function.
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes variance over requested axis.
.PP
\f[B]Currently, variance will be calculated for dataframe having atleast
one numeric columns\f[R].
.PP
The parameters: \[lq]level\[rq], \[lq]numeric_only\[rq],
\[lq]**kwargs\[rq] are simply kept in to make the interface uniform to
the pandas DataFrame.var().
These are not used internally in frovedis.
.PP
\f[B]Creatinng frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
peopleDF = {
            \[aq]Name\[aq]:[\[aq]Jai\[aq], \[aq]Anuj\[aq], \[aq]Jai\[aq], \[aq]Princi\[aq], \[aq]Gaurav\[aq], \[aq]Anuj\[aq], \[aq]Princi\[aq], \[aq]Abhi\[aq]],
            \[aq]Age\[aq]:[27, 24, 22, 32, 33, 36, 27, 32],
            \[aq]City\[aq]:[\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq], 
                    \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Qualification\[aq]:[\[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq], \[aq]Phd\[aq], \[aq]B.Tech\[aq]],
            \[aq]Score\[aq]: [23, 34, 35, 45, np.nan, 50, 52, np.nan]
            }

# create pandas dataframe
pdf1 = pd.DataFrame(peopleDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Name    Age     City       Qualification  Score
0       Jai     27      Nagpur     B.Tech         23
1       Anuj    24      Kanpur     Phd            34
2       Jai     22      Allahabad  B.Tech         35
3       Princi  32      Kannuaj    Phd            45
4       Gaurav  33      Allahabad  Phd            NULL
5       Anuj    36      Kanpur     B.Tech         50
6       Princi  27      Kanpur     Phd            52
7       Abhi    32      Kanpur     B.Tech         NULL
\f[R]
.fi
.PP
\f[B]Variance computation along the rows (by default):\f[R]
.PP
For example,
.IP
.nf
\f[C]
# var() demo
fdf1.var().show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   var
Age     23.5535
Score   123.766
\f[R]
.fi
.PP
It displays a frovedis dataframe with numeric column(s) containing the
newly computed variance for each column.
.PP
Also, it excludes the missing value in \f[B]`Score'\f[R] column while
computing variance.
.PP
\f[B]Variance computation along the rows and using skipna
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# var() demo using skipna = False
fdf1.var(skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   var
Age     23.5535
Score   NULL
\f[R]
.fi
.PP
\f[B]Variance computation along the rows and using ddof parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# var() demo using ddof = 2 
fdf1.var(ddof = 2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   var
Age     27.4791
Score   154.708
\f[R]
.fi
.PP
\f[B]Variance computation along the columns:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# var() demo using axis = 1
fdf1.var(axis = 1).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   var
0       8
1       50
2       84.5
3       84.5
4       NULL
5       98
6       312.5
7       NULL
\f[R]
.fi
.PP
\f[B]Variance computation along the columns and using skipna
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# var() demo using axis = 1 and skipna = False
fdf1.var(axis = 1, skipna = False).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   var
0       8
1       50
2       84.5
3       84.5
4       NULL
5       98
6       312.5
7       NULL
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance with the result of the
specified aggregate operation.
.SH SEE ALSO
.IP \[bu] 2
\f[B]DataFrame - Introduction\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Generic Fucntions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Conversion Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Sorting Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Math Functions\f[R]
