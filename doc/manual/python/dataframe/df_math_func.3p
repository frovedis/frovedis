.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "DataFrame Math Functions" "" "" "" ""
.hy
.SH NAME
.PP
DataFrame Math Functions - this manual contains all the methods for
carrying out mathematical operations.
.SS DESCRIPTION
.PP
Frovedis dataframe has several math functions defined for performing
operations like add(), sub(), mul(), etc.
between two dataframes or between scalar value and dataframe.
These functions return a new frovedis DataFrame instance as a result.
.PP
Also, it contains reverse operations such as radd(), rsub(), rmul(),
etc.
.SS Public Member Functions
.IP
.nf
\f[C]
1. abs()
2. add(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
3. div(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
4. floordiv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
5. mod(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
6. mul(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
7. pow(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
8. sub(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
9. truediv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
10. radd(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
11. rdiv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
12. rfloordiv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
13. rmod(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
14. rmul(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
15. rpow(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
16. rsub(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
17. rtruediv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
\f[R]
.fi
.SS Detailed Description
.SS 1. DataFrame.abs()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes absolute numeric value of each element.
.PP
This function only applies to elements that are all numeric.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
tempDF = {
            \[aq]City\[aq]: [\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq],
                     \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
            \[aq]Temperature\[aq]: [-2, 10, 18, 34, -8, -4, 36, 45]
           }

# create pandas dataframe
pdf1 = pd.DataFrame(tempDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   City       Temperature
0       Nagpur     -2
1       Kanpur     10
2       Allahabad  18
3       Kannuaj    34
4       Allahabad  -8
5       Kanpur     -4
6       Kanpur     36
7       Kanpur     45
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# abs() demo
print(fdf1[\[aq]Temperature\[aq]].abs())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Temperature
0       2
1       10
2       18
3       34
4       8
5       4
6       36
7       45
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance.
.SS 2. DataFrame.add(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be added with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform addition operation along the
indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform addition operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs addition operation between two dataframes or dataframe and
scalar value.
It is equivalent to \f[B]`dataframe + other'\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()  
    
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# add() demo with scalar value using operator version
print(fdf1 + 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       15      20
1       16      21
2       14      22
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# add() demo with scalar value using method version
fdf1.add(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       15      20
1       16      21
2       14      22
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are added
with a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# add() demo on two dataframes using operator version
print(fdf1 + fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# add() demo on two dataframes using method version
fdf1.add(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are added.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# add() demo on two dataframes using method version and fill_value = 10
fdf1.add(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       21
2       12      20
\f[R]
.fi
.PP
Here, only common columns in both dataframes are added, excluding the
misiing values.
Other column elements are added with the fill_value = 10 (exluding
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 3. DataFrame.div(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided over the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform division operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs floating division operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]`dataframe / other'\f[R].
.PP
\f[B]It is an alias of truediv().\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# div() demo with scalar value using operator version
print(fdf1 / 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.5     1
1       0.6     1.1
2       0.4     1.19999
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# div() demo with scalar value using method version
fdf1.div(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.5     1
1       0.6     1.1
2       0.4     1.19999
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# div() demo on two dataframes using operator version
print(fdf1 / fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.22222
2       0.5     1.0909
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# div() demo on two dataframes using method version
fdf1.div(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.22222
2       0.5     1.0909
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# div() demo on two dataframes using method version and fill_value = 10
fdf1.div(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.1
2       0.5     1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the fill_value = 10 (excluding
the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 4. DataFrame.floordiv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided over the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform division operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs integer division operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]`dataframe // other'\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# floordiv() demo with scalar value using operator version
print(fdf1 // 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       1
1       0       1
2       0       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# floordiv() demo with scalar value using method version
fdf1.floordiv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       1
1       0       1
2       0       1
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PD 0
.P
.PD
Also, resultant dataframe column elements will contain floor integer
value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# floordiv() demo on two dataframes using operator version
print(fdf1 // fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       2       1
2       0       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# floordiv() demo on two dataframes using method version
fdf1.floordiv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       2       1
2       0       1
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# floordiv() demo on two dataframes using method version and fill_value = 10
fdf1.floordiv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       2       1
2       0       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the fill_value = 10 (excluding
the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 5. DataFrame.mod(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform modulo operation with
the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform modulo operation along the
indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform modulo operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs modulo operation between two dataframes or dataframe and
scalar value.
It is equivalent to \f[B]`dataframe % other'\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame()

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mod() demo with scalar value using operator version
print(fdf1 % 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       0
1       6       1
2       4       2
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mod() demo with scalar value using method version
fdf1.mod(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       0
1       6       1
2       4       2
\f[R]
.fi
.PP
In both versions, modulo operation is performed on all column elements
(axis = 1 by default) by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mod() demo on two dataframes using operator version
print(fdf1 % fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1       3
1       0       2
2       4       1
\f[R]
.fi
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mod() demo on two dataframes using method version
fdf1.mod(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1       3
1       0       2
2       4       1
\f[R]
.fi
.PP
In both versions, modulo is performed on only common columns in both
dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
For example,
.IP
.nf
\f[C]
# mod() demo on two dataframes using method version and fill_value = 10
fdf1.mod(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1       3
1       0       1
2       4       0
\f[R]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes,
excluding the missing values.
Modulo is performed on other column elements using the value 10
(excluding the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 6. DataFrame.mul(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be multiplied with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform multiplication operation along
the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform multiplication operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs multiplication operation between two dataframes or dtaframe
and scalar value.
It is equivalent to \f[B]`dataframe * other'\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mul() demo with scalar value using operator version
print(fdf1 * 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       50      100
1       60      110
2       40      120
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mul() demo with scalar value using method version
fdf1.mul(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       50      100
1       60      110
2       40      120
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are
multiplied with a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }        

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mult() demo on two dataframes using operator version
print(fdf1 * fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mul() demo on two dataframes using method version
fdf1.mul(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are multiplied.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# mul() demo on two dataframes using method version and fill_value = 10
fdf1.mul(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      110
2       32      100
\f[R]
.fi
.PP
Here, only common columns in both dataframes are multiplied, excluding
the missing values.
Other column elements are multiplied with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 7. DataFrame.pow(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform exponential power
operation with the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform exponential power operation
along the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform exponential power operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs exponential power operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]`dataframe ** other'\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }    

# create pandas dataframe
pdf1 = pd.DataFrame()

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# pow() demo with scalar value using operator version
print(fdf1 ** 2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      20
1       12      22
2       8       24
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# pow() demo with scalar value using method version
fdf1.pow(2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      20
1       12      22
2       8       24
\f[R]
.fi
.PP
In both versions, exponential power operation is performed on all column
elements (axis = 1 by default) by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
     \[dq]points\[dq]: [5, 6, 4],
     \[dq]total\[dq]: [10, 11, 12]
    }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# pow() demo on two dataframes using operator version
print(fdf1 ** fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# pow() demo on two dataframes using method version
fdf1.pow(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
In both versions, exponential power operation on only common columns in
both dataframes.
Exponential power operation on other are replaced with NaN values in
resultant dataframe (fill_value = None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# pow() on two dataframes using method version and fill_value = 10
fdf1.pow(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       25      1.00000e+07
1       216     2.59374e+10
2       65536   1.00000e+10
\f[R]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes, excluding the missing values.
Exponential power operation on other column elements is performed with
the value 10 (excluding the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 8. DataFrame.sub(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be subtracted with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform subtraction operation along the
indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform subtraction operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs subtraction operation between two dataframes or dtaframe and
scalar value.
It is equivalent to \f[B]`dataframe - other'\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [5, 6, 4],
          \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# sub() demo with scalar value using operator version
print(fdf1 - 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -5      0
1       -4      1
2       -6      2
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# sub() demo with scalar value using method version
fdf1.sub(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -5      0
1       -4      1
2       -6      2
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are
subtracted by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [5, 6, 4],
          \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# sub() demo on two dataframes using operator version
print(fdf1 - fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       3       3
1       3       2
2       -4      1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# sub() demo on two dataframes using method version
fdf1.sub(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       3       3
1       3       2
2       -4      1
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are subtracted.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# sub() demo on two dataframes using method version and fill_value = 10
fdf1.sub(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       3       3
1       3       1
2       -4      0
\f[R]
.fi
.PP
Here, only common columns in both dataframes are subtracted, excluding
the missing values.
Other column elements are subtracted with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 9. DataFrame.truediv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform division operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs floating division operation between two dataframes or
dtaframe and scalar value.
It is equivalent to \f[B]`dataframe / other'\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [8, 5, 9],
          \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# truediv() demo with scalar value using operator version
print(fdf1 / 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.8     0.3
1       0.5     0.2
2       0.9     0.1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# truediv() demo with scalar value using method version
fdf1.truediv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.8     0.3
1       0.5     0.2
2       0.9     0.1
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [8, 5, 9],
          \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 =  {
          \[dq]points\[dq]: [4, 7, 2],
          \[dq]total\[dq]: [9, 1, 9]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       4       9
1       7       1
2       2       9
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# truediv() demo on two dataframes using operator version
print(fdf1 / fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points    total
0       2         0.333333
1       0.714285  2
2       4.5       0.111111
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# truediv() demo on two dataframes using method version
fdf1.truediv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points    total
0       2         0.333333
1       0.714285  2
2       4.5       0.111111
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# truediv() demo on two dataframes using method version and fill_value = 10
fdf1.truediv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.1
2       0.5     1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 10. DataFrame.radd(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be added with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse addition operation along
the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse addition operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse addition operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]`other + dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse addition of scalar using
operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# radd() demo with scalar value using method version
fdf1.radd(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       15      20
1       16      21
2       14      22
\f[R]
.fi
.PP
Here, it adds the scalar to all columns in dataframe (axis = 1 by
default).
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For examples,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# radd() demo on two dataframes using method version
fdf1.radd(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
Here, only common columns in both dataframes are added.
Column values in other datframe are replaced with NaN values in
resultant dataframe (fill_value = None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# radd() demo on two dataframes using method version and fill_value = 10
fdf1.radd(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       21
2       12      20
\f[R]
.fi
.PP
Here, only common columns in both dataframes are added excluding the
missing values.
The fill_value = 10 is added to both column values in the dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 11. DataFrame.rdiv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse floating division operation between two dataframes
or dataframe and a scalar value.
It is equivalent to \f[B]`other / dataframe'\f[R].
.PP
It is an alias of rtruediv().
.PP
\f[B]Currently, it does not perform reverse division of scalar using
operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rdiv() demo with scalar value using method version
fdf1.rdiv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       1.66666 0.90909
2       2.5     0.833333
\f[R]
.fi
.PP
Here, it uses the scalar to perform division on all column elements in
dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rdiv() demo on two dataframes using method version
fdf1.rdiv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.4     0.7
1       0.5     0.818181
2       2       0.916666
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rdiv() demo on two dataframes using method version and fill_value = 10
fdf1.rdiv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.4     0.7
1       0.5     0.90909
2       2       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is used to divide over column values in other
dataframe (excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 12. DataFrame.rfloordiv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse floating division operation between two dataframes
or dataframe and scalar value.
It is equivalent to \f[B]`other // dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse division of scalar using
operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rfloordiv() demo with scalar value using method version
fdf1.rfloordiv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       1       0
2       2       0
\f[R]
.fi
.PP
Here, it uses the scalar to perform division on all column elements
(axis = 1 by default).
.PD 0
.P
.PD
Also, resultant dataframe column elements will contain floor integer
value.
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rfloordiv() demo on two dataframes using method version
fdf1.rfloordiv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       0       0
2       2       0
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rfloordiv()  demo on two dataframes using method version and fill_value = 10
fdf1.rfloordiv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       0       0
2       2       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is used to divide over column values in other
dataframe (excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 13. DataFrame.rmod(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform modulo operation with
the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse modulo operation along
the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse modulo operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse modulo operation between two dataframes or dataframe
and scalar value.
It is equivalent to \f[B]`other % dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse modulo of scalar using
operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
        \[dq]points\[dq]: [5, 6, 4],
        \[dq]total\[dq]: [50, 40, 20]
       }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rmod() demo with scalar value using method version
fdf1.rmod(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       4       10
2       2       10
\f[R]
.fi
.PP
Here, it uses the scalar to perform modulo operation on all column
elements (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rmod() demo on two dataframes using method version
fdf1.rmod(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       0       11
\f[R]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rmod() demo on two dataframes using method version and fill_value = 10
fdf1.rmod(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       10
2       0       0
\f[R]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes,
excluding the missing values.
The fill_value = 10 is used to perform modulo over column values in
other dataframe (excluding the missing values) and stored in new
dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 14. DataFrame.rmul(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be multiplied with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse multiplication operation
along the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse multiplication operation on
the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse multiplication operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]`other * dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse multiplication of scalar
using operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }   

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rmul() demo with scalar value using method version
fdf1.rmul(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       50      100
1       60      110
2       40      120
\f[R]
.fi
.PP
Here, it uses the scalar to perform multiplication on all column
elements in dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rmul() demo on two dataframes using method version
fdf1.rmul(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
Here, only common columns in both dataframes are multiplied.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rmul() demo on two dataframes using method version and fill_value = 10
fdf1.rmul(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      110
2       32      100
\f[R]
.fi
.PP
Here, only common columns in both dataframes are multiplied, excluding
the missing values.
The fill_value = 10 is multiplied with column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 15. DataFrame.rpow(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perfomr exponential power
operation with the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse exponential power
operation along the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse exponential power operation
on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse exponential power operation between two dataframes
or dtaframe and scalar value.
It is equivalent to \f[B]`other ** dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse exponential power operation
of scalar using operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
        \[dq]points\[dq]: [5, 6, 4],
        \[dq]total\[dq]: [10, 11, 12]
       }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rpow() demo with scalar value using method version
fdf1.rpow(2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       32      1024
1       64      2048
2       16      4096
\f[R]
.fi
.PP
Here, it uses the scalar to perform exponential power operation on all
column elements in dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [5, 6, 4],
          \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rpow() demo on two dataframes using method version
fdf1.rpow(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rpow() demo on two dataframes using method version and fill_value = 10
fdf1.rpow(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       32      2.82475e+08
1       729     9.99999e+10
2       4096    1.00000e+10
\f[R]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes, excluding the missing values.
The fill_value = 10 is used to perform exponential power operation on
column values in other dataframe (excluding the missing values) and
stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 16. DataFrame.rsub(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be subtracted with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse subtraction operation
along the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse subtraction operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse subtraction operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]`other - dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse subtraction of scalar using
operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [5, 6, 4],
          \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rsub() with scalar value using method version
fdf1.rsub(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       0
1       4       -1
2       6       -2
\f[R]
.fi
.PP
Here, it subtracts the scalar to all columns in dataframe (axis = 1 by
default).
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [5, 6, 4],
          \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rsub() on two dataframes using method version
fdf1.rsub(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -3      -3
1       -3      -2
2       4       -1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are subtracted.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rsub() on two dataframes using method version and fill_value = 10
fdf1.rsub(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -3      -3
1       -3      -1
2       4       0
\f[R]
.fi
.PP
Here, only common columns in both dataframes are subtracted, excluding
the missing values.
The fill_value = 10 is subtracted on column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 17. DataFrame.rtruediv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.PD 0
.P
.PD
- Number
.PD 0
.P
.PD
- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
- pandas Series
.PD 0
.P
.PD
- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: `columns')
.PD 0
.P
.PD
- \f[B]1 or `columns'\f[R]: perform reverse division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse floating division operation between two dataframes
or dtaframe and scalar value.
It is equivalent to \f[B]`other / dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse division of scalar using
operator version.
Only method version is supported.\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [8, 5, 9],
          \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rtruediv() demo with scalar value using method version
fdf1.rtruediv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1.25    3.33333
1       2       5
2       1.11111 10
\f[R]
.fi
.PP
Here, it uses the scalar to perform division on all column elements in
dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 =  {
          \[dq]points\[dq]: [8, 5, 9],
          \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 =  {
          \[dq]points\[dq]: [4, 7, 2],
          \[dq]total\[dq]: [9, 1, 9]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       4       9
1       7       1
2       2       9
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rtruediv() demo on two dataframes using method version
fdf1.rtruediv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points    total
0       0.5       3
1       1.39999   0.5
2       0.222222  9
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# rtruediv() demo on two dataframes using method version and fill_value = 10
fdf1.rtruediv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.4     0.7
1       0.5     0.90909
2       2       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is divided with column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SH SEE ALSO
.IP \[bu] 2
\f[B]DataFrame - Introduction\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Generic Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Conversion Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Sorting Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Aggregate Functions\f[R]
