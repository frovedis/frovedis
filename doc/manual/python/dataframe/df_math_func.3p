.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "DataFrame Math Functions" "" "" "" ""
.hy
.SH NAME
.PP
DataFrame Math Functions - this manual contains all the methods for
carrying out mathematical operations.
.SS DESCRIPTION
.PP
Frovedis dataframe has several math functions defined for performing
operations like add(), sub(), mul(), etc.
between two dataframes or between scalar value and dataframe.
These functions return a new frovedis DataFrame instance as a result.
.PP
Also, it contains reverse operations such as radd(), rsub(), rmul(),
etc.
.PP
However, there are some special cases while using frovedis dataframe
with mathematical operations as mentioned below:
.PP
\f[B]Binary operation on two frovedis dataframes having same columns but
different datatypes:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1)
fdf1 = fdf.DataFrame(pdf1)

data2 = {
         \[dq]points\[dq]: [2., 3., 8.],
         \[dq]total\[dq]: [7, 9, 11]
        }

pdf2 = pd.DataFrame(data2)
fdf2 = fdf.DataFrame(pdf2)

print(fdf1 + fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
Here, \f[B]`points'\f[R] column in first dataframe is \f[B]int type\f[R]
and in other dataframe is \f[B]float type\f[R].
.PP
Type conversion occurs for `points' column in resultant dataframe.
.IP
.nf
\f[C]
fdf1.points(int) + fdf2.points(float) -> res.points(float) 
\f[R]
.fi
.PP
Also, binary operation can be performed between columns in dataframe as
well.
.PP
For example,
.IP
.nf
\f[C]
print(fdf1[\[dq]points\[dq]] + fdf2[\[dq]points\[dq]])
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   (points+points)
0       7
1       9
2       12
\f[R]
.fi
.PP
The above expression can also be written as follows:
.IP
.nf
\f[C]
print(fdf1.points + fdf2.points)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   (points+points)
0       7
1       9
2       12
\f[R]
.fi
.PP
\f[B]Binary operation on two frovedis dataframes having atleast one
common column:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1)
fdf1 = fdf.DataFrame(pdf1)

data2 = {
         \[dq]score\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

pdf2 = pd.DataFrame(data2)
fdf2 = fdf.DataFrame(pdf2)

print(fdf1 + fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  score   total
0       NULL    NULL    17
1       NULL    NULL    20
2       NULL    NULL    23
\f[R]
.fi
.PP
Here, the resultant dataframe will contains all columns from input
frovedis dataframes lexicographically.
.PD 0
.P
.PD
Also, binary operation (i.e.\ addition) is performed on the common
column only.
.PP
\f[B]Binary operation on two frovedis dataframes having same columns.
Also, same indices but in different order:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1, index = [1,2,3])
fdf1 = fdf.DataFrame(pdf1)

data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

pdf2 = pd.DataFrame(data2, index = [2,3,1])
fdf2 = fdf.DataFrame(pdf2)

print(fdf1 + fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
1       13      21
2       8       18
3       7       21
\f[R]
.fi
.PP
Binary operation (i.e.\ addition) will be performed between same indices
for each column irrespective of the index order.
.PP
\f[B]Currently, binary operation on two frovedis dataframes having same
columns but different indices is not supported\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1, index = [0,1,2])
fdf1 = fdf.DataFrame(pdf1)

data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

pdf2 = pd.DataFrame(data2, index = [0,1,3])
fdf2 = fdf.DataFrame(pdf2)

print(fdf1 + fdf2)
\f[R]
.fi
.PP
In this case, dataframes have same column but indices are different.
This will raise an exception in frovedis.
.PP
\f[B]Binary operation between columns of frovedis dataframes.
Also, having same indices:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1, index = [1,2,3])
fdf1 = fdf.DataFrame(pdf1)

data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

pdf2 = pd.DataFrame(data2, index = [1,2,3])
fdf2 = fdf.DataFrame(pdf2)

print(fdf1[\[aq]points\[aq]] + fdf2[\[aq]points\[aq]])
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   (points+points)
1       7
2       9
3       12
\f[R]
.fi
.PP
\f[B]Binary operation between two frovedis dataframes having single
column (common) only.
Also, having same indices but different order:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
pdf1 = pd.Series([27, 24, 22, 32, 33, 36, 27, 32],index = [0,1,2,3,4,5,6,7])
pdf2 = pd.Series([23, 34, 35, 45, 23, 50, 52, 34],index = [2,3,1,0,7,4,5,6])

fdf1 = fdf.DataFrame(pdf1)
fdf2 = fdf.DataFrame(pdf2)

print(fdf1 + fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   (0+0)
0       72
1       59
2       45
3       66
4       83
5       88
6       61
7       55
\f[R]
.fi
.PP
Binary operation (i.e.\ addition) will be performed between same indices
irrespective of the index order in the frovedis dataframe.
.PP
\f[B]Currently, binary operation on two frovedis dataframes single
column only but different indices is not supported\f[R].
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
pdf1 = pd.Series([27, 24, 22, 32, 33, 36, 27, 32],index = [0,1,2,3,4,5,6,7])
pdf2 = pd.Series([23, 34, 35, 45, 23, 50, 52, 34],index = [2,3,1,0,8,4,5,9])

fdf1 = fdf.DataFrame(pdf1)
fdf2 = fdf.DataFrame(pdf2)

print(fdf1 + fdf2)
\f[R]
.fi
.PP
In this case, resultant dataframe has single column but indices are
different.
This will raise an exception in frovedis.
.PP
\f[B]Binary operation between frovedis dataframe and scalar value (float
type):\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1)
fdf1 = fdf.DataFrame(pdf1)

print(fdf1 + 12.)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       17      22
1       18      23
2       16      24
\f[R]
.fi
.PP
Here, binary operation (i.e.\ addition) will be performed between the
scalar value of float type on each column of the resultant frovedis
dataframe.
.PP
\f[B]Binary operation between frovedis dataframe and row vector:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1)
fdf1 = fdf.DataFrame(pdf1)

print(fdf1 + [51, 34])
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       56      44
1       57      45
2       55      46
\f[R]
.fi
.PP
Here, binary operation (i.e addition) will be performed between each
element of row vector with each column on the given index of the
frovedis dataframe.
.PP
\f[B]Binary operation between frovedis dataframe and column vector:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

pdf1 = pd.DataFrame(data1)
fdf1 = fdf.DataFrame(pdf1)

print(fdf1[\[aq]points\[aq]] + [21, 34, 45])
print(fdf1[\[aq]total\[aq]] + [21, 34, 45])
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points
0       26
1       40
2       49

index   total
0       31
1       45
2       57
\f[R]
.fi
.PP
Here, binary operation (i.e addition) will be performed between the
array and the given column of frovedis dataframe.
.SS Public Member Functions
.IP
.nf
\f[C]
1. abs()
2. add(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
3. div(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
4. floordiv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
5. mod(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
6. mul(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
7. pow(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
8. sub(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
9. truediv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
10. radd(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
11. rdiv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
12. rfloordiv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
13. rmod(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
14. rmul(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
15. rpow(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
16. rsub(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
17. rtruediv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)  
\f[R]
.fi
.SS Detailed Description
.SS 1. DataFrame.abs()
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It computes absolute numeric value of each element.
.PP
This function only applies to elements that are all numeric.
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import numpy as np
import frovedis.dataframe as fdf

# a dictionary
tempDF = {
          \[aq]City\[aq]: [\[aq]Nagpur\[aq], \[aq]Kanpur\[aq], \[aq]Allahabad\[aq], \[aq]Kannuaj\[aq], \[aq]Allahabad\[aq],
                   \[aq]Kanpur\[aq], \[aq]Kanpur\[aq], \[aq]Kanpur\[aq]],
          \[aq]Temperature\[aq]: [-2, 10, 18, 34, -8, -4, 36, 45]
         }

# create pandas dataframe
pdf1 = pd.DataFrame(tempDF)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   City       Temperature
0       Nagpur     -2
1       Kanpur     10
2       Allahabad  18
3       Kannuaj    34
4       Allahabad  -8
5       Kanpur     -4
6       Kanpur     36
7       Kanpur     45
\f[R]
.fi
.PP
\f[B]Absolute numeric values in a frovedis dataframe:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# abs() demo
print(fdf1[\[aq]Temperature\[aq]].abs())
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   Temperature
0       2
1       10
2       18
3       34
4       8
5       4
6       36
7       45
\f[R]
.fi
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame instance.
.SS 2. DataFrame.add(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be added with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform addition operation along the
indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform addition operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs addition between two operands.
It is equivalent to \f[B]`dataframe + other'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()  
    
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Add a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 + 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       15      20
1       16      21
2       14      22
\f[R]
.fi
.PP
\f[B]Add a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.add(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       15      20
1       16      21
2       14      22
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are added
with a scalar value.
.PP
\f[B]Creating two frovedis dataframes to perform addition:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Add two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 + fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
\f[B]Add two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.add(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are added.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes in order to use fill_value
parameter during addition:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Add two dataframes and using fill_value parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# add() demo on two dataframes using method version and fill_value = 10
fdf1.add(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       21
2       12      20
\f[R]
.fi
.PP
Here, only common columns in both dataframes are added, excluding the
misiing values.
Other column elements are added with the fill_value = 10 (exluding
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 3. DataFrame.div(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided over the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform division operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs floating division operation between two operands.
It is equivalent to \f[B]`dataframe / other'\f[R].
.PP
\f[B]It is an alias of truediv().\f[R]
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Divide a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 / 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.5     1
1       0.6     1.1
2       0.4     1.19999
\f[R]
.fi
.PP
\f[B]Divide a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.div(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.5     1
1       0.6     1.1
2       0.4     1.19999
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PP
\f[B]Creating two frovedis dataframes to perform division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Divide two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 / fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.22222
2       0.5     1.0909
\f[R]
.fi
.PP
\f[B]Divide two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.div(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.22222
2       0.5     1.0909
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes in order to use fill_value
parameter during division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Divide two dataframes and using fill_value parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# div() demo on two dataframes using method version and fill_value = 10
fdf1.div(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.1
2       0.5     1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the fill_value = 10 (excluding
the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 4. DataFrame.floordiv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided over the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform division operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs integer division operation between operands.
It is equivalent to \f[B]`dataframe // other'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Floor Division on a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 // 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       1
1       0       1
2       0       1
\f[R]
.fi
.PP
\f[B]Floor Division on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.floordiv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       1
1       0       1
2       0       1
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PD 0
.P
.PD
Also, resultant dataframe column elements will contain floor integer
value.
.PP
\f[B]Creating two frovedis dataframes to perform floor division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Floor Division on two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 // fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       2       1
2       0       1
\f[R]
.fi
.PP
\f[B]Floor Division on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.floordiv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       2       1
2       0       1
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes in order to use fill_value
parameter during floor division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Floor Division on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# floordiv() demo on two dataframes using method version and fill_value = 10
fdf1.floordiv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       2       1
2       0       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the fill_value = 10 (excluding
the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 5. DataFrame.mod(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform modulo operation with
the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform modulo operation along the
indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform modulo operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs modulo operation between two operands.
It is equivalent to \f[B]`dataframe % other'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame()

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Modulo on a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 % 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       0
1       6       1
2       4       2
\f[R]
.fi
.PP
\f[B]Modulo on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.mod(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       0
1       6       1
2       4       2
\f[R]
.fi
.PP
In both versions, modulo operation is performed on all column elements
(axis = 1 by default) by a scalar value.
.PP
\f[B]Creating two frovedis dataframes to perform modulo:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Modulo on two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 % fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1       3
1       0       2
2       4       1
\f[R]
.fi
.PP
\f[B]Creating two frovedis dataframes to perform modulo, use fill_value
parameter too:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Modulo on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.mod(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1       3
1       0       2
2       4       1
\f[R]
.fi
.PP
In both versions, modulo is performed on only common columns in both
dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Modulo on two dataframes and using fill_value parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mod() demo on two dataframes using method version and fill_value = 10
fdf1.mod(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1       3
1       0       1
2       4       0
\f[R]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes,
excluding the missing values.
Modulo is performed on other column elements using the value 10
(excluding the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 6. DataFrame.mul(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be multiplied with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform multiplication operation along
the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform multiplication operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs multiplication operation between two operands.
It is equivalent to \f[B]`dataframe * other'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Multiply a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 * 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       50      100
1       60      110
2       40      120
\f[R]
.fi
.PP
\f[B]Multiply a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.mul(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       50      100
1       60      110
2       40      120
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are
multiplied with a scalar value.
.PP
\f[B]Creating two frovedis dataframes to perform multiplication:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }        

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Multiply two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 * fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
\f[B]Multiply two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mul() demo on two dataframes using method version
fdf1.mul(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are multiplied.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes in order to use fill_value
parameter during multiplication:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Multiply two dataframes and using fill_value parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# mul() demo on two dataframes using method version and fill_value = 10
fdf1.mul(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      110
2       32      100
\f[R]
.fi
.PP
Here, only common columns in both dataframes are multiplied, excluding
the missing values.
Other column elements are multiplied with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 7. DataFrame.pow(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform exponential power
operation with the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform exponential power operation
along the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform exponential power operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs exponential power operation between two operands.
It is equivalent to \f[B]`dataframe ** other'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }    

# create pandas dataframe
pdf1 = pd.DataFrame()

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Exponential power operation on a scalar value using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 ** 2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      20
1       12      22
2       8       24
\f[R]
.fi
.PP
\f[B]Exponential power operation on a scalar value using method
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.pow(2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      20
1       12      22
2       8       24
\f[R]
.fi
.PP
In both versions, exponential power operation is performed on all column
elements (axis = 1 by default) by a scalar value.
.PP
\f[B]Creating two frovedis dataframes to perform exponential power
operation:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Exponential power operation on two dataframes using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 ** fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
\f[B]Exponential power operation on two dataframes using method
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.pow(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
In both versions, exponential power operation on only common columns in
both dataframes.
Exponential power operation on other are replaced with NaN values in
resultant dataframe (fill_value = None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during exponential power operation:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Exponential power operation on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# pow() on two dataframes using method version and fill_value = 10
fdf1.pow(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       25      1.00000e+07
1       216     2.59374e+10
2       65536   1.00000e+10
\f[R]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes, excluding the missing values.
Exponential power operation on other column elements is performed with
the value 10 (excluding the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 8. DataFrame.sub(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be subtracted with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform subtraction operation along the
indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform subtraction operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs subtraction operation between two operands.
It is equivalent to \f[B]`dataframe - other'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Subtract a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 - 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -5      0
1       -4      1
2       -6      2
\f[R]
.fi
.PP
\f[B]Subtract a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.sub(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -5      0
1       -4      1
2       -6      2
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are
subtracted by a scalar value.
.PP
\f[B]Creating two frovedis dataframes to perform subtraction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Subtract two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 - fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       3       3
1       3       2
2       -4      1
\f[R]
.fi
.PP
\f[B]Subtract two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.sub(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       3       3
1       3       2
2       -4      1
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are subtracted.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during subtraction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Subtract two dataframes and using fill_value parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# sub() demo on two dataframes using method version and fill_value = 10
fdf1.sub(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       3       3
1       3       1
2       -4      0
\f[R]
.fi
.PP
Here, only common columns in both dataframes are subtracted, excluding
the missing values.
Other column elements are subtracted with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 9. DataFrame.truediv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform division operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs floating division operation between two operands.
It is equivalent to \f[B]`dataframe / other'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [8, 5, 9],
         \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
\f[B]Floating Division on a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 / 10)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.8     0.3
1       0.5     0.2
2       0.9     0.1
\f[R]
.fi
.PP
\f[B]Floating Division on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.truediv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.8     0.3
1       0.5     0.2
2       0.9     0.1
\f[R]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PP
\f[B]Creating two frovedis dataframes to perform floating division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [8, 5, 9],
         \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [4, 7, 2],
         \[dq]total\[dq]: [9, 1, 9]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       4       9
1       7       1
2       2       9
\f[R]
.fi
.PP
\f[B]Floating Division on two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf1 / fdf2)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points    total
0       2         0.333333
1       0.714285  2
2       4.5       0.111111
\f[R]
.fi
.PP
\f[B]Floating Division on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
fdf1.truediv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points    total
0       2         0.333333
1       0.714285  2
2       4.5       0.111111
\f[R]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during floating division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Floating Division on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# truediv() demo on two dataframes using method version and fill_value = 10
fdf1.truediv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2.5     1.42857
1       2       1.1
2       0.5     1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 10. DataFrame.radd(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be added with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse addition operation along
the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse addition operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse addition operation between two operands.
It is equivalent to \f[B]`other + dataframe'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Reverse addition on a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 + fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       15      20
1       16      21
2       14      22
\f[R]
.fi
.PP
\f[B]Reverse addition on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# radd() demo with scalar value using method version
fdf1.radd(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       15      20
1       16      21
2       14      22
\f[R]
.fi
.PP
Here, it adds the scalar to all columns in dataframe (axis = 1 by
default).
.PP
\f[B]Creating two frovedis dataframes to perform reverse addition:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For examples,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Reverse addition on two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 + fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
\f[B]Reverse addition on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# radd() demo on two dataframes using method version
fdf1.radd(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       20
2       12      23
\f[R]
.fi
.PP
Here, only common columns in both dataframes are added.
Column values in other datframe are replaced with NaN values in
resultant dataframe (fill_value = None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse addition:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse addition on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# radd() demo on two dataframes using method version and fill_value = 10
fdf1.radd(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       7       17
1       9       21
2       12      20
\f[R]
.fi
.PP
Here, only common columns in both dataframes are added excluding the
missing values.
The fill_value = 10 is added to both column values in the dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 11. DataFrame.rdiv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse floating division operation between two operands.
It is equivalent to \f[B]`other / dataframe'\f[R].
.PP
It is an alias of rtruediv().
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Reverse division on a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 / fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       1.66666 0.90909
2       2.5     0.833333
\f[R]
.fi
.PP
\f[B]Reverse division on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rdiv() demo with scalar value using method version
fdf1.rdiv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       1.66666 0.90909
2       2.5     0.833333
\f[R]
.fi
.PP
Here, it uses the scalar to perform division on all column elements in
dataframe (axis = 1 by default).
.PP
\f[B]Creating two frovedis dataframes to perform reverse division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Reverse division on two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 / fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.4     0.7
1       0.5     0.818181
2       2       0.916666
\f[R]
.fi
.PP
\f[B]Reverse division on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rdiv() demo on two dataframes using method version
fdf1.rdiv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.4     0.7
1       0.5     0.818181
2       2       0.916666
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse division on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rdiv() demo on two dataframes using method version and fill_value = 10
fdf1.rdiv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.4     0.7
1       0.5     0.90909
2       2       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is used to divide over column values in other
dataframe (excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 12. DataFrame.rfloordiv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse floating division operation between two operands.
It is equivalent to \f[B]`other // dataframe'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Reverse floor division on a scalar value using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 // fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       1       0
2       2       0
\f[R]
.fi
.PP
\f[B]Reverse floor division on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rfloordiv() demo with scalar value using method version
fdf1.rfloordiv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       1
1       1       0
2       2       0
\f[R]
.fi
.PP
Here, it uses the scalar to perform division on all column elements
(axis = 1 by default).
.PD 0
.P
.PD
Also, resultant dataframe column elements will contain floor integer
value.
.PP
\f[B]Creating two frovedis dataframes to perform reverse floor
division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Reverse floor division on two dataframes using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 // fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       0       0
2       2       0
\f[R]
.fi
.PP
\f[B]Reverse floor division on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rfloordiv() demo on two dataframes using method version
fdf1.rfloordiv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       0       0
2       2       0
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse floor division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse floor division on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rfloordiv()  demo on two dataframes using method version and fill_value = 10
fdf1.rfloordiv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       0       0
2       2       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is used to divide over column values in other
dataframe (excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 13. DataFrame.rmod(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform modulo operation with
the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse modulo operation along
the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse modulo operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse modulo operation between two operands.
It is equivalent to \f[B]`other % dataframe'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [50, 40, 20]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Reverse modulo on a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 % fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       4       10
2       2       10
\f[R]
.fi
.PP
\f[B]Reverse modulo on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rmod() demo with scalar value using method version
fdf1.rmod(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0       0
1       4       10
2       2       10
\f[R]
.fi
.PP
Here, it uses the scalar to perform modulo operation on all column
elements (axis = 1 by default).
.PP
\f[B]Creating two frovedis dataframes to perform reverse modulo:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Reverse modulo on two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 % fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       0       11
\f[R]
.fi
.PP
\f[B]Reverse modulo on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rmod() demo on two dataframes using method version
fdf1.rmod(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       0       11
\f[R]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse modulo:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse modulo on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rmod() demo on two dataframes using method version and fill_value = 10
fdf1.rmod(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       10
2       0       0
\f[R]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes,
excluding the missing values.
The fill_value = 10 is used to perform modulo over column values in
other dataframe (excluding the missing values) and stored in new
dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 14. DataFrame.rmul(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be multiplied with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse multiplication operation
along the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse multiplication operation on
the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse multiplication operation between two operands.
It is equivalent to \f[B]`other * dataframe'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }   

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Reverse multiplication on a scalar value using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 * fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       50      100
1       60      110
2       40      120
\f[R]
.fi
.PP
\f[B]Reverse multiplication on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rmul() demo with scalar value using method version
fdf1.rmul(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       50      100
1       60      110
2       40      120
\f[R]
.fi
.PP
Here, it uses the scalar to perform multiplication on all column
elements in dataframe (axis = 1 by default).
.PP
\f[B]Creating two frovedis dataframes to perform reverse
multiplication:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Reverse multiplication on two dataframes using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 * fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
\f[B]Reverse multiplication on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rmul() demo on two dataframes using method version
fdf1.rmul(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
Here, only common columns in both dataframes are multiplied.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse multiplication:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse multiplication on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rmul() demo on two dataframes using method version and fill_value = 10
fdf1.rmul(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      110
2       32      100
\f[R]
.fi
.PP
Here, only common columns in both dataframes are multiplied, excluding
the missing values.
The fill_value = 10 is multiplied with column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 15. DataFrame.rpow(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perfomr exponential power
operation with the current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse exponential power
operation along the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse exponential power operation on
the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse exponential power operation between two operands.
It is equivalent to \f[B]`other ** dataframe'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Reverse exponential power operation on a scalar value using
operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 ** fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       32      1024
1       64      2048
2       16      4096
\f[R]
.fi
.PP
\f[B]Reverse exponential power operation on a scalar value using method
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rpow() demo with scalar value using method version
fdf1.rpow(2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       32      1024
1       64      2048
2       16      4096
\f[R]
.fi
.PP
Here, it uses the scalar to perform exponential power operation on all
column elements in dataframe (axis = 1 by default).
.PP
\f[B]Creating two frovedis dataframes to perform reverse exponential
power operation:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }    

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Reverse exponential power operation on two dataframes using
operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 ** fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
\f[B]Reverse exponential power operation on two dataframes using method
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rpow() demo on two dataframes using method version
fdf1.rpow(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       10      70
1       18      99
2       32      132
\f[R]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse exponential power operation:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse exponential power operation on two dataframes and using
fill_value parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rpow() demo on two dataframes using method version and fill_value = 10
fdf1.rpow(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       32      2.82475e+08
1       729     9.99999e+10
2       4096    1.00000e+10
\f[R]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes, excluding the missing values.
The fill_value = 10 is used to perform exponential power operation on
column values in other dataframe (excluding the missing values) and
stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 16. DataFrame.rsub(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be subtracted with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse subtraction operation
along the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse subtraction operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse subtraction operation between two operands.
It is equivalent to \f[B]`other - dataframe'\f[R].
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
\f[B]Reverse subtraction on a scalar value using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 - fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       0
1       4       -1
2       6       -2
\f[R]
.fi
.PP
\f[B]Reverse subtraction on a scalar value using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rsub() with scalar value using method version
fdf1.rsub(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       0
1       4       -1
2       6       -2
\f[R]
.fi
.PP
Here, it subtracts the scalar to all columns in dataframe (axis = 1 by
default).
.PP
\f[B]Creating two frovedis dataframes to perform reverse
subtraction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, 12]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       12
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, 9, 11]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       9
2       8       11
\f[R]
.fi
.PP
\f[B]Reverse subtraction on two dataframes using operator version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 - fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -3      -3
1       -3      -2
2       4       -1
\f[R]
.fi
.PP
\f[B]Reverse subtraction on two dataframes using method version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rsub() on two dataframes using method version
fdf1.rsub(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -3      -3
1       -3      -2
2       4       -1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are subtracted.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse subtraction:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse subtraction on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rsub() on two dataframes using method version and fill_value = 10
fdf1.rsub(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       -3      -3
1       -3      -1
2       4       0
\f[R]
.fi
.PP
Here, only common columns in both dataframes are subtracted, excluding
the missing values.
The fill_value = 10 is subtracted on column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 17. DataFrame.rtruediv(other, axis = `columns', level = None, fill_value = None)
.PP
\f[B]Parameters\f[R]
.PD 0
.P
.PD
\f[B]\f[BI]other\f[B]\f[R]: It can accept single or multiple element
data structure like the following:
.IP \[bu] 2
Number
.PD 0
.P
.PD
.IP \[bu] 2
List having 1 dimension.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
A numpy ndarray having 1 dimension.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
.IP \[bu] 2
pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
.IP \[bu] 2
pandas Series
.PD 0
.P
.PD
.IP \[bu] 2
frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[BI]axis\f[B]\f[R]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: `columns')
.IP \[bu] 2
\f[B]1 or `columns'\f[R]: perform reverse division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[BI]level\f[B]\f[R]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[BI]fill_value\f[B]\f[R]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
Irrespective of the specified value, if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[R]
.PD 0
.P
.PD
It performs reverse floating division operation between two operands.
It is equivalent to \f[B]`other / dataframe'\f[R].
.PP
\f[B]Currently, it does not perform reverse division of scalar using
operator version.
Only method version is supported.\f[R]
.PP
\f[B]Creating frovedis DataFrame from pandas DataFrame:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [8, 5, 9],
         \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
\f[B]Reverse floating division on a scalar value using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(10 / fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1.25    3.33333
1       2       5
2       1.11111 10
\f[R]
.fi
.PP
\f[B]Reverse floating division on a scalar value using method
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rtruediv() demo with scalar value using method version
fdf1.rtruediv(10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       1.25    3.33333
1       2       5
2       1.11111 10
\f[R]
.fi
.PP
Here, it uses the scalar to perform division on all column elements in
dataframe (axis = 1 by default).
.PP
\f[B]Creating two frovedis dataframes to perform reverse floating
division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [8, 5, 9],
         \[dq]total\[dq]: [3, 2, 1]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       8       3
1       5       2
2       9       1
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [4, 7, 2],
         \[dq]total\[dq]: [9, 1, 9]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       4       9
1       7       1
2       2       9
\f[R]
.fi
.PP
\f[B]Reverse floating division on two dataframes using operator
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
print(fdf2 / fdf1)
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points    total
0       0.5       3
1       1.39999   0.5
2       0.222222  9
\f[R]
.fi
.PP
\f[B]Reverse floating division on two dataframes using method
version:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rtruediv() demo on two dataframes using method version
fdf1.rtruediv(other = fdf2).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points    total
0       0.5       3
1       1.39999   0.5
2       0.222222  9
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]Creating two frovedis dataframes and use fill_value parameter
during reverse floating division:\f[R]
.PP
For example,
.IP
.nf
\f[C]
import pandas as pd
import frovedis.dataframe as fdf

# a dictionary
data1 = {
         \[dq]points\[dq]: [5, 6, 4],
         \[dq]total\[dq]: [10, 11, np.nan]
        }

# create pandas dataframe
pdf1 = pd.DataFrame(data1)

# create frovedis dataframe
fdf1 = fdf.DataFrame(pdf1)

# display the frovedis dataframe
fdf1.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       5       10
1       6       11
2       4       NULL
\f[R]
.fi
.PP
For example,
.IP
.nf
\f[C]
# a dictionary
data2 = {
         \[dq]points\[dq]: [2, 3, 8],
         \[dq]total\[dq]: [7, np.nan, np.nan]
        }

# create pandas dataframe
pdf2 = pd.DataFrame(data2)

# create frovedis dataframe
fdf2 = fdf.DataFrame(pdf2)

# display the frovedis dataframe
fdf2.show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       2       7
1       3       NULL
2       8       NULL
\f[R]
.fi
.PP
\f[B]Reverse floating division on two dataframes and using fill_value
parameter:\f[R]
.PP
For example,
.IP
.nf
\f[C]
# rtruediv() demo on two dataframes using method version and fill_value = 10
fdf1.rtruediv(other = fdf2, fill_value = 10).show()
\f[R]
.fi
.PP
Output
.IP
.nf
\f[C]
index   points  total
0       0.4     0.7
1       0.5     0.90909
2       2       1
\f[R]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is divided with column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[R]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SH SEE ALSO
.IP \[bu] 2
\f[B]DataFrame - Introduction\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Indexing Operations\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Generic Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Conversion Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Sorting Functions\f[R]
.PD 0
.P
.PD
.IP \[bu] 2
\f[B]DataFrame - Aggregate Functions\f[R]
