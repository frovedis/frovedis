.TH "DataFrame Binary Operator Functions" "" "" "" ""
.SH NAME
.PP
DataFrame Binary Operator Functions \- methods for carrying out binary
operations like add(), sub(), etc and related functions like radd(),
rsub(), etc.
for carrying out reverse binary operations are illustrated here.
.SH SYNOPSIS
.IP
.nf
\f[C]
frovedis.dataframe.df.DataFrame(df\ =\ None,\ is_series\ =\ False)\ \ 
\f[]
.fi
.SS Public Member Functions
.PP
add(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
radd(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
div(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
rdiv(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
floordiv(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PD 0
.P
.PD
rfloordiv(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PD 0
.P
.PD
mod(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
rmod(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
mul(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
rmul(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
pow(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
rpow(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
sub(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
rsub(other, axis = \[aq]columns\[aq], level = None, fill_value = None)
.PD 0
.P
.PD
truediv(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PD 0
.P
.PD
rtruediv(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.SS Detailed Description
.SS 1. add(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be added with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform addition operation along the
indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform addition operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs addition operation between two dataframes or dataframe and
scalar value.
It is equivalent to \f[B]\[aq]dataframe + other\[aq]\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()\ \ 
\ \ \ \ 
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ add()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ +\ 10)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 15\ \ \ \ \ \ 20
1\ \ \ \ \ \ \ 16\ \ \ \ \ \ 21
2\ \ \ \ \ \ \ 14\ \ \ \ \ \ 22
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ add()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.add(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 15\ \ \ \ \ \ 20
1\ \ \ \ \ \ \ 16\ \ \ \ \ \ 21
2\ \ \ \ \ \ \ 14\ \ \ \ \ \ 22
\f[]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are added
with a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ add()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ +\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 7\ \ \ \ \ \ \ 17
1\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 20
2\ \ \ \ \ \ \ 12\ \ \ \ \ \ 23
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ add()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.add(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 7\ \ \ \ \ \ \ 17
1\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 20
2\ \ \ \ \ \ \ 12\ \ \ \ \ \ 23
\f[]
.fi
.PP
In both versions, only common columns in both dataframes are added.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ add()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.add(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 7\ \ \ \ \ \ \ 17
1\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 21
2\ \ \ \ \ \ \ 12\ \ \ \ \ \ 20
\f[]
.fi
.PP
Here, only common columns in both dataframes are added, excluding the
misiing values.
Other column elements are
.PD 0
.P
.PD
added with the fill_value = 10 (exluding missing values) in resultant
dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 2. radd(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be added with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse addition operation along
the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse addition operation
on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse addition operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]\[aq]other + dataframe\[aq]\f[].
.PP
Currently, it does not perform reverse addition of scalar using operator
version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ radd()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.radd(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 15\ \ \ \ \ \ 20
1\ \ \ \ \ \ \ 16\ \ \ \ \ \ 21
2\ \ \ \ \ \ \ 14\ \ \ \ \ \ 22
\f[]
.fi
.PP
Here, it adds the scalar to all columns in dataframe (axis = 1 by
default).
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For examples,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ radd()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.radd(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 7\ \ \ \ \ \ \ 17
1\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 20
2\ \ \ \ \ \ \ 12\ \ \ \ \ \ 23
\f[]
.fi
.PP
Here, only common columns in both dataframes are added.
Column values in other datframe are replaced with NaN values in
resultant dataframe (fill_value = None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ radd()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.radd(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 7\ \ \ \ \ \ \ 17
1\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 21
2\ \ \ \ \ \ \ 12\ \ \ \ \ \ 20
\f[]
.fi
.PP
Here, only common columns in both dataframes are added excluding the
missing values.
The fill_value = 10 is added to both column values in the dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 3. div(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided over the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs floating division operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]\[aq]dataframe / other\[aq]\f[].
.PD 0
.P
.PD
It is an alias of truediv().
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ div()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ /\ 10)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0.5\ \ \ \ \ 1
1\ \ \ \ \ \ \ 0.6\ \ \ \ \ 1.1
2\ \ \ \ \ \ \ 0.4\ \ \ \ \ 1.19999
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ div()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.div(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0.5\ \ \ \ \ 1
1\ \ \ \ \ \ \ 0.6\ \ \ \ \ 1.1
2\ \ \ \ \ \ \ 0.4\ \ \ \ \ 1.19999
\f[]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ div()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ /\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2.5\ \ \ \ \ 1.42857
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1.22222
2\ \ \ \ \ \ \ 0.5\ \ \ \ \ 1.0909
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ div()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.div(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2.5\ \ \ \ \ 1.42857
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1.22222
2\ \ \ \ \ \ \ 0.5\ \ \ \ \ 1.0909
\f[]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ div()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.div(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2.5\ \ \ \ \ 1.42857
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1.1
2\ \ \ \ \ \ \ 0.5\ \ \ \ \ 1
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the fill_value = 10 (excluding
the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 4. rdiv(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse division operation
on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse floating division operation between two dataframes
or dataframe and a scalar value.
It is equivalent to \f[B]\[aq]other / dataframe\[aq]\f[].
.PD 0
.P
.PD
It is an alias of rtruediv().
.PD 0
.P
.PD
Currently, it does not perform reverse division of scalar using operator
version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rdiv()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.rdiv(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
1\ \ \ \ \ \ \ 1.66666\ 0.90909
2\ \ \ \ \ \ \ 2.5\ \ \ \ \ 0.833333
\f[]
.fi
.PP
Here, it uses the scalar to perform division on all column elements in
dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rdiv()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.rdiv(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0.4\ \ \ \ \ 0.7
1\ \ \ \ \ \ \ 0.5\ \ \ \ \ 0.818181
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 0.916666
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rdiv()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.rdiv(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0.4\ \ \ \ \ 0.7
1\ \ \ \ \ \ \ 0.5\ \ \ \ \ 0.90909
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is used to divide over column values in other
dataframe (excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 5. floordiv(other, axis = \[aq]columns\[aq], level = None,
fill_value = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided over the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs integer division operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]\[aq]dataframe // other\[aq]\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ floordiv()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ //\ 10)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
1\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ floordiv()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.floordiv(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
1\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PD 0
.P
.PD
Also, resultant dataframe column elements will contain floor integer
value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ floordiv()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ //\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ floordiv()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.floordiv(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ floordiv()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.floordiv(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are
.PD 0
.P
.PD
divided with the fill_value = 10 (excluding the missing values) in
resultant dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 6. rfloordiv(other, axis = \[aq]columns\[aq], level = None,
fill_value = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse division operation
on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse floating division operation between two dataframes
or dataframe and scalar value.
It is equivalent to \f[B]\[aq]other // dataframe\[aq]\f[].
.PP
Currently, it does not perform reverse division of scalar using operator
version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rfloordiv()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.rfloordiv(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
1\ \ \ \ \ \ \ 1\ \ \ \ \ \ \ 0
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 0
\f[]
.fi
.PP
Here, it uses the scalar to perform division on all column elements
(axis = 1 by default).
.PD 0
.P
.PD
Also, resultant dataframe column elements will contain floor integer
value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rfloordiv()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.rfloordiv(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 0
1\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 0
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 0
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rfloordiv()\ \ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.rfloordiv(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 0
1\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 0
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is used to divide over column values in other
dataframe (excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 7. mod(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform modulo operation with
the current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform modulo operation along the
indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform modulo operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs modulo operation between two dataframes or dataframe and
scalar value.
It is equivalent to \f[B]\[aq]dataframe % other\[aq]\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame()

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mod()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ %\ 10)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 0
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 2
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mod()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.mod(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 0
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 2
\f[]
.fi
.PP
In both versions, modulo operation is performed on all column elements
(axis = 1 by default) by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mod()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ %\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 1\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mod()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.mod(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 1\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
In both versions, modulo is performed on only common columns in both
dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
For example,
.IP
.nf
\f[C]
#\ mod()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.mod(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 1\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 0
\f[]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes,
excluding the missing values.
Modulo is performed on other column elements using the value 10
(excluding the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 8. rmod(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform modulo operation with
the current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse modulo operation along
the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse modulo operation on
the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse modulo operation between two dataframes or dataframe
and scalar value.
It is equivalent to \f[B]\[aq]other % dataframe\[aq]\f[].
.PP
Currently, it does not perform reverse modulo of scalar using operator
version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ "total":\ [50,\ 40,\ 20]
\ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rmod()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.rmod(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 0
1\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 10
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 10
\f[]
.fi
.PP
Here, it uses the scalar to perform modulo operation on all column
elements (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }\ \ \ \ 

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rmod()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.rmod(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rmod()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.rmod(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 10
2\ \ \ \ \ \ \ 0\ \ \ \ \ \ \ 0
\f[]
.fi
.PP
Here, modulo is performed on only common columns in both dataframes,
excluding the missing values.
The fill_value = 10 is used to perform modulo over column values in
other dataframe (excluding the missing values) and stored in new
dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 9. mul(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be multiplied with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform multiplication operation along
the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform multiplication operation on
the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PD 0
.P
.PD
s \f[B]Purpose\f[]
.PD 0
.P
.PD
It performs multiplication operation between two dataframes or dtaframe
and scalar value.
It is equivalent to \f[B]\[aq]dataframe * other\[aq]\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mul()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ *\ 10)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 50\ \ \ \ \ \ 100
1\ \ \ \ \ \ \ 60\ \ \ \ \ \ 110
2\ \ \ \ \ \ \ 40\ \ \ \ \ \ 120
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mul()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.mul(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 50\ \ \ \ \ \ 100
1\ \ \ \ \ \ \ 60\ \ \ \ \ \ 110
2\ \ \ \ \ \ \ 40\ \ \ \ \ \ 120
\f[]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are
multiplied with a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }\ \ \ \ \ \ \ \ 

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mult()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ *\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 99
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 132
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mul()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.mul(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 99
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 132
\f[]
.fi
.PP
In both versions, only common columns in both dataframes are multiplied.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ mul()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.mul(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 110
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 100
\f[]
.fi
.PP
Here, only common columns in both dataframes are multiplied, excluding
the missing values.
Other column elements are multiplied with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 10. rmul(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be multiplied with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse multiplication operation
along the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse multiplication
operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse multiplication operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]\[aq]other * dataframe\[aq]\f[].
.PP
Currently, it does not perform reverse multiplication of scalar using
operator version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }\ \ \ 

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rmul()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.rmul(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 50\ \ \ \ \ \ 100
1\ \ \ \ \ \ \ 60\ \ \ \ \ \ 110
2\ \ \ \ \ \ \ 40\ \ \ \ \ \ 120
\f[]
.fi
.PP
Here, it uses the scalar to perform multiplication on all column
elements in dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }\ \ \ \ 

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rmul()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.rmul(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 99
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 132
\f[]
.fi
.PP
Here, only common columns in both dataframes are multiplied.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rmul()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.rmul(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 110
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 100
\f[]
.fi
.PP
Here, only common columns in both dataframes are multiplied, excluding
the missing values.
The fill_value = 10 is multiplied with column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 11. pow(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perform exponential power
operation with the current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform exponential power operation
along the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform exponential power operation
on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs exponential power operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]\[aq]dataframe \f[] other\[aq]**.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }\ \ \ \ 

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame()

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ pow()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ **\ 2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 20
1\ \ \ \ \ \ \ 12\ \ \ \ \ \ 22
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 24
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ pow()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.pow(2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 20
1\ \ \ \ \ \ \ 12\ \ \ \ \ \ 22
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 24
\f[]
.fi
.PP
In both versions, exponential power operation is performed on all column
elements (axis = 1 by default) by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }\ \ \ \ 

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ pow()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ **\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 99
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 132
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ pow()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.pow(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 99
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 132
\f[]
.fi
.PP
In both versions, exponential power operation on only common columns in
both dataframes.
Exponential power operation on other are replaced with NaN values in
resultant dataframe (fill_value = None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ pow()\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.pow(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 25\ \ \ \ \ \ 1.00000e+07
1\ \ \ \ \ \ \ 216\ \ \ \ \ 2.59374e+10
2\ \ \ \ \ \ \ 65536\ \ \ 1.00000e+10
\f[]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes, excluding the missing values.
Exponential power operation on other column elements is performed with
the value 10 (excluding the missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 12. rpow(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to perfomr exponential power
operation with the current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse exponential power
operation along the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse exponential power
operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse exponential power operation between two dataframes
or dtaframe and scalar value.
It is equivalent to \f[B]\[aq]other \f[] dataframe\[aq]**.
.PP
Currently, it does not perform reverse exponential power operation of
scalar using operator version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rpow()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.rpow(2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 32\ \ \ \ \ \ 1024
1\ \ \ \ \ \ \ 64\ \ \ \ \ \ 2048
2\ \ \ \ \ \ \ 16\ \ \ \ \ \ 4096
\f[]
.fi
.PP
Here, it uses the scalar to perform exponential power operation on all
column elements in dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }\ \ \ \ 

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rpow()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.rpow(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 10\ \ \ \ \ \ 70
1\ \ \ \ \ \ \ 18\ \ \ \ \ \ 99
2\ \ \ \ \ \ \ 32\ \ \ \ \ \ 132
\f[]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rpow()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.rpow(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 32\ \ \ \ \ \ 2.82475e+08
1\ \ \ \ \ \ \ 729\ \ \ \ \ 9.99999e+10
2\ \ \ \ \ \ \ 4096\ \ \ \ 1.00000e+10
\f[]
.fi
.PP
Here, exponential power operation is performed on only common columns in
both dataframes, excluding the missing values.
The fill_value = 10 is used to perform exponential power operation on
column values in other dataframe (excluding the missing values) and
stored in new dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 13. sub(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be subtracted with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform subtraction operation along the
indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform subtraction operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs subtraction operation between two dataframes or dtaframe and
scalar value.
It is equivalent to \f[B]\[aq]dataframe \- other\[aq]\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sub()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ \-\ 10)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ \-5\ \ \ \ \ \ 0
1\ \ \ \ \ \ \ \-4\ \ \ \ \ \ 1
2\ \ \ \ \ \ \ \-6\ \ \ \ \ \ 2
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sub()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.sub(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ \-5\ \ \ \ \ \ 0
1\ \ \ \ \ \ \ \-4\ \ \ \ \ \ 1
2\ \ \ \ \ \ \ \-6\ \ \ \ \ \ 2
\f[]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are
subtracted by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sub()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ \-\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ \-4\ \ \ \ \ \ 1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sub()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.sub(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ \-4\ \ \ \ \ \ 1
\f[]
.fi
.PP
In both versions, only common columns in both dataframes are subtracted.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ sub()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.sub(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ \-4\ \ \ \ \ \ 0
\f[]
.fi
.PP
Here, only common columns in both dataframes are subtracted, excluding
the missing values.
Other column elements are subtracted with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 14. rsub(other, axis = \[aq]columns\[aq], level = None, fill_value =
None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be subtracted with the
current dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse subtraction operation
along the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse subtraction
operation on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse subtraction operation between two dataframes or
dataframe and scalar value.
It is equivalent to \f[B]\[aq]other \- dataframe\[aq]\f[].
.PP
Currently, it does not perform reverse subtraction of scalar using
operator version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rsub()\ with\ scalar\ value\ using\ method\ version
fdf1.rsub(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 0
1\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ \-1
2\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ \-2
\f[]
.fi
.PP
Here, it subtracts the scalar to all columns in dataframe (axis = 1 by
default).
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ 12]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 12
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ 9,\ 11]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ 9
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 11
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rsub()\ on\ two\ dataframes\ using\ method\ version
fdf1.rsub(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ \-3\ \ \ \ \ \ \-3
1\ \ \ \ \ \ \ \-3\ \ \ \ \ \ \-2
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ \-1
\f[]
.fi
.PP
Here, only common columns in both dataframes are subtracted.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rsub()\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.rsub(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ \-3\ \ \ \ \ \ \-3
1\ \ \ \ \ \ \ \-3\ \ \ \ \ \ \-1
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 0
\f[]
.fi
.PP
Here, only common columns in both dataframes are subtracted, excluding
the missing values.
The fill_value = 10 is subtracted on column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 15. truediv(other, axis = \[aq]columns\[aq], level = None,
fill_value = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform division operation along the
indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform division operation on the
columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs floating division operation between two dataframes or
dtaframe and scalar value.
It is equivalent to \f[B]\[aq]dataframe / other\[aq]\f[].
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [8,\ 5,\ 9],
\ \ \ \ \ \ \ \ \ \ "total":\ [3,\ 2,\ 1]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ truediv()\ demo\ with\ scalar\ value\ using\ operator\ version
print(fdf1\ /\ 10)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0.8\ \ \ \ \ 0.3
1\ \ \ \ \ \ \ 0.5\ \ \ \ \ 0.2
2\ \ \ \ \ \ \ 0.9\ \ \ \ \ 0.1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ truediv()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.truediv(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0.8\ \ \ \ \ 0.3
1\ \ \ \ \ \ \ 0.5\ \ \ \ \ 0.2
2\ \ \ \ \ \ \ 0.9\ \ \ \ \ 0.1
\f[]
.fi
.PP
In both versions, all column elements (axis = 1 by default) are divied
by a scalar value.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [8,\ 5,\ 9],
\ \ \ \ \ \ \ \ \ \ "total":\ [3,\ 2,\ 1]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [4,\ 7,\ 2],
\ \ \ \ \ \ \ \ \ \ "total":\ [9,\ 1,\ 9]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 9
1\ \ \ \ \ \ \ 7\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 9
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ truediv()\ demo\ on\ two\ dataframes\ using\ operator\ version
print(fdf1\ /\ fdf2)
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ \ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ \ \ 0.333333
1\ \ \ \ \ \ \ 0.714285\ \ 2
2\ \ \ \ \ \ \ 4.5\ \ \ \ \ \ \ 0.111111
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ truediv()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.truediv(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ \ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ \ \ 0.333333
1\ \ \ \ \ \ \ 0.714285\ \ 2
2\ \ \ \ \ \ \ 4.5\ \ \ \ \ \ \ 0.111111
\f[]
.fi
.PP
In both versions, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ truediv()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.truediv(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2.5\ \ \ \ \ 1.42857
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1.1
2\ \ \ \ \ \ \ 0.5\ \ \ \ \ 1
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
Other column elements are divided with the value 10 (excluding the
missing values) in resultant dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
.SS 16. rtruediv(other, axis = \[aq]columns\[aq], level = None,
fill_value = None)
.PP
\f[B]Parameters\f[]
.PD 0
.P
.PD
\f[B]\f[I]other\f[]\f[]: It can accept single or multiple element data
structure like the following:
.PD 0
.P
.PD
\- Number
.PD 0
.P
.PD
\- List.
Currently, this method supports operation on only list of numeric
values.
.PD 0
.P
.PD
\- A numpy ndarray.
Currently, this method supports operation on only an array of numeric
values.
.PD 0
.P
.PD
\- pandas DataFrame.
It must not be an empty dataframe.
.PD 0
.P
.PD
\- pandas Series
.PD 0
.P
.PD
\- frovedis DataFrame.
It must not be an empty dataframe.
.PP
Any of these is considered as the value to be divided with the current
dataframe.
.PD 0
.P
.PD
\f[B]\f[I]axis\f[]\f[]: It accepts an integer or string object as
parameter.
It is used to decide whether to perform reverse division operation along
the indices or by column labels.
(Default: \[aq]columns\[aq])
.PD 0
.P
.PD
\- \f[B]1 or \[aq]columns\[aq]\f[]: perform reverse division operation
on the columns.
Currently, axis = 1 is supported in this method.
.PP
\f[B]\f[I]level\f[]\f[]: This is an unused parameter.
(Default: None)
.PD 0
.P
.PD
\f[B]\f[I]fill_value\f[]\f[]: It accepts scalar values or None.
It fills existing missing (NaN) values, and any new element needed for
successful dataframe alignment, with this value before computation.
(Default: None)
.PD 0
.P
.PD
When it is either None or not None and if data in both corresponding
dataframe locations is missing, then the result will be missing
(contains NaNs).
.PP
\f[B]Purpose\f[]
.PD 0
.P
.PD
It performs reverse floating division operation between two dataframes
or dtaframe and scalar value.
It is equivalent to \f[B]\[aq]other / dataframe\[aq]\f[].
.PP
Currently, it does not perform reverse division of scalar using operator
version.
Only method version is supported.
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [8,\ 5,\ 9],
\ \ \ \ \ \ \ \ \ \ "total":\ [3,\ 2,\ 1]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rtruediv()\ demo\ with\ scalar\ value\ using\ method\ version
fdf1.rtruediv(10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 1.25\ \ \ \ 3.33333
1\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 5
2\ \ \ \ \ \ \ 1.11111\ 10
\f[]
.fi
.PP
Here, it uses the scalar to perform division on all column elements in
dataframe (axis = 1 by default).
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [8,\ 5,\ 9],
\ \ \ \ \ \ \ \ \ \ "total":\ [3,\ 2,\ 1]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 2
2\ \ \ \ \ \ \ 9\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ \ {
\ \ \ \ \ \ \ \ \ \ "points":\ [4,\ 7,\ 2],
\ \ \ \ \ \ \ \ \ \ "total":\ [9,\ 1,\ 9]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ 9
1\ \ \ \ \ \ \ 7\ \ \ \ \ \ \ 1
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 9
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rtruediv()\ demo\ on\ two\ dataframes\ using\ method\ version
fdf1.rtruediv(other\ =\ fdf2).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ \ \ total
0\ \ \ \ \ \ \ 0.5\ \ \ \ \ \ \ 3
1\ \ \ \ \ \ \ 1.39999\ \ \ 0.5
2\ \ \ \ \ \ \ 0.222222\ \ 9
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided.
Other are replaced with NaN values in resultant dataframe (fill_value =
None by default).
.PP
\f[B]When fill_value is not None,\f[]
.PP
For example,
.IP
.nf
\f[C]
import\ pandas\ as\ pd
import\ frovedis.dataframe\ as\ fdf

#\ a\ dictionary
data1\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [5,\ 6,\ 4],
\ \ \ \ \ \ \ \ \ "total":\ [10,\ 11,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf1\ =\ pd.DataFrame(data1)

#\ create\ frovedis\ dataframe
fdf1\ =\ fdf.DataFrame(pdf1)

#\ display\ the\ frovedis\ dataframe
fdf1.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 5\ \ \ \ \ \ \ 10
1\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ 11
2\ \ \ \ \ \ \ 4\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ a\ dictionary
data2\ =\ {
\ \ \ \ \ \ \ \ \ "points":\ [2,\ 3,\ 8],
\ \ \ \ \ \ \ \ \ "total":\ [7,\ np.nan,\ np.nan]
\ \ \ \ \ \ \ \ }

#\ create\ pandas\ dataframe
pdf2\ =\ pd.DataFrame(data2)

#\ create\ frovedis\ dataframe
fdf2\ =\ fdf.DataFrame(pdf2)

#\ display\ the\ frovedis\ dataframe
fdf2.show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 7
1\ \ \ \ \ \ \ 3\ \ \ \ \ \ \ NULL
2\ \ \ \ \ \ \ 8\ \ \ \ \ \ \ NULL
\f[]
.fi
.PP
For example,
.IP
.nf
\f[C]
#\ rtruediv()\ demo\ on\ two\ dataframes\ using\ method\ version\ and\ fill_value\ =\ 10
fdf1.rtruediv(other\ =\ fdf2,\ fill_value\ =\ 10).show()
\f[]
.fi
.PP
Output
.IP
.nf
\f[C]
index\ \ \ points\ \ total
0\ \ \ \ \ \ \ 0.4\ \ \ \ \ 0.7
1\ \ \ \ \ \ \ 0.5\ \ \ \ \ 0.90909
2\ \ \ \ \ \ \ 2\ \ \ \ \ \ \ 1
\f[]
.fi
.PP
Here, only common columns in both dataframes are divided, excluding the
missing values.
The fill_value = 10 is divided with column values in other dataframe
(excluding the missing values) and stored in new dataframe.
.PP
\f[B]Return Value\f[]
.PD 0
.P
.PD
It returns a frovedis DataFrame which contains the result of arithmetic
operation.
